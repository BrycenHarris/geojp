{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geojp","text":"<p>A python package for my Geospacial Analysis class</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://BrycenHarris.github.io/geojp</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to Geojp: Geojp is a Python package designed to aid developers and data user alike in creating Heat Maps and interactive Time Slider Maps effortlessly. Whether you're visualizing spatial trends, analyzing temporal patterns, or simply exploring geographic data, Geojp equips you with the tools to bring your maps to life with ease.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>Geojp offers two useful feature that will aid the geospatial community Those two features are a Time Slider and Heat Map.</p> <p>Creating time slider animations: Geojp enables the creation of animations from both vector and raster data, allowing you to visualize temporal changes in your geospatial datasets.</p> <p></p> <p>Creating Heat Maps: Geojp supports the creation of heat maps to visualize data density.</p> <p></p>"},{"location":"#package-walkthrough-video","title":"Package Walkthrough Video","text":"<p>https://youtu.be/E36S2q0E0i8 </p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#geojp.common.The_national_map_USGS","title":"<code> The_national_map_USGS        </code>","text":"<p>The national map is a collection of topological datasets, maintained by the USGS.</p> <p>It provides an API endpoint which can be used to find downloadable links for the products offered.     - Full description of datasets available can retrieved.       This consists of metadata such as detail description and publication dates.     - A wide range of dataformats are available</p> <p>This class is a tiny wrapper to find and download files using the API.</p> <p>More complete documentation for the API can be found at     https://apps.nationalmap.gov/tnmaccess/#/</p> Source code in <code>geojp/common.py</code> <pre><code>class The_national_map_USGS:\n    \"\"\"\n    The national map is a collection of topological datasets, maintained by the USGS.\n\n    It provides an API endpoint which can be used to find downloadable links for the products offered.\n        - Full description of datasets available can retrieved.\n          This consists of metadata such as detail description and publication dates.\n        - A wide range of dataformats are available\n\n    This class is a tiny wrapper to find and download files using the API.\n\n    More complete documentation for the API can be found at\n        https://apps.nationalmap.gov/tnmaccess/#/\n    \"\"\"\n\n    def __init__(self):\n        self.api_endpoint = r\"https://tnmaccess.nationalmap.gov/api/v1/\"\n        self.DS = self.datasets_full\n\n    @property\n    def datasets_full(self) -&gt; list:\n        \"\"\"\n        Full description of datasets provided.\n        Returns a JSON or empty list.\n        \"\"\"\n        link = f\"{self.api_endpoint}datasets?\"\n        try:\n            return requests.get(link).json()\n        except Exception:\n            print(f\"Failed to load metadata from The National Map API endpoint\\n{link}\")\n            return []\n\n    @property\n    def prodFormats(self) -&gt; list:\n        \"\"\"\n        Return all datatypes available in any of the collections.\n        Note that \"All\" is only peculiar to one dataset.\n        \"\"\"\n        return set(i[\"displayName\"] for ds in self.DS for i in ds[\"formats\"])\n\n    @property\n    def datasets(self) -&gt; list:\n        \"\"\"\n        Returns a list of dataset tags (most common human readable self description for specific datasets).\n        \"\"\"\n        return set(y[\"sbDatasetTag\"] for x in self.DS for y in x[\"tags\"])\n\n    def parse_region(self, region, geopandas_args={}) -&gt; list:\n        \"\"\"\n\n        Translate a Vector dataset to its bounding box.\n\n        Args:\n            region (str | list): an URL|filepath to a vector dataset to a polygon\n            geopandas_reader_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n                Used for reading a region URL|filepath.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(region, str):\n            if region.startswith(\"http\"):\n                region = github_raw_url(region)\n                region = download_file(region)\n            elif not os.path.exists(region):\n                raise ValueError(\"region must be a path or a URL to a vector dataset.\")\n\n            roi = gpd.read_file(region, **geopandas_args)\n            roi = roi.to_crs(epsg=4326)\n            return roi.total_bounds\n        return region\n\n    def download_tiles(\n        self, region=None, out_dir=None, download_args={}, geopandas_args={}, API={}\n    ) -&gt; None:\n        \"\"\"\n\n        Download the US National Elevation Datasets (NED) for a region.\n\n        Args:\n            region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n                Alternatively you could use API parameters such as polygon or bbox.\n            out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n            download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n            geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n                Used for reading a region URL|filepath.\n            API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n                Exposes most of the documented API. Defaults to {}.\n\n        Returns:\n            None\n        \"\"\"\n\n        if os.environ.get(\"USE_MKDOCS\") is not None:\n            return\n\n        if out_dir is None:\n            out_dir = os.getcwd()\n        else:\n            out_dir = os.path.abspath(out_dir)\n\n        tiles = self.find_tiles(\n            region, return_type=\"list\", geopandas_args=geopandas_args, API=API\n        )\n        T = len(tiles)\n        errors = 0\n        done = 0\n\n        for i, link in enumerate(tiles):\n            file_name = os.path.basename(link)\n            out_name = os.path.join(out_dir, file_name)\n            if i &lt; 5 or (i &lt; 50 and not (i % 5)) or not (i % 20):\n                print(f\"Downloading {i+1} of {T}: {file_name}\")\n            try:\n                download_file(link, out_name, **download_args)\n                done += 1\n            except KeyboardInterrupt:\n                print(\"Cancelled download\")\n                break\n            except Exception:\n                errors += 1\n                print(f\"Failed to download {i+1} of {T}: {file_name}\")\n\n        print(\n            f\"{done} Downloads completed, {errors} downloads failed, {T} files available\"\n        )\n        return\n\n    def find_tiles(self, region=None, return_type=\"list\", geopandas_args={}, API={}):\n        \"\"\"\n        Find a list of downloadable files.\n\n        Args:\n            region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n                Alternatively you could use API parameters such as polygon or bbox.\n            out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n            return_type (str): list | dict. Defaults to list. Changes the return output type and content.\n            geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n                Used for reading a region URL|filepath.\n            API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n                Exposes most of the documented API parameters. Defaults to {}.\n\n        Returns:\n            list: A list of download_urls.\n            dict: A dictionary with urls and related metadata\n        \"\"\"\n        assert region or API, \"Provide a region or use the API\"\n\n        if region:\n            API[\"bbox\"] = self.parse_region(region, geopandas_args)\n\n        results = self.find_details(**API)\n        if return_type == \"list\":\n            return [i[\"downloadURL\"] for i in results.get(\"items\")]\n        return results\n\n    def find_details(\n        self,\n        bbox: List[float] = None,\n        polygon: List[Tuple[float, float]] = None,\n        datasets: str = None,\n        prodFormats: str = None,\n        prodExtents: str = None,\n        q: str = None,\n        dateType: str = None,\n        start: str = None,\n        end: str = None,\n        offset: int = 0,\n        max: int = None,\n        outputFormat: str = \"JSON\",\n        polyType: str = None,\n        polyCode: str = None,\n        extentQuery: int = None,\n    ) -&gt; Dict:\n        \"\"\"\n        Possible search parameters (kwargs) support by API\n\n        Parameter               Values\n            Description\n        ---------------------------------------------------------------------------------------------------\n        bbox                    'minx, miny, maxx, maxy'\n            Geographic longitude/latitude values expressed in  decimal degrees in a comma-delimited list.\n        polygon                 '[x,y x,y x,y x,y x,y]'\n            Polygon, longitude/latitude values expressed in decimal degrees in a space-delimited list.\n        datasets                See: Datasets (Optional)\n            Dataset tag name (sbDatasetTag)\n            From https://apps.nationalmap.gov/tnmaccess/#/product\n        prodFormats             See: Product Formats (Optional)\n            Dataset-specific format\n\n        prodExtents             See: Product Extents (Optional)\n            Dataset-specific extent\n        q                       free text\n            Text input which can be used to filter by product titles and text descriptions.\n        dateType                dateCreated | lastUpdated | Publication\n            Type of date to search by.\n        start                   'YYYY-MM-DD'\n            Start date\n        end                     'YYYY-MM-DD'\n            End date (required if start date is provided)\n        offset                  integer\n            Offset into paginated results - default=0\n        max                     integer\n            Number of results returned\n        outputFormat            JSON | CSV | pjson\n            Default=JSON\n        polyType                state | huc2 | huc4 | huc8\n            Well Known Polygon Type. Use this parameter to deliver data by state or HUC\n            (hydrologic unit codes defined by the Watershed Boundary Dataset/WBD)\n        polyCode                state FIPS code or huc number\n            Well Known Polygon Code. This value needs to coordinate with the polyType parameter.\n        extentQuery             integer\n            A Polygon code in the science base system, typically from an uploaded shapefile\n        \"\"\"\n\n        try:\n            # call locals before creating new locals\n            used_locals = {k: v for k, v in locals().items() if v and k != \"self\"}\n\n            # Parsing\n            if polygon:\n                used_locals[\"polygon\"] = \",\".join(\n                    \" \".join(map(str, point)) for point in polygon\n                )\n            if bbox:\n                used_locals[\"bbox\"] = str(bbox)[1:-1]\n\n            if max:\n                max += 2\n\n            # Fetch response\n            response = requests.get(f\"{self.api_endpoint}products?\", params=used_locals)\n            if response.status_code // 100 == 2:\n                return response.json()\n            else:\n                # Parameter validation handled by API endpoint error responses\n                print(response.json())\n            return {}\n        except Exception as e:\n            print(e)\n            return {}\n</code></pre>"},{"location":"common/#geojp.common.The_national_map_USGS.datasets","title":"<code>datasets: list</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns a list of dataset tags (most common human readable self description for specific datasets).</p>"},{"location":"common/#geojp.common.The_national_map_USGS.datasets_full","title":"<code>datasets_full: list</code>  <code>property</code> <code>readonly</code>","text":"<p>Full description of datasets provided. Returns a JSON or empty list.</p>"},{"location":"common/#geojp.common.The_national_map_USGS.prodFormats","title":"<code>prodFormats: list</code>  <code>property</code> <code>readonly</code>","text":"<p>Return all datatypes available in any of the collections. Note that \"All\" is only peculiar to one dataset.</p>"},{"location":"common/#geojp.common.The_national_map_USGS.download_tiles","title":"<code>download_tiles(self, region=None, out_dir=None, download_args={}, geopandas_args={}, API={})</code>","text":"<p>Download the US National Elevation Datasets (NED) for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy]. Alternatively you could use API parameters such as polygon or bbox.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> <code>None</code> <code>download_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the download_file function. Defaults to {}.</p> <code>{}</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>API</code> <code>dict</code> <p>A dictionary of arguments to pass to the self.find_details() function. Exposes most of the documented API. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>geojp/common.py</code> <pre><code>def download_tiles(\n    self, region=None, out_dir=None, download_args={}, geopandas_args={}, API={}\n) -&gt; None:\n    \"\"\"\n\n    Download the US National Elevation Datasets (NED) for a region.\n\n    Args:\n        region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n            Alternatively you could use API parameters such as polygon or bbox.\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n            Exposes most of the documented API. Defaults to {}.\n\n    Returns:\n        None\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n    else:\n        out_dir = os.path.abspath(out_dir)\n\n    tiles = self.find_tiles(\n        region, return_type=\"list\", geopandas_args=geopandas_args, API=API\n    )\n    T = len(tiles)\n    errors = 0\n    done = 0\n\n    for i, link in enumerate(tiles):\n        file_name = os.path.basename(link)\n        out_name = os.path.join(out_dir, file_name)\n        if i &lt; 5 or (i &lt; 50 and not (i % 5)) or not (i % 20):\n            print(f\"Downloading {i+1} of {T}: {file_name}\")\n        try:\n            download_file(link, out_name, **download_args)\n            done += 1\n        except KeyboardInterrupt:\n            print(\"Cancelled download\")\n            break\n        except Exception:\n            errors += 1\n            print(f\"Failed to download {i+1} of {T}: {file_name}\")\n\n    print(\n        f\"{done} Downloads completed, {errors} downloads failed, {T} files available\"\n    )\n    return\n</code></pre>"},{"location":"common/#geojp.common.The_national_map_USGS.find_details","title":"<code>find_details(self, bbox=None, polygon=None, datasets=None, prodFormats=None, prodExtents=None, q=None, dateType=None, start=None, end=None, offset=0, max=None, outputFormat='JSON', polyType=None, polyCode=None, extentQuery=None)</code>","text":"<p>Possible search parameters (kwargs) support by API</p> <p>Parameter               Values     Description</p> <p>bbox                    'minx, miny, maxx, maxy'     Geographic longitude/latitude values expressed in  decimal degrees in a comma-delimited list. polygon                 '[x,y x,y x,y x,y x,y]'     Polygon, longitude/latitude values expressed in decimal degrees in a space-delimited list. datasets                See: Datasets (Optional)     Dataset tag name (sbDatasetTag)     From https://apps.nationalmap.gov/tnmaccess/#/product prodFormats             See: Product Formats (Optional)     Dataset-specific format</p> <p>prodExtents             See: Product Extents (Optional)     Dataset-specific extent q                       free text     Text input which can be used to filter by product titles and text descriptions. dateType                dateCreated | lastUpdated | Publication     Type of date to search by. start                   'YYYY-MM-DD'     Start date end                     'YYYY-MM-DD'     End date (required if start date is provided) offset                  integer     Offset into paginated results - default=0 max                     integer     Number of results returned outputFormat            JSON | CSV | pjson     Default=JSON polyType                state | huc2 | huc4 | huc8     Well Known Polygon Type. Use this parameter to deliver data by state or HUC     (hydrologic unit codes defined by the Watershed Boundary Dataset/WBD) polyCode                state FIPS code or huc number     Well Known Polygon Code. This value needs to coordinate with the polyType parameter. extentQuery             integer     A Polygon code in the science base system, typically from an uploaded shapefile</p> Source code in <code>geojp/common.py</code> <pre><code>def find_details(\n    self,\n    bbox: List[float] = None,\n    polygon: List[Tuple[float, float]] = None,\n    datasets: str = None,\n    prodFormats: str = None,\n    prodExtents: str = None,\n    q: str = None,\n    dateType: str = None,\n    start: str = None,\n    end: str = None,\n    offset: int = 0,\n    max: int = None,\n    outputFormat: str = \"JSON\",\n    polyType: str = None,\n    polyCode: str = None,\n    extentQuery: int = None,\n) -&gt; Dict:\n    \"\"\"\n    Possible search parameters (kwargs) support by API\n\n    Parameter               Values\n        Description\n    ---------------------------------------------------------------------------------------------------\n    bbox                    'minx, miny, maxx, maxy'\n        Geographic longitude/latitude values expressed in  decimal degrees in a comma-delimited list.\n    polygon                 '[x,y x,y x,y x,y x,y]'\n        Polygon, longitude/latitude values expressed in decimal degrees in a space-delimited list.\n    datasets                See: Datasets (Optional)\n        Dataset tag name (sbDatasetTag)\n        From https://apps.nationalmap.gov/tnmaccess/#/product\n    prodFormats             See: Product Formats (Optional)\n        Dataset-specific format\n\n    prodExtents             See: Product Extents (Optional)\n        Dataset-specific extent\n    q                       free text\n        Text input which can be used to filter by product titles and text descriptions.\n    dateType                dateCreated | lastUpdated | Publication\n        Type of date to search by.\n    start                   'YYYY-MM-DD'\n        Start date\n    end                     'YYYY-MM-DD'\n        End date (required if start date is provided)\n    offset                  integer\n        Offset into paginated results - default=0\n    max                     integer\n        Number of results returned\n    outputFormat            JSON | CSV | pjson\n        Default=JSON\n    polyType                state | huc2 | huc4 | huc8\n        Well Known Polygon Type. Use this parameter to deliver data by state or HUC\n        (hydrologic unit codes defined by the Watershed Boundary Dataset/WBD)\n    polyCode                state FIPS code or huc number\n        Well Known Polygon Code. This value needs to coordinate with the polyType parameter.\n    extentQuery             integer\n        A Polygon code in the science base system, typically from an uploaded shapefile\n    \"\"\"\n\n    try:\n        # call locals before creating new locals\n        used_locals = {k: v for k, v in locals().items() if v and k != \"self\"}\n\n        # Parsing\n        if polygon:\n            used_locals[\"polygon\"] = \",\".join(\n                \" \".join(map(str, point)) for point in polygon\n            )\n        if bbox:\n            used_locals[\"bbox\"] = str(bbox)[1:-1]\n\n        if max:\n            max += 2\n\n        # Fetch response\n        response = requests.get(f\"{self.api_endpoint}products?\", params=used_locals)\n        if response.status_code // 100 == 2:\n            return response.json()\n        else:\n            # Parameter validation handled by API endpoint error responses\n            print(response.json())\n        return {}\n    except Exception as e:\n        print(e)\n        return {}\n</code></pre>"},{"location":"common/#geojp.common.The_national_map_USGS.find_tiles","title":"<code>find_tiles(self, region=None, return_type='list', geopandas_args={}, API={})</code>","text":"<p>Find a list of downloadable files.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy]. Alternatively you could use API parameters such as polygon or bbox.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> required <code>return_type</code> <code>str</code> <p>list | dict. Defaults to list. Changes the return output type and content.</p> <code>'list'</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>API</code> <code>dict</code> <p>A dictionary of arguments to pass to the self.find_details() function. Exposes most of the documented API parameters. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of download_urls. dict: A dictionary with urls and related metadata</p> Source code in <code>geojp/common.py</code> <pre><code>def find_tiles(self, region=None, return_type=\"list\", geopandas_args={}, API={}):\n    \"\"\"\n    Find a list of downloadable files.\n\n    Args:\n        region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n            Alternatively you could use API parameters such as polygon or bbox.\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        return_type (str): list | dict. Defaults to list. Changes the return output type and content.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        API (dict, optional): A dictionary of arguments to pass to the self.find_details() function.\n            Exposes most of the documented API parameters. Defaults to {}.\n\n    Returns:\n        list: A list of download_urls.\n        dict: A dictionary with urls and related metadata\n    \"\"\"\n    assert region or API, \"Provide a region or use the API\"\n\n    if region:\n        API[\"bbox\"] = self.parse_region(region, geopandas_args)\n\n    results = self.find_details(**API)\n    if return_type == \"list\":\n        return [i[\"downloadURL\"] for i in results.get(\"items\")]\n    return results\n</code></pre>"},{"location":"common/#geojp.common.The_national_map_USGS.parse_region","title":"<code>parse_region(self, region, geopandas_args={})</code>","text":"<p>Translate a Vector dataset to its bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>an URL|filepath to a vector dataset to a polygon</p> required <code>geopandas_reader_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> required Source code in <code>geojp/common.py</code> <pre><code>def parse_region(self, region, geopandas_args={}) -&gt; list:\n    \"\"\"\n\n    Translate a Vector dataset to its bounding box.\n\n    Args:\n        region (str | list): an URL|filepath to a vector dataset to a polygon\n        geopandas_reader_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(region, str):\n        if region.startswith(\"http\"):\n            region = github_raw_url(region)\n            region = download_file(region)\n        elif not os.path.exists(region):\n            raise ValueError(\"region must be a path or a URL to a vector dataset.\")\n\n        roi = gpd.read_file(region, **geopandas_args)\n        roi = roi.to_crs(epsg=4326)\n        return roi.total_bounds\n    return region\n</code></pre>"},{"location":"common/#geojp.common.WhiteboxTools","title":"<code> WhiteboxTools            (WhiteboxTools)         </code>","text":"<p>This class inherits the whitebox WhiteboxTools class.</p> Source code in <code>geojp/common.py</code> <pre><code>class WhiteboxTools(whitebox.WhiteboxTools):\n    \"\"\"This class inherits the whitebox WhiteboxTools class.\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"common/#geojp.common.__install_from_github","title":"<code>__install_from_github(url)</code>","text":"<p>Install a package from a GitHub repository.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the GitHub repository.</p> required Source code in <code>geojp/common.py</code> <pre><code>def __install_from_github(url: str):\n    \"\"\"Install a package from a GitHub repository.\n\n    Args:\n        url (str): The URL of the GitHub repository.\n    \"\"\"\n\n    try:\n        download_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        if not os.path.exists(download_dir):\n            os.makedirs(download_dir)\n\n        repo_name = os.path.basename(url)\n        zip_url = os.path.join(url, \"archive/master.zip\")\n        filename = repo_name + \"-master.zip\"\n        download_from_url(\n            url=zip_url, out_file_name=filename, out_dir=download_dir, unzip=True\n        )\n\n        pkg_dir = os.path.join(download_dir, repo_name + \"-master\")\n        pkg_name = os.path.basename(url)\n        work_dir = os.getcwd()\n        os.chdir(pkg_dir)\n        print(\"Installing {}...\".format(pkg_name))\n        cmd = \"pip install .\"\n        os.system(cmd)\n        os.chdir(work_dir)\n        print(\"{} has been installed successfully.\".format(pkg_name))\n        # print(\"\\nPlease comment out 'install_from_github()' and restart the kernel to take effect:\\nJupyter menu -&gt; Kernel -&gt; Restart &amp; Clear Output\")\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.add_crs","title":"<code>add_crs(filename, epsg)</code>","text":"<p>Add a CRS to a raster dataset.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the raster dataset.</p> required <code>epsg</code> <code>int | str</code> <p>The EPSG code of the CRS.</p> required Source code in <code>geojp/common.py</code> <pre><code>def add_crs(filename, epsg):\n    \"\"\"Add a CRS to a raster dataset.\n\n    Args:\n        filename (str): The filename of the raster dataset.\n        epsg (int | str): The EPSG code of the CRS.\n\n    \"\"\"\n    try:\n        import rasterio\n    except ImportError:\n        raise ImportError(\n            \"rasterio is required for adding a CRS to a raster. Please install it using 'pip install rasterio'.\"\n        )\n\n    if not os.path.exists(filename):\n        raise ValueError(\"filename must exist.\")\n\n    if isinstance(epsg, int):\n        epsg = f\"EPSG:{epsg}\"\n    elif isinstance(epsg, str):\n        epsg = \"EPSG:\" + epsg\n    else:\n        raise ValueError(\"epsg must be an integer or string.\")\n\n    crs = rasterio.crs.CRS({\"init\": epsg})\n    with rasterio.open(filename, mode=\"r+\") as src:\n        src.crs = crs\n</code></pre>"},{"location":"common/#geojp.common.add_image_to_gif","title":"<code>add_image_to_gif(in_gif, out_gif, in_image, xy=None, image_size=(80, 80), circle_mask=False)</code>","text":"<p>Adds an image logo to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>Input file path to the GIF image.</p> required <code>out_gif</code> <code>str</code> <p>Output file path to the GIF image.</p> required <code>in_image</code> <code>str</code> <p>Input file path to the image.</p> required <code>xy</code> <code>tuple</code> <p>Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>None</code> <code>image_size</code> <code>tuple</code> <p>Resize image. Defaults to (80, 80).</p> <code>(80, 80)</code> <code>circle_mask</code> <code>bool</code> <p>Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False.</p> <code>False</code> Source code in <code>geojp/common.py</code> <pre><code>def add_image_to_gif(\n    in_gif, out_gif, in_image, xy=None, image_size=(80, 80), circle_mask=False\n):\n    \"\"\"Adds an image logo to a GIF image.\n\n    Args:\n        in_gif (str): Input file path to the GIF image.\n        out_gif (str): Output file path to the GIF image.\n        in_image (str): Input file path to the image.\n        xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        image_size (tuple, optional): Resize image. Defaults to (80, 80).\n        circle_mask (bool, optional): Whether to apply a circle mask to the image. This only works with non-png images. Defaults to False.\n    \"\"\"\n    import io\n\n    from PIL import Image, ImageDraw, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n\n    in_gif = os.path.abspath(in_gif)\n\n    is_url = False\n    if in_image.startswith(\"http\"):\n        is_url = True\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if (not is_url) and (not os.path.exists(in_image)):\n        print(\"The provided logo file does not exist.\")\n        return\n\n    out_dir = check_dir((os.path.dirname(out_gif)))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    try:\n        gif = Image.open(in_gif)\n    except Exception as e:\n        print(\"An error occurred while opening the image.\")\n        print(e)\n        return\n\n    logo_raw_image = None\n    try:\n        if in_image.startswith(\"http\"):\n            logo_raw_image = open_image_from_url(in_image)\n        else:\n            in_image = os.path.abspath(in_image)\n            logo_raw_image = Image.open(in_image)\n    except Exception as e:\n        print(e)\n\n    logo_raw_size = logo_raw_image.size\n\n    ratio = max(\n        logo_raw_size[0] / image_size[0],\n        logo_raw_size[1] / image_size[1],\n    )\n    image_resize = (int(logo_raw_size[0] / ratio), int(logo_raw_size[1] / ratio))\n    image_size = min(logo_raw_size[0], image_size[0]), min(\n        logo_raw_size[1], image_size[1]\n    )\n\n    logo_image = logo_raw_image.convert(\"RGBA\")\n    logo_image.thumbnail(image_size, Image.ANTIALIAS)\n\n    gif_width, gif_height = gif.size\n    mask_im = None\n\n    if circle_mask:\n        mask_im = Image.new(\"L\", image_size, 0)\n        draw = ImageDraw.Draw(mask_im)\n        draw.ellipse((0, 0, image_size[0], image_size[1]), fill=255)\n\n    if has_transparency(logo_raw_image):\n        mask_im = logo_image.copy()\n\n    if xy is None:\n        # default logo location is 5% width and 5% height of the image.\n        delta = 10\n        xy = (gif_width - image_resize[0] - delta, gif_height - image_resize[1] - delta)\n        # xy = (int(0.05 * gif_width), int(0.05 * gif_height))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        print(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n        return\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; gif_width) and (y &gt; 0) and (y &lt; gif_height):\n            pass\n        else:\n            print(\n                \"xy is out of bounds. x must be within [0, {}], and y must be within [0, {}]\".format(\n                    gif_width, gif_height\n                )\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = int(float(x.replace(\"%\", \"\")) / 100.0 * gif_width)\n                y = int(float(y.replace(\"%\", \"\")) / 100.0 * gif_height)\n                xy = (x, y)\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n\n    else:\n        raise Exception(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n\n    try:\n        frames = []\n        for _, frame in enumerate(ImageSequence.Iterator(gif)):\n            frame = frame.convert(\"RGBA\")\n            frame.paste(logo_image, xy, mask_im)\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n            frames.append(frame)\n\n        frames[0].save(out_gif, save_all=True, append_images=frames[1:])\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geojp.common.add_mask_to_image","title":"<code>add_mask_to_image(image, mask, output, color='red')</code>","text":"<p>Overlay a binary mask (e.g., roads, building footprints, etc) on an image. Credits to Xingjian Shi for the sample code.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>A local path or HTTP URL to an image.</p> required <code>mask</code> <code>str</code> <p>A local path or HTTP URL to a binary mask.</p> required <code>output</code> <code>str</code> <p>A local path to the output image.</p> required <code>color</code> <code>str</code> <p>Color of the mask. Defaults to 'red'.</p> <code>'red'</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If rasterio and detectron2 are not installed.</p> Source code in <code>geojp/common.py</code> <pre><code>def add_mask_to_image(image, mask, output, color=\"red\"):\n    \"\"\"Overlay a binary mask (e.g., roads, building footprints, etc) on an image. Credits to Xingjian Shi for the sample code.\n\n    Args:\n        image (str): A local path or HTTP URL to an image.\n        mask (str): A local path or HTTP URL to a binary mask.\n        output (str): A local path to the output image.\n        color (str, optional): Color of the mask. Defaults to 'red'.\n\n    Raises:\n        ImportError: If rasterio and detectron2 are not installed.\n    \"\"\"\n    try:\n        import rasterio\n        from detectron2.utils.visualizer import Visualizer\n        from PIL import Image\n    except ImportError:\n        raise ImportError(\n            \"Please install rasterio and detectron2 to use this function. See https://detectron2.readthedocs.io/en/latest/tutorials/install.html\"\n        )\n\n    ds = rasterio.open(image)\n    image_arr = ds.read()\n\n    mask_arr = rasterio.open(mask).read()\n\n    vis = Visualizer(image_arr.transpose((1, 2, 0)))\n    vis.draw_binary_mask(mask_arr[0] &gt; 0, color=color)\n\n    out_arr = Image.fromarray(vis.get_output().get_image())\n\n    out_arr.save(output)\n\n    if ds.crs is not None:\n        numpy_to_cog(output, output, profile=image)\n</code></pre>"},{"location":"common/#geojp.common.add_progress_bar_to_gif","title":"<code>add_progress_bar_to_gif(in_gif, out_gif, progress_bar_color='blue', progress_bar_height=5, duration=100, loop=0)</code>","text":"<p>Adds a progress bar to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the input GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The file path to the output GIF image.</p> required <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'blue'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>duration</code> <code>int</code> <p>controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation. Defaults to 100.</p> <code>100</code> <code>loop</code> <code>int</code> <p>controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> Source code in <code>geojp/common.py</code> <pre><code>def add_progress_bar_to_gif(\n    in_gif,\n    out_gif,\n    progress_bar_color=\"blue\",\n    progress_bar_height=5,\n    duration=100,\n    loop=0,\n):\n    \"\"\"Adds a progress bar to a GIF image.\n\n    Args:\n        in_gif (str): The file path to the input GIF image.\n        out_gif (str): The file path to the output GIF image.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation. Defaults to 100.\n        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    \"\"\"\n    import io\n\n    from PIL import Image, ImageDraw, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n\n    in_gif = os.path.abspath(in_gif)\n    out_gif = os.path.abspath(out_gif)\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    progress_bar_color = check_color(progress_bar_color)\n\n    try:\n        image = Image.open(in_gif)\n    except Exception as e:\n        raise Exception(\"An error occurred while opening the gif.\")\n\n    count = image.n_frames\n    W, H = image.size\n    progress_bar_widths = [i * 1.0 / count * W for i in range(1, count + 1)]\n    progress_bar_shapes = [\n        [(0, H - progress_bar_height), (x, H)] for x in progress_bar_widths\n    ]\n\n    try:\n        frames = []\n        # Loop over each frame in the animated image\n        for index, frame in enumerate(ImageSequence.Iterator(image)):\n            # Draw the text on the frame\n            frame = frame.convert(\"RGB\")\n            draw = ImageDraw.Draw(frame)\n            # w, h = draw.textsize(text[index])\n            draw.rectangle(progress_bar_shapes[index], fill=progress_bar_color)\n            del draw\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n\n            frames.append(frame)\n        # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/\n        # Save the frames as a new image\n\n        frames[0].save(\n            out_gif,\n            save_all=True,\n            append_images=frames[1:],\n            duration=duration,\n            loop=loop,\n            optimize=True,\n        )\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.add_text_to_gif","title":"<code>add_text_to_gif(in_gif, out_gif, xy=None, text_sequence=None, font_type='arial.ttf', font_size=20, font_color='#000000', add_progress_bar=True, progress_bar_color='white', progress_bar_height=5, duration=100, loop=0)</code>","text":"<p>Adds animated text to a GIF image.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the input GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The file path to the output GIF image.</p> required <code>xy</code> <code>tuple</code> <p>Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.</p> <code>None</code> <code>text_sequence</code> <code>int, str, list</code> <p>Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.</p> <code>None</code> <code>font_type</code> <code>str</code> <p>Font type. Defaults to \"arial.ttf\".</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>Font size. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.</p> <code>'#000000'</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar at the bottom of the GIF. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>Color for the progress bar. Defaults to 'white'.</p> <code>'white'</code> <code>progress_bar_height</code> <code>int</code> <p>Height of the progress bar. Defaults to 5.</p> <code>5</code> <code>duration</code> <code>int</code> <p>controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100.</p> <code>100</code> <code>loop</code> <code>int</code> <p>controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> Source code in <code>geojp/common.py</code> <pre><code>def add_text_to_gif(\n    in_gif,\n    out_gif,\n    xy=None,\n    text_sequence=None,\n    font_type=\"arial.ttf\",\n    font_size=20,\n    font_color=\"#000000\",\n    add_progress_bar=True,\n    progress_bar_color=\"white\",\n    progress_bar_height=5,\n    duration=100,\n    loop=0,\n):\n    \"\"\"Adds animated text to a GIF image.\n\n    Args:\n        in_gif (str): The file path to the input GIF image.\n        out_gif (str): The file path to the output GIF image.\n        xy (tuple, optional): Top left corner of the text. It can be formatted like this: (10, 10) or ('15%', '25%'). Defaults to None.\n        text_sequence (int, str, list, optional): Text to be drawn. It can be an integer number, a string, or a list of strings. Defaults to None.\n        font_type (str, optional): Font type. Defaults to \"arial.ttf\".\n        font_size (int, optional): Font size. Defaults to 20.\n        font_color (str, optional): Font color. It can be a string (e.g., 'red'), rgb tuple (e.g., (255, 127, 0)), or hex code (e.g., '#ff00ff').  Defaults to '#000000'.\n        add_progress_bar (bool, optional): Whether to add a progress bar at the bottom of the GIF. Defaults to True.\n        progress_bar_color (str, optional): Color for the progress bar. Defaults to 'white'.\n        progress_bar_height (int, optional): Height of the progress bar. Defaults to 5.\n        duration (int, optional): controls how long each frame will be displayed for, in milliseconds. It is the inverse of the frame rate. Setting it to 100 milliseconds gives 10 frames per second. You can decrease the duration to give a smoother animation.. Defaults to 100.\n        loop (int, optional): controls how many times the animation repeats. The default, 1, means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    \"\"\"\n    import io\n\n    import pkg_resources\n    from PIL import Image, ImageDraw, ImageFont, ImageSequence\n\n    warnings.simplefilter(\"ignore\")\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"leafmap\", \"leafmap.py\"))\n    default_font = os.path.join(pkg_dir, \"data/fonts/arial.ttf\")\n\n    in_gif = os.path.abspath(in_gif)\n    out_gif = os.path.abspath(out_gif)\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if font_type == \"arial.ttf\":\n        font = ImageFont.truetype(default_font, font_size)\n    elif font_type == \"alibaba.otf\":\n        default_font = os.path.join(pkg_dir, \"data/fonts/alibaba.otf\")\n        font = ImageFont.truetype(default_font, font_size)\n    else:\n        try:\n            font_list = system_fonts(show_full_path=True)\n            font_names = [os.path.basename(f) for f in font_list]\n            if (font_type in font_list) or (font_type in font_names):\n                font = ImageFont.truetype(font_type, font_size)\n            else:\n                print(\n                    \"The specified font type could not be found on your system. Using the default font instead.\"\n                )\n                font = ImageFont.truetype(default_font, font_size)\n        except Exception as e:\n            print(e)\n            font = ImageFont.truetype(default_font, font_size)\n\n    color = check_color(font_color)\n    progress_bar_color = check_color(progress_bar_color)\n\n    try:\n        image = Image.open(in_gif)\n    except Exception as e:\n        print(\"An error occurred while opening the gif.\")\n        print(e)\n        return\n\n    count = image.n_frames\n    W, H = image.size\n    progress_bar_widths = [i * 1.0 / count * W for i in range(1, count + 1)]\n    progress_bar_shapes = [\n        [(0, H - progress_bar_height), (x, H)] for x in progress_bar_widths\n    ]\n\n    if xy is None:\n        # default text location is 5% width and 5% height of the image.\n        xy = (int(0.05 * W), int(0.05 * H))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        print(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n        return\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; W) and (y &gt; 0) and (y &lt; H):\n            pass\n        else:\n            print(\n                f\"xy is out of bounds. x must be within [0, {W}], and y must be within [0, {H}]\"\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = int(float(x.replace(\"%\", \"\")) / 100.0 * W)\n                y = int(float(y.replace(\"%\", \"\")) / 100.0 * H)\n                xy = (x, y)\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n    else:\n        print(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n        return\n\n    if text_sequence is None:\n        text = [str(x) for x in range(1, count + 1)]\n    elif isinstance(text_sequence, int):\n        text = [str(x) for x in range(text_sequence, text_sequence + count + 1)]\n    elif isinstance(text_sequence, str):\n        try:\n            text_sequence = int(text_sequence)\n            text = [str(x) for x in range(text_sequence, text_sequence + count + 1)]\n        except Exception:\n            text = [text_sequence] * count\n    elif isinstance(text_sequence, list) and len(text_sequence) != count:\n        print(\n            f\"The length of the text sequence must be equal to the number ({count}) of frames in the gif.\"\n        )\n        return\n    else:\n        text = [str(x) for x in text_sequence]\n\n    try:\n        frames = []\n        # Loop over each frame in the animated image\n        for index, frame in enumerate(ImageSequence.Iterator(image)):\n            # Draw the text on the frame\n            frame = frame.convert(\"RGB\")\n            draw = ImageDraw.Draw(frame)\n            # w, h = draw.textsize(text[index])\n            draw.text(xy, text[index], font=font, fill=color)\n            if add_progress_bar:\n                draw.rectangle(progress_bar_shapes[index], fill=progress_bar_color)\n            del draw\n\n            b = io.BytesIO()\n            frame.save(b, format=\"GIF\")\n            frame = Image.open(b)\n\n            frames.append(frame)\n        # https://www.pythoninformer.com/python-libraries/pillow/creating-animated-gif/\n        # Save the frames as a new image\n\n        frames[0].save(\n            out_gif,\n            save_all=True,\n            append_images=frames[1:],\n            duration=duration,\n            loop=loop,\n            optimize=True,\n        )\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geojp.common.adjust_longitude","title":"<code>adjust_longitude(in_fc)</code>","text":"<p>Adjusts longitude if it is less than -180 or greater than 180.</p> <p>Parameters:</p> Name Type Description Default <code>in_fc</code> <code>dict</code> <p>The input dictionary containing coordinates.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the converted longitudes</p> Source code in <code>geojp/common.py</code> <pre><code>def adjust_longitude(in_fc):\n    \"\"\"Adjusts longitude if it is less than -180 or greater than 180.\n\n    Args:\n        in_fc (dict): The input dictionary containing coordinates.\n\n    Returns:\n        dict: A dictionary containing the converted longitudes\n    \"\"\"\n    try:\n        keys = in_fc.keys()\n\n        if \"geometry\" in keys:\n            coordinates = in_fc[\"geometry\"][\"coordinates\"]\n\n            if in_fc[\"geometry\"][\"type\"] == \"Point\":\n                longitude = coordinates[0]\n                if longitude &lt; -180:\n                    longitude = 360 + longitude\n                elif longitude &gt; 180:\n                    longitude = longitude - 360\n                in_fc[\"geometry\"][\"coordinates\"][0] = longitude\n\n            elif in_fc[\"geometry\"][\"type\"] == \"Polygon\":\n                for index1, item in enumerate(coordinates):\n                    for index2, element in enumerate(item):\n                        longitude = element[0]\n                        if longitude &lt; -180:\n                            longitude = 360 + longitude\n                        elif longitude &gt; 180:\n                            longitude = longitude - 360\n                        in_fc[\"geometry\"][\"coordinates\"][index1][index2][0] = longitude\n\n            elif in_fc[\"geometry\"][\"type\"] == \"LineString\":\n                for index, element in enumerate(coordinates):\n                    longitude = element[0]\n                    if longitude &lt; -180:\n                        longitude = 360 + longitude\n                    elif longitude &gt; 180:\n                        longitude = longitude - 360\n                    in_fc[\"geometry\"][\"coordinates\"][index][0] = longitude\n\n        elif \"type\" in keys:\n            coordinates = in_fc[\"coordinates\"]\n\n            if in_fc[\"type\"] == \"Point\":\n                longitude = coordinates[0]\n                if longitude &lt; -180:\n                    longitude = 360 + longitude\n                elif longitude &gt; 180:\n                    longitude = longitude - 360\n                in_fc[\"coordinates\"][0] = longitude\n\n            elif in_fc[\"type\"] == \"Polygon\":\n                for index1, item in enumerate(coordinates):\n                    for index2, element in enumerate(item):\n                        longitude = element[0]\n                        if longitude &lt; -180:\n                            longitude = 360 + longitude\n                        elif longitude &gt; 180:\n                            longitude = longitude - 360\n                        in_fc[\"coordinates\"][index1][index2][0] = longitude\n\n            elif in_fc[\"type\"] == \"LineString\":\n                for index, element in enumerate(coordinates):\n                    longitude = element[0]\n                    if longitude &lt; -180:\n                        longitude = 360 + longitude\n                    elif longitude &gt; 180:\n                        longitude = longitude - 360\n                    in_fc[\"coordinates\"][index][0] = longitude\n\n        return in_fc\n\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"common/#geojp.common.arc_active_map","title":"<code>arc_active_map()</code>","text":"<p>Get the active map in ArcGIS Pro.</p> <p>Returns:</p> Type Description <code>arcpy.Map</code> <p>The active map in ArcGIS Pro.</p> Source code in <code>geojp/common.py</code> <pre><code>def arc_active_map():\n    \"\"\"Get the active map in ArcGIS Pro.\n\n    Returns:\n        arcpy.Map: The active map in ArcGIS Pro.\n    \"\"\"\n    if is_arcpy():\n        import arcpy\n\n        aprx = arcpy.mp.ArcGISProject(\"CURRENT\")\n        m = aprx.activeMap\n        return m\n    else:\n        return None\n</code></pre>"},{"location":"common/#geojp.common.arc_active_view","title":"<code>arc_active_view()</code>","text":"<p>Get the active view in ArcGIS Pro.</p> <p>Returns:</p> Type Description <code>arcpy.MapView</code> <p>The active view in ArcGIS Pro.</p> Source code in <code>geojp/common.py</code> <pre><code>def arc_active_view():\n    \"\"\"Get the active view in ArcGIS Pro.\n\n    Returns:\n        arcpy.MapView: The active view in ArcGIS Pro.\n    \"\"\"\n    if is_arcpy():\n        import arcpy\n\n        aprx = arcpy.mp.ArcGISProject(\"CURRENT\")\n        view = aprx.activeView\n        return view\n    else:\n        return None\n</code></pre>"},{"location":"common/#geojp.common.arc_add_layer","title":"<code>arc_add_layer(url, name=None, shown=True, opacity=1.0)</code>","text":"<p>Add a layer to the active map in ArcGIS Pro.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the tile layer to add.</p> required <code>name</code> <code>str</code> <p>The name of the layer. Defaults to None.</p> <code>None</code> <code>shown</code> <code>bool</code> <p>Whether the layer is shown. Defaults to True.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>The opacity of the layer. Defaults to 1.0.</p> <code>1.0</code> Source code in <code>geojp/common.py</code> <pre><code>def arc_add_layer(url, name=None, shown=True, opacity=1.0):\n    \"\"\"Add a layer to the active map in ArcGIS Pro.\n\n    Args:\n        url (str): The URL of the tile layer to add.\n        name (str, optional): The name of the layer. Defaults to None.\n        shown (bool, optional): Whether the layer is shown. Defaults to True.\n        opacity (float, optional): The opacity of the layer. Defaults to 1.0.\n    \"\"\"\n    if is_arcpy():\n        m = arc_active_map()\n        if m is not None:\n            m.addDataFromPath(url)\n            if isinstance(name, str):\n                layers = m.listLayers(\"Tiled service layer\")\n                if len(layers) &gt; 0:\n                    layer = layers[0]\n                    layer.name = name\n                    layer.visible = shown\n                    layer.transparency = 100 - (opacity * 100)\n</code></pre>"},{"location":"common/#geojp.common.arc_zoom_to_bounds","title":"<code>arc_zoom_to_bounds(bounds)</code>","text":"<p>Zoom to a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list</code> <p>The bounding box to zoom to in the form [xmin, ymin, xmax, ymax] or [(ymin, xmin), (ymax, xmax)].</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>geojp/common.py</code> <pre><code>def arc_zoom_to_bounds(bounds):\n    \"\"\"Zoom to a bounding box.\n\n    Args:\n        bounds (list): The bounding box to zoom to in the form [xmin, ymin, xmax, ymax] or [(ymin, xmin), (ymax, xmax)].\n\n    Raises:\n        ValueError: _description_\n    \"\"\"\n\n    if len(bounds) == 4:\n        xmin, ymin, xmax, ymax = bounds\n    elif len(bounds) == 2:\n        (ymin, xmin), (ymax, xmax) = bounds\n    else:\n        raise ValueError(\"bounds must be a tuple of length 2 or 4.\")\n\n    arc_zoom_to_extent(xmin, ymin, xmax, ymax)\n</code></pre>"},{"location":"common/#geojp.common.arc_zoom_to_extent","title":"<code>arc_zoom_to_extent(xmin, ymin, xmax, ymax)</code>","text":"<p>Zoom to an extent in ArcGIS Pro.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>The minimum x value of the extent.</p> required <code>ymin</code> <code>float</code> <p>The minimum y value of the extent.</p> required <code>xmax</code> <code>float</code> <p>The maximum x value of the extent.</p> required <code>ymax</code> <code>float</code> <p>The maximum y value of the extent.</p> required Source code in <code>geojp/common.py</code> <pre><code>def arc_zoom_to_extent(xmin, ymin, xmax, ymax):\n    \"\"\"Zoom to an extent in ArcGIS Pro.\n\n    Args:\n        xmin (float): The minimum x value of the extent.\n        ymin (float): The minimum y value of the extent.\n        xmax (float): The maximum x value of the extent.\n        ymax (float): The maximum y value of the extent.\n    \"\"\"\n    if is_arcpy():\n        import arcpy\n\n        view = arc_active_view()\n        if view is not None:\n            view.camera.setExtent(\n                arcpy.Extent(\n                    xmin,\n                    ymin,\n                    xmax,\n                    ymax,\n                    spatial_reference=arcpy.SpatialReference(4326),\n                )\n            )\n\n        # if isinstance(zoom, int):\n        #     scale = 156543.04 * math.cos(0) / math.pow(2, zoom)\n        #     view.camera.scale = scale  # Not working properly\n</code></pre>"},{"location":"common/#geojp.common.array_to_image","title":"<code>array_to_image(array, output=None, source=None, dtype=None, compress='deflate', transpose=True, cellsize=None, crs=None, transform=None, driver='COG', **kwargs)</code>","text":"<p>Save a NumPy array as a GeoTIFF using the projection information from an existing GeoTIFF file.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.ndarray</code> <p>The NumPy array to be saved as a GeoTIFF.</p> required <code>output</code> <code>str</code> <p>The path to the output image. If None, a temporary file will be created. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>The path to an existing GeoTIFF file with map projection information. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>np.dtype</code> <p>The data type of the output array. Defaults to None.</p> <code>None</code> <code>compress</code> <code>str</code> <p>The compression method. Can be one of the following: \"deflate\", \"lzw\", \"packbits\", \"jpeg\". Defaults to \"deflate\".</p> <code>'deflate'</code> <code>transpose</code> <code>bool</code> <p>Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.</p> <code>True</code> <code>cellsize</code> <code>float</code> <p>The resolution of the output image in meters. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The CRS of the output image. Defaults to None.</p> <code>None</code> <code>transform</code> <code>tuple</code> <p>The affine transformation matrix, can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361). Defaults to None.</p> <code>None</code> <code>driver</code> <code>str</code> <p>The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".</p> <code>'COG'</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the rasterio.open() function.</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def array_to_image(\n    array,\n    output: str = None,\n    source: str = None,\n    dtype: str = None,\n    compress: str = \"deflate\",\n    transpose: bool = True,\n    cellsize: float = None,\n    crs: str = None,\n    transform: tuple = None,\n    driver: str = \"COG\",\n    **kwargs,\n) -&gt; str:\n    \"\"\"Save a NumPy array as a GeoTIFF using the projection information from an existing GeoTIFF file.\n\n    Args:\n        array (np.ndarray): The NumPy array to be saved as a GeoTIFF.\n        output (str): The path to the output image. If None, a temporary file will be created. Defaults to None.\n        source (str, optional): The path to an existing GeoTIFF file with map projection information. Defaults to None.\n        dtype (np.dtype, optional): The data type of the output array. Defaults to None.\n        compress (str, optional): The compression method. Can be one of the following: \"deflate\", \"lzw\", \"packbits\", \"jpeg\". Defaults to \"deflate\".\n        transpose (bool, optional): Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.\n        cellsize (float, optional): The resolution of the output image in meters. Defaults to None.\n        crs (str, optional): The CRS of the output image. Defaults to None.\n        transform (tuple, optional): The affine transformation matrix, can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361).\n            Defaults to None.\n        driver (str, optional): The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".\n        **kwargs: Additional keyword arguments to be passed to the rasterio.open() function.\n    \"\"\"\n\n    import numpy as np\n    import rasterio\n    import xarray as xr\n    from rasterio.transform import Affine\n\n    if output is None:\n        return array_to_memory_file(\n            array,\n            source,\n            dtype,\n            compress,\n            transpose,\n            cellsize,\n            crs=crs,\n            transform=transform,\n            driver=driver,\n            **kwargs,\n        )\n\n    if isinstance(array, xr.DataArray):\n        coords = [coord for coord in array.coords]\n        if coords[0] == \"time\":\n            x_dim = coords[1]\n            y_dim = coords[2]\n            array = (\n                array.isel(time=0).rename({y_dim: \"y\", x_dim: \"x\"}).transpose(\"y\", \"x\")\n            )\n        array = array.values\n\n    if array.ndim == 3 and transpose:\n        array = np.transpose(array, (1, 2, 0))\n\n    out_dir = os.path.dirname(os.path.abspath(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if not output.endswith(\".tif\"):\n        output += \".tif\"\n\n    if source is not None:\n        with rasterio.open(source) as src:\n            crs = src.crs\n            transform = src.transform\n            if compress is None:\n                compress = src.compression\n    else:\n        if cellsize is None:\n            raise ValueError(\"resolution must be provided if source is not provided\")\n        if crs is None:\n            raise ValueError(\n                \"crs must be provided if source is not provided, such as EPSG:3857\"\n            )\n\n        if transform is None:\n            # Define the geotransformation parameters\n            xmin, ymin, xmax, ymax = (\n                0,\n                0,\n                cellsize * array.shape[1],\n                cellsize * array.shape[0],\n            )\n            transform = rasterio.transform.from_bounds(\n                xmin, ymin, xmax, ymax, array.shape[1], array.shape[0]\n            )\n        elif isinstance(transform, Affine):\n            pass\n        elif isinstance(transform, (tuple, list)):\n            transform = Affine(*transform)\n\n        kwargs[\"transform\"] = transform\n\n    if dtype is None:\n        # Determine the minimum and maximum values in the array\n        min_value = np.min(array)\n        max_value = np.max(array)\n        # Determine the best dtype for the array\n        if min_value &gt;= 0 and max_value &lt;= 1:\n            dtype = np.float32\n        elif min_value &gt;= 0 and max_value &lt;= 255:\n            dtype = np.uint8\n        elif min_value &gt;= -128 and max_value &lt;= 127:\n            dtype = np.int8\n        elif min_value &gt;= 0 and max_value &lt;= 65535:\n            dtype = np.uint16\n        elif min_value &gt;= -32768 and max_value &lt;= 32767:\n            dtype = np.int16\n        else:\n            dtype = np.float64\n\n    # Convert the array to the best dtype\n    array = array.astype(dtype)\n\n    # Define the GeoTIFF metadata\n    metadata = {\n        \"driver\": driver,\n        \"height\": array.shape[0],\n        \"width\": array.shape[1],\n        \"dtype\": array.dtype,\n        \"crs\": crs,\n        \"transform\": transform,\n    }\n\n    if array.ndim == 2:\n        metadata[\"count\"] = 1\n    elif array.ndim == 3:\n        metadata[\"count\"] = array.shape[2]\n    if compress is not None:\n        metadata[\"compress\"] = compress\n\n    metadata.update(**kwargs)\n\n    # Create a new GeoTIFF file and write the array to it\n    with rasterio.open(output, \"w\", **metadata) as dst:\n        if array.ndim == 2:\n            dst.write(array, 1)\n        elif array.ndim == 3:\n            for i in range(array.shape[2]):\n                dst.write(array[:, :, i], i + 1)\n</code></pre>"},{"location":"common/#geojp.common.array_to_memory_file","title":"<code>array_to_memory_file(array, source=None, dtype=None, compress='deflate', transpose=True, cellsize=None, crs=None, transform=None, driver='COG', **kwargs)</code>","text":"<p>Convert a NumPy array to a memory file.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>numpy.ndarray</code> <p>The input NumPy array.</p> required <code>source</code> <code>str</code> <p>Path to the source file to extract metadata from. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>str</code> <p>The desired data type of the array. Defaults to None.</p> <code>None</code> <code>compress</code> <code>str</code> <p>The compression method for the output file. Defaults to \"deflate\".</p> <code>'deflate'</code> <code>transpose</code> <code>bool</code> <p>Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.</p> <code>True</code> <code>cellsize</code> <code>float</code> <p>The cell size of the array if source is not provided. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system of the array if source is not provided. Defaults to None.</p> <code>None</code> <code>transform</code> <code>tuple</code> <p>The affine transformation matrix if source is not provided. Can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361). Defaults to None</p> <code>None</code> <code>driver</code> <code>str</code> <p>The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".</p> <code>'COG'</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the rasterio.open() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>rasterio.DatasetReader</code> <p>The rasterio dataset reader object for the converted array.</p> Source code in <code>geojp/common.py</code> <pre><code>def array_to_memory_file(\n    array,\n    source: str = None,\n    dtype: str = None,\n    compress: str = \"deflate\",\n    transpose: bool = True,\n    cellsize: float = None,\n    crs: str = None,\n    transform: tuple = None,\n    driver=\"COG\",\n    **kwargs,\n):\n    \"\"\"Convert a NumPy array to a memory file.\n\n    Args:\n        array (numpy.ndarray): The input NumPy array.\n        source (str, optional): Path to the source file to extract metadata from. Defaults to None.\n        dtype (str, optional): The desired data type of the array. Defaults to None.\n        compress (str, optional): The compression method for the output file. Defaults to \"deflate\".\n        transpose (bool, optional): Whether to transpose the array from (bands, rows, columns) to (rows, columns, bands). Defaults to True.\n        cellsize (float, optional): The cell size of the array if source is not provided. Defaults to None.\n        crs (str, optional): The coordinate reference system of the array if source is not provided. Defaults to None.\n        transform (tuple, optional): The affine transformation matrix if source is not provided.\n            Can be rio.transform() or a tuple like (0.5, 0.0, -180.25, 0.0, -0.5, 83.780361). Defaults to None\n        driver (str, optional): The driver to use for creating the output file, such as 'GTiff'. Defaults to \"COG\".\n        **kwargs: Additional keyword arguments to be passed to the rasterio.open() function.\n\n    Returns:\n        rasterio.DatasetReader: The rasterio dataset reader object for the converted array.\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import xarray as xr\n    from rasterio.transform import Affine\n\n    if isinstance(array, xr.DataArray):\n        coords = [coord for coord in array.coords]\n        if coords[0] == \"time\":\n            x_dim = coords[1]\n            y_dim = coords[2]\n            array = (\n                array.isel(time=0).rename({y_dim: \"y\", x_dim: \"x\"}).transpose(\"y\", \"x\")\n            )\n        if hasattr(array, \"rio\"):\n            if hasattr(array.rio, \"crs\"):\n                crs = array.rio.crs\n            if hasattr(array.rio, \"transform\"):\n                transform = array.rio.transform()\n        elif source is None:\n            if hasattr(array, \"encoding\"):\n                if \"source\" in array.encoding:\n                    source = array.encoding[\"source\"]\n        array = array.values\n\n    if array.ndim == 3 and transpose:\n        array = np.transpose(array, (1, 2, 0))\n\n    if source is not None:\n        with rasterio.open(source) as src:\n            crs = src.crs\n            transform = src.transform\n            if compress is None:\n                compress = src.compression\n    else:\n        if crs is None:\n            raise ValueError(\n                \"crs must be provided if source is not provided, such as EPSG:3857\"\n            )\n\n        if transform is None:\n            if cellsize is None:\n                raise ValueError(\"cellsize must be provided if source is not provided\")\n            # Define the geotransformation parameters\n            xmin, ymin, xmax, ymax = (\n                0,\n                0,\n                cellsize * array.shape[1],\n                cellsize * array.shape[0],\n            )\n            # (west, south, east, north, width, height)\n            transform = rasterio.transform.from_bounds(\n                xmin, ymin, xmax, ymax, array.shape[1], array.shape[0]\n            )\n        elif isinstance(transform, Affine):\n            pass\n        elif isinstance(transform, (tuple, list)):\n            transform = Affine(*transform)\n\n        kwargs[\"transform\"] = transform\n\n    if dtype is None:\n        # Determine the minimum and maximum values in the array\n        min_value = np.min(array)\n        max_value = np.max(array)\n        # Determine the best dtype for the array\n        if min_value &gt;= 0 and max_value &lt;= 1:\n            dtype = np.float32\n        elif min_value &gt;= 0 and max_value &lt;= 255:\n            dtype = np.uint8\n        elif min_value &gt;= -128 and max_value &lt;= 127:\n            dtype = np.int8\n        elif min_value &gt;= 0 and max_value &lt;= 65535:\n            dtype = np.uint16\n        elif min_value &gt;= -32768 and max_value &lt;= 32767:\n            dtype = np.int16\n        else:\n            dtype = np.float64\n\n    # Convert the array to the best dtype\n    array = array.astype(dtype)\n\n    # Define the GeoTIFF metadata\n    metadata = {\n        \"driver\": driver,\n        \"height\": array.shape[0],\n        \"width\": array.shape[1],\n        \"dtype\": array.dtype,\n        \"crs\": crs,\n        \"transform\": transform,\n    }\n\n    if array.ndim == 2:\n        metadata[\"count\"] = 1\n    elif array.ndim == 3:\n        metadata[\"count\"] = array.shape[2]\n    if compress is not None:\n        metadata[\"compress\"] = compress\n\n    metadata.update(**kwargs)\n\n    # Create a new memory file and write the array to it\n    memory_file = rasterio.MemoryFile()\n    dst = memory_file.open(**metadata)\n\n    if array.ndim == 2:\n        dst.write(array, 1)\n    elif array.ndim == 3:\n        for i in range(array.shape[2]):\n            dst.write(array[:, :, i], i + 1)\n\n    dst.close()\n\n    # Read the dataset from memory\n    dataset_reader = rasterio.open(dst.name, mode=\"r\")\n\n    return dataset_reader\n</code></pre>"},{"location":"common/#geojp.common.assign_continuous_colors","title":"<code>assign_continuous_colors(df, column, cmap=None, colors=None, labels=None, scheme='Quantiles', k=5, legend_kwds=None, classification_kwds=None, to_rgb=True, return_type='array', return_legend=False)</code>","text":"<p>Assigns continuous colors to a DataFrame column based on a specified scheme.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>A pandas DataFrame.</p> required <code>column</code> <code>str</code> <p>The name of the column to assign colors.</p> required <code>cmap</code> <code>str</code> <p>The name of the colormap to use.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of custom colors.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of custom labels for the legend.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>The scheme for classifying the data. Default is 'Quantiles'.</p> <code>'Quantiles'</code> <code>k</code> <code>int</code> <p>The number of classes for classification.</p> <code>5</code> <code>legend_kwds</code> <code>dict</code> <p>Additional keyword arguments for configuring the legend.</p> <code>None</code> <code>classification_kwds</code> <code>dict</code> <p>Additional keyword arguments for configuring the classification.</p> <code>None</code> <code>to_rgb</code> <code>bool</code> <p>Whether to convert colors to RGB values. Default is True.</p> <code>True</code> <code>return_type</code> <code>str</code> <p>The type of the returned values. Default is 'array'.</p> <code>'array'</code> <code>return_legend</code> <code>bool</code> <p>Whether to return the legend. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <p>The assigned colors as a numpy array or a tuple containing the colors and the legend, depending on the value of return_legend.</p> Source code in <code>geojp/common.py</code> <pre><code>def assign_continuous_colors(\n    df,\n    column: str,\n    cmap: str = None,\n    colors: list = None,\n    labels: list = None,\n    scheme: str = \"Quantiles\",\n    k: int = 5,\n    legend_kwds: dict = None,\n    classification_kwds: dict = None,\n    to_rgb: bool = True,\n    return_type: str = \"array\",\n    return_legend: bool = False,\n):\n    \"\"\"Assigns continuous colors to a DataFrame column based on a specified scheme.\n\n    Args:\n        df: A pandas DataFrame.\n        column: The name of the column to assign colors.\n        cmap: The name of the colormap to use.\n        colors: A list of custom colors.\n        labels: A list of custom labels for the legend.\n        scheme: The scheme for classifying the data. Default is 'Quantiles'.\n        k: The number of classes for classification.\n        legend_kwds: Additional keyword arguments for configuring the legend.\n        classification_kwds: Additional keyword arguments for configuring the classification.\n        to_rgb: Whether to convert colors to RGB values. Default is True.\n        return_type: The type of the returned values. Default is 'array'.\n        return_legend: Whether to return the legend. Default is False.\n\n    Returns:\n        The assigned colors as a numpy array or a tuple containing the colors and the legend, depending on the value of return_legend.\n    \"\"\"\n    import numpy as np\n\n    data = df[[column]].copy()\n    new_df, legend = classify(\n        data, column, cmap, colors, labels, scheme, k, legend_kwds, classification_kwds\n    )\n    values = new_df[\"color\"].values.tolist()\n\n    if to_rgb:\n        values = [hex_to_rgb(check_color(color)) for color in values]\n        if return_type == \"array\":\n            values = np.array(values, dtype=np.uint8)\n\n    if return_legend:\n        return values, legend\n    else:\n        return values\n</code></pre>"},{"location":"common/#geojp.common.assign_discrete_colors","title":"<code>assign_discrete_colors(df, column, cmap, to_rgb=True, return_type='array')</code>","text":"<p>Assigns unique colors to each category in a categorical column of a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>The input dataframe.</p> required <code>column</code> <code>str</code> <p>The name of the categorical column.</p> required <code>cmap</code> <code>dict</code> <p>A dictionary mapping categories to colors.</p> required <code>to_rgb</code> <code>bool</code> <p>Whether to convert the colors to RGB values. Defaults to True.</p> <code>True</code> <code>return_type</code> <code>str</code> <p>The type of the returned values. Can be 'list' or 'array'. Defaults to 'array'.</p> <code>'array'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of colors for each category in the categorical column.</p> Source code in <code>geojp/common.py</code> <pre><code>def assign_discrete_colors(df, column, cmap, to_rgb=True, return_type=\"array\"):\n    \"\"\"\n    Assigns unique colors to each category in a categorical column of a dataframe.\n\n    Args:\n        df (pandas.DataFrame): The input dataframe.\n        column (str): The name of the categorical column.\n        cmap (dict): A dictionary mapping categories to colors.\n        to_rgb (bool): Whether to convert the colors to RGB values. Defaults to True.\n        return_type (str): The type of the returned values. Can be 'list' or 'array'. Defaults to 'array'.\n\n    Returns:\n        list: A list of colors for each category in the categorical column.\n    \"\"\"\n    import numpy as np\n\n    # Copy the categorical column from the original dataframe\n    category_column = df[column].copy()\n\n    # Map colors to the categorical values\n    category_column = category_column.map(cmap)\n\n    values = category_column.values.tolist()\n\n    if to_rgb:\n        values = [hex_to_rgb(check_color(color)) for color in values]\n        if return_type == \"array\":\n            values = np.array(values, dtype=np.uint8)\n\n    return values\n</code></pre>"},{"location":"common/#geojp.common.basemap_xyz_tiles","title":"<code>basemap_xyz_tiles()</code>","text":"<p>Returns a dictionary containing a set of basemaps that are XYZ tile layers.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of XYZ tile layers.</p> Source code in <code>geojp/common.py</code> <pre><code>def basemap_xyz_tiles():\n    \"\"\"Returns a dictionary containing a set of basemaps that are XYZ tile layers.\n\n    Returns:\n        dict: A dictionary of XYZ tile layers.\n    \"\"\"\n    from .leafmap import basemaps\n\n    layers_dict = {}\n    keys = dict(basemaps).keys()\n    for key in keys:\n        if isinstance(basemaps[key], ipyleaflet.WMSLayer):\n            pass\n        else:\n            layers_dict[key] = basemaps[key]\n    return layers_dict\n</code></pre>"},{"location":"common/#geojp.common.bbox_to_gdf","title":"<code>bbox_to_gdf(bbox, crs='epsg:4326')</code>","text":"<p>Convert a bounding box to a GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list</code> <p>A bounding box in the format of [minx, miny, maxx, maxy].</p> required <code>crs</code> <code>str</code> <p>The CRS of the bounding box. Defaults to 'epsg:4326'.</p> <code>'epsg:4326'</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame with a single polygon.</p> Source code in <code>geojp/common.py</code> <pre><code>def bbox_to_gdf(bbox, crs=\"epsg:4326\"):\n    \"\"\"Convert a bounding box to a GeoPandas GeoDataFrame.\n\n    Args:\n        bbox (list): A bounding box in the format of [minx, miny, maxx, maxy].\n        crs (str, optional): The CRS of the bounding box. Defaults to 'epsg:4326'.\n\n    Returns:\n        GeoDataFrame: A GeoDataFrame with a single polygon.\n    \"\"\"\n    import geopandas as gpd\n    from shapely.geometry import Polygon\n\n    return gpd.GeoDataFrame(\n        geometry=[Polygon.from_bounds(*bbox)],\n        crs=crs,\n    )\n</code></pre>"},{"location":"common/#geojp.common.bbox_to_geojson","title":"<code>bbox_to_geojson(bounds)</code>","text":"<p>Convert coordinates of a bounding box to a geojson.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list | tuple</code> <p>A list of coordinates representing [left, bottom, right, top] or m.bounds.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A geojson feature.</p> Source code in <code>geojp/common.py</code> <pre><code>def bbox_to_geojson(bounds):\n    \"\"\"Convert coordinates of a bounding box to a geojson.\n\n    Args:\n        bounds (list | tuple): A list of coordinates representing [left, bottom, right, top] or m.bounds.\n\n    Returns:\n        dict: A geojson feature.\n    \"\"\"\n\n    if isinstance(bounds, tuple) and len(bounds) == 2:\n        bounds = [bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]]\n\n    return {\n        \"geometry\": {\n            \"type\": \"Polygon\",\n            \"coordinates\": [\n                [\n                    [bounds[0], bounds[3]],\n                    [bounds[0], bounds[1]],\n                    [bounds[2], bounds[1]],\n                    [bounds[2], bounds[3]],\n                    [bounds[0], bounds[3]],\n                ]\n            ],\n        },\n        \"type\": \"Feature\",\n    }\n</code></pre>"},{"location":"common/#geojp.common.bbox_to_polygon","title":"<code>bbox_to_polygon(bbox)</code>","text":"<p>Convert a bounding box to a shapely Polygon.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list</code> <p>A bounding box in the format of [minx, miny, maxx, maxy].</p> required <p>Returns:</p> Type Description <code>Polygon</code> <p>A shapely Polygon.</p> Source code in <code>geojp/common.py</code> <pre><code>def bbox_to_polygon(bbox):\n    \"\"\"Convert a bounding box to a shapely Polygon.\n\n    Args:\n        bbox (list): A bounding box in the format of [minx, miny, maxx, maxy].\n\n    Returns:\n        Polygon: A shapely Polygon.\n    \"\"\"\n    from shapely.geometry import Polygon\n\n    return Polygon.from_bounds(*bbox)\n</code></pre>"},{"location":"common/#geojp.common.blend_images","title":"<code>blend_images(img1, img2, alpha=0.5, output=False, show=True, figsize=(12, 10), axis='off', **kwargs)</code>","text":"<p>Blends two images together using the addWeighted function from the OpenCV library.</p> <p>Parameters:</p> Name Type Description Default <code>img1</code> <code>numpy.ndarray</code> <p>The first input image on top represented as a NumPy array.</p> required <code>img2</code> <code>numpy.ndarray</code> <p>The second input image at the bottom represented as a NumPy array.</p> required <code>alpha</code> <code>float</code> <p>The weighting factor for the first image in the blend. By default, this is set to 0.5.</p> <code>0.5</code> <code>output</code> <code>str</code> <p>The path to the output image. Defaults to False.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display the blended image. Defaults to True.</p> <code>True</code> <code>figsize</code> <code>tuple</code> <p>The size of the figure. Defaults to (12, 10).</p> <code>(12, 10)</code> <code>axis</code> <code>str</code> <p>The axis of the figure. Defaults to \"off\".</p> <code>'off'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the cv2.addWeighted() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>The blended image as a NumPy array.</p> Source code in <code>geojp/common.py</code> <pre><code>def blend_images(\n    img1,\n    img2,\n    alpha=0.5,\n    output=False,\n    show=True,\n    figsize=(12, 10),\n    axis=\"off\",\n    **kwargs,\n):\n    \"\"\"\n    Blends two images together using the addWeighted function from the OpenCV library.\n\n    Args:\n        img1 (numpy.ndarray): The first input image on top represented as a NumPy array.\n        img2 (numpy.ndarray): The second input image at the bottom represented as a NumPy array.\n        alpha (float): The weighting factor for the first image in the blend. By default, this is set to 0.5.\n        output (str, optional): The path to the output image. Defaults to False.\n        show (bool, optional): Whether to display the blended image. Defaults to True.\n        figsize (tuple, optional): The size of the figure. Defaults to (12, 10).\n        axis (str, optional): The axis of the figure. Defaults to \"off\".\n        **kwargs: Additional keyword arguments to pass to the cv2.addWeighted() function.\n\n    Returns:\n        numpy.ndarray: The blended image as a NumPy array.\n    \"\"\"\n    import cv2\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # Resize the images to have the same dimensions\n    if isinstance(img1, str):\n        if img1.startswith(\"http\"):\n            img1 = download_file(img1)\n\n        if not os.path.exists(img1):\n            raise ValueError(f\"Input path {img1} does not exist.\")\n\n        img1 = cv2.imread(img1)\n\n    if isinstance(img2, str):\n        if img2.startswith(\"http\"):\n            img2 = download_file(img2)\n\n        if not os.path.exists(img2):\n            raise ValueError(f\"Input path {img2} does not exist.\")\n\n        img2 = cv2.imread(img2)\n\n    if img1.dtype == np.float32:\n        img1 = (img1 * 255).astype(np.uint8)\n\n    if img2.dtype == np.float32:\n        img2 = (img2 * 255).astype(np.uint8)\n\n    if img1.dtype != img2.dtype:\n        img2 = img2.astype(img1.dtype)\n\n    img1 = cv2.resize(img1, (img2.shape[1], img2.shape[0]))\n\n    # Blend the images using the addWeighted function\n    beta = 1 - alpha\n    blend_img = cv2.addWeighted(img1, alpha, img2, beta, 0, **kwargs)\n\n    if output:\n        array_to_image(blend_img, output, img2)\n\n    if show:\n        plt.figure(figsize=figsize)\n        plt.imshow(blend_img)\n        plt.axis(axis)\n        plt.show()\n    else:\n        return blend_img\n</code></pre>"},{"location":"common/#geojp.common.bounds_to_xy_range","title":"<code>bounds_to_xy_range(bounds)</code>","text":"<p>Convert bounds to x and y range to be used as input to bokeh map.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list</code> <p>A list of bounds in the form [(south, west), (north, east)] or [xmin, ymin, xmax, ymax].</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (x_range, y_range).</p> Source code in <code>geojp/common.py</code> <pre><code>def bounds_to_xy_range(bounds):\n    \"\"\"Convert bounds to x and y range to be used as input to bokeh map.\n\n    Args:\n        bounds (list): A list of bounds in the form [(south, west), (north, east)] or [xmin, ymin, xmax, ymax].\n\n    Returns:\n        tuple: A tuple of (x_range, y_range).\n    \"\"\"\n\n    if isinstance(bounds, tuple):\n        bounds = list(bounds)\n    elif not isinstance(bounds, list):\n        raise TypeError(\"bounds must be a list\")\n\n    if len(bounds) == 4:\n        west, south, east, north = bounds\n    elif len(bounds) == 2:\n        south, west = bounds[0]\n        north, east = bounds[1]\n\n    xmin, ymin = lnglat_to_meters(west, south)\n    xmax, ymax = lnglat_to_meters(east, north)\n    x_range = (xmin, xmax)\n    y_range = (ymin, ymax)\n    return x_range, y_range\n</code></pre>"},{"location":"common/#geojp.common.center_zoom_to_xy_range","title":"<code>center_zoom_to_xy_range(center, zoom)</code>","text":"<p>Convert center and zoom to x and y range to be used as input to bokeh map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>A tuple of (latitude, longitude).</p> required <code>zoom</code> <code>int</code> <p>The zoom level.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (x_range, y_range).</p> Source code in <code>geojp/common.py</code> <pre><code>def center_zoom_to_xy_range(center, zoom):\n    \"\"\"Convert center and zoom to x and y range to be used as input to bokeh map.\n\n    Args:\n        center (tuple): A tuple of (latitude, longitude).\n        zoom (int): The zoom level.\n\n    Returns:\n        tuple: A tuple of (x_range, y_range).\n    \"\"\"\n\n    if isinstance(center, tuple) or isinstance(center, list):\n        pass\n    else:\n        raise TypeError(\"center must be a tuple or list\")\n\n    if not isinstance(zoom, int):\n        raise TypeError(\"zoom must be an integer\")\n\n    latitude, longitude = center\n    x_range = (-179, 179)\n    y_range = (-70, 70)\n    x_full_length = x_range[1] - x_range[0]\n    y_full_length = y_range[1] - y_range[0]\n\n    x_length = x_full_length / 2 ** (zoom - 2)\n    y_length = y_full_length / 2 ** (zoom - 2)\n\n    south = latitude - y_length / 2\n    north = latitude + y_length / 2\n    west = longitude - x_length / 2\n    east = longitude + x_length / 2\n\n    xmin, ymin = lnglat_to_meters(west, south)\n    xmax, ymax = lnglat_to_meters(east, north)\n\n    x_range = (xmin, xmax)\n    y_range = (ymin, ymax)\n\n    return x_range, y_range\n</code></pre>"},{"location":"common/#geojp.common.cesium_to_streamlit","title":"<code>cesium_to_streamlit(html, width=800, height=600, responsive=True, scrolling=False, token_name=None, token_value=None, **kwargs)</code>","text":"<p>Renders an cesium HTML file in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML file to render. It can a local file path or a URL.</p> required <code>width</code> <code>int</code> <p>Width of the map. Defaults to 800.</p> <code>800</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>600</code> <code>responsive</code> <code>bool</code> <p>Whether to make the map responsive. Defaults to True.</p> <code>True</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow the map to scroll. Defaults to False.</p> <code>False</code> <code>token_name</code> <code>str</code> <p>The name of the token in the HTML file to be replaced. Defaults to None.</p> <code>None</code> <code>token_value</code> <code>str</code> <p>The value of the token to pass to the HTML file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>geojp/common.py</code> <pre><code>def cesium_to_streamlit(\n    html,\n    width=800,\n    height=600,\n    responsive=True,\n    scrolling=False,\n    token_name=None,\n    token_value=None,\n    **kwargs,\n):\n    \"\"\"Renders an cesium HTML file in a Streamlit app. This method is a static Streamlit Component, meaning, no information is passed back from Leaflet on browser interaction.\n\n    Args:\n        html (str): The HTML file to render. It can a local file path or a URL.\n        width (int, optional): Width of the map. Defaults to 800.\n        height (int, optional): Height of the map. Defaults to 600.\n        responsive (bool, optional): Whether to make the map responsive. Defaults to True.\n        scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n        token_name (str, optional): The name of the token in the HTML file to be replaced. Defaults to None.\n        token_value (str, optional): The value of the token to pass to the HTML file. Defaults to None.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n    if token_name is None:\n        token_name = \"your_access_token\"\n\n    if token_value is None:\n        token_value = os.environ.get(\"CESIUM_TOKEN\")\n\n    html_to_streamlit(\n        html, width, height, responsive, scrolling, token_name, token_value\n    )\n</code></pre>"},{"location":"common/#geojp.common.check_cmap","title":"<code>check_cmap(cmap)</code>","text":"<p>Check the colormap and return a list of colors.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str | list | Box</code> <p>The colormap to check.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of colors.</p> Source code in <code>geojp/common.py</code> <pre><code>def check_cmap(cmap):\n    \"\"\"Check the colormap and return a list of colors.\n\n    Args:\n        cmap (str | list | Box): The colormap to check.\n\n    Returns:\n        list: A list of colors.\n    \"\"\"\n\n    from box import Box\n    from .colormaps import get_palette\n\n    if isinstance(cmap, str):\n        try:\n            return get_palette(cmap)\n        except Exception as e:\n            raise Exception(f\"{cmap} is not a valid colormap.\")\n    elif isinstance(cmap, Box):\n        return list(cmap[\"default\"])\n    elif isinstance(cmap, list) or isinstance(cmap, tuple):\n        return cmap\n    else:\n        raise Exception(f\"{cmap} is not a valid colormap.\")\n</code></pre>"},{"location":"common/#geojp.common.check_color","title":"<code>check_color(in_color)</code>","text":"<p>Checks the input color and returns the corresponding hex color code.</p> <p>Parameters:</p> Name Type Description Default <code>in_color</code> <code>str or tuple or list</code> <p>It can be a string (e.g., 'red', '#ffff00', 'ffff00', 'ff0') or RGB tuple (e.g., (255, 127, 0)).</p> required <p>Returns:</p> Type Description <code>str</code> <p>A hex color code.</p> Source code in <code>geojp/common.py</code> <pre><code>def check_color(in_color: Union[str, Tuple]) -&gt; str:\n    \"\"\"Checks the input color and returns the corresponding hex color code.\n\n    Args:\n            in_color (str or tuple or list): It can be a string (e.g., 'red', '#ffff00', 'ffff00', 'ff0') or RGB tuple (e.g., (255, 127, 0)).\n\n    Returns:\n        str: A hex color code.\n    \"\"\"\n    import colour\n\n    out_color = \"#000000\"  # default black color\n    if (isinstance(in_color, tuple) or isinstance(in_color, list)) and len(\n        in_color\n    ) == 3:\n        # rescale color if necessary\n        if all(isinstance(item, int) for item in in_color):\n            in_color = [c / 255.0 for c in in_color]\n\n        return colour.Color(rgb=tuple(in_color)).hex_l\n\n    else:\n        # try to guess the color system\n        try:\n            return colour.Color(in_color).hex_l\n\n        except Exception as e:\n            pass\n\n        # try again by adding an extra # (GEE handle hex codes without #)\n        try:\n            return colour.Color(f\"#{in_color}\").hex_l\n\n        except Exception as e:\n            print(\n                f\"The provided color ({in_color}) is invalid. Using the default black color.\"\n            )\n            print(e)\n\n        return out_color\n</code></pre>"},{"location":"common/#geojp.common.check_dir","title":"<code>check_dir(dir_path, make_dirs=True)</code>","text":"<p>Checks if a directory exists and creates it if it does not.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>[str</code> <p>The path to the directory.</p> required <code>make_dirs</code> <code>bool</code> <p>Whether to create the directory if it does not exist. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the directory could not be found.</p> <code>TypeError</code> <p>If the input directory path is not a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The path to the directory.</p> Source code in <code>geojp/common.py</code> <pre><code>def check_dir(dir_path, make_dirs=True):\n    \"\"\"Checks if a directory exists and creates it if it does not.\n\n    Args:\n        dir_path ([str): The path to the directory.\n        make_dirs (bool, optional): Whether to create the directory if it does not exist. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the directory could not be found.\n        TypeError: If the input directory path is not a string.\n\n    Returns:\n        str: The path to the directory.\n    \"\"\"\n\n    if isinstance(dir_path, str):\n        if dir_path.startswith(\"~\"):\n            dir_path = os.path.expanduser(dir_path)\n        else:\n            dir_path = os.path.abspath(dir_path)\n\n        if not os.path.exists(dir_path) and make_dirs:\n            os.makedirs(dir_path)\n\n        if os.path.exists(dir_path):\n            return dir_path\n        else:\n            raise FileNotFoundError(\"The provided directory could not be found.\")\n    else:\n        raise TypeError(\"The provided directory path must be a string.\")\n</code></pre>"},{"location":"common/#geojp.common.check_file_path","title":"<code>check_file_path(file_path, make_dirs=True)</code>","text":"<p>Gets the absolute file path.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file.</p> required <code>make_dirs</code> <code>bool</code> <p>Whether to create the directory if it does not exist. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the directory could not be found.</p> <code>TypeError</code> <p>If the input directory path is not a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The absolute path to the file.</p> Source code in <code>geojp/common.py</code> <pre><code>def check_file_path(file_path, make_dirs=True):\n    \"\"\"Gets the absolute file path.\n\n    Args:\n        file_path (str): The path to the file.\n        make_dirs (bool, optional): Whether to create the directory if it does not exist. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the directory could not be found.\n        TypeError: If the input directory path is not a string.\n\n    Returns:\n        str: The absolute path to the file.\n    \"\"\"\n    if isinstance(file_path, str):\n        if file_path.startswith(\"~\"):\n            file_path = os.path.expanduser(file_path)\n        else:\n            file_path = os.path.abspath(file_path)\n\n        file_dir = os.path.dirname(file_path)\n        if not os.path.exists(file_dir) and make_dirs:\n            os.makedirs(file_dir)\n\n        return file_path\n\n    else:\n        raise TypeError(\"The provided file path must be a string.\")\n</code></pre>"},{"location":"common/#geojp.common.check_html_string","title":"<code>check_html_string(html_string)</code>","text":"<p>Check if an HTML string contains local images and convert them to base64.</p> <p>Parameters:</p> Name Type Description Default <code>html_string</code> <code>str</code> <p>The HTML string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML string with local images converted to base64.</p> Source code in <code>geojp/common.py</code> <pre><code>def check_html_string(html_string):\n    \"\"\"Check if an HTML string contains local images and convert them to base64.\n\n    Args:\n        html_string (str): The HTML string.\n\n    Returns:\n        str: The HTML string with local images converted to base64.\n    \"\"\"\n    import re\n    import base64\n\n    # Search for img tags with src attribute\n    img_regex = r'&lt;img[^&gt;]+src\\s*=\\s*[\"\\']([^\"\\':]+)[\"\\'][^&gt;]*&gt;'\n\n    for match in re.findall(img_regex, html_string):\n        with open(match, \"rb\") as img_file:\n            img_data = img_file.read()\n            base64_data = base64.b64encode(img_data).decode(\"utf-8\")\n            html_string = html_string.replace(\n                'src=\"{}\"'.format(match),\n                'src=\"data:image/png;base64,' + base64_data + '\"',\n            )\n\n    return html_string\n</code></pre>"},{"location":"common/#geojp.common.check_url","title":"<code>check_url(url)</code>","text":"<p>Check if an HTTP URL is working.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the URL is working (returns a 200 status code), False otherwise.</p> Source code in <code>geojp/common.py</code> <pre><code>def check_url(url: str) -&gt; bool:\n    \"\"\"Check if an HTTP URL is working.\n\n    Args:\n        url (str): The URL to check.\n\n    Returns:\n        bool: True if the URL is working (returns a 200 status code), False otherwise.\n    \"\"\"\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            return True\n        else:\n            return False\n    except requests.exceptions.RequestException:\n        return False\n</code></pre>"},{"location":"common/#geojp.common.classify","title":"<code>classify(data, column, cmap=None, colors=None, labels=None, scheme='Quantiles', k=5, legend_kwds=None, classification_kwds=None)</code>","text":"<p>Classify a dataframe column using a variety of classification schemes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame | gpd.GeoDataFrame</code> <p>The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.</p> required <code>column</code> <code>str</code> <p>The column to classify.</p> required <code>cmap</code> <code>str</code> <p>The name of a colormap recognized by matplotlib. Defaults to None.</p> <code>None</code> <code>colors</code> <code>list</code> <p>A list of colors to use for the classification. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of labels to use for the legend. Defaults to None.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>Name of a choropleth classification scheme (requires mapclassify). Name of a choropleth classification scheme (requires mapclassify). A mapclassify.MapClassifier object will be used under the hood. Supported are all schemes provided by mapclassify (e.g. 'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled', 'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced', 'JenksCaspallSampled', 'MaxP', 'MaximumBreaks', 'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean', 'UserDefined'). Arguments can be passed in classification_kwds.</p> <code>'Quantiles'</code> <code>k</code> <code>int</code> <p>Number of classes (ignored if scheme is None or if column is categorical). Default to 5.</p> <code>5</code> <code>legend_kwds</code> <code>dict</code> <p>Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or <code>matplotlib.pyplot.colorbar</code>. Defaults to None. Keyword arguments to pass to :func:<code>matplotlib.pyplot.legend</code> or Additional accepted keywords when <code>scheme</code> is specified: fmt : string     A formatting specification for the bin edges of the classes in the     legend. For example, to have no decimals: <code>{\"fmt\": \"{:.0f}\"}</code>. labels : list-like     A list of legend labels to override the auto-generated labblels.     Needs to have the same number of elements as the number of     classes (<code>k</code>). interval : boolean (default False)     An option to control brackets from mapclassify legend.     If True, open/closed interval brackets are shown in the legend.</p> <code>None</code> <code>classification_kwds</code> <code>dict</code> <p>Keyword arguments to pass to mapclassify. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame, dict</code> <p>A pandas dataframe with the classification applied and a legend dictionary.</p> Source code in <code>geojp/common.py</code> <pre><code>def classify(\n    data,\n    column,\n    cmap=None,\n    colors=None,\n    labels=None,\n    scheme=\"Quantiles\",\n    k=5,\n    legend_kwds=None,\n    classification_kwds=None,\n):\n    \"\"\"Classify a dataframe column using a variety of classification schemes.\n\n    Args:\n        data (str | pd.DataFrame | gpd.GeoDataFrame): The data to classify. It can be a filepath to a vector dataset, a pandas dataframe, or a geopandas geodataframe.\n        column (str): The column to classify.\n        cmap (str, optional): The name of a colormap recognized by matplotlib. Defaults to None.\n        colors (list, optional): A list of colors to use for the classification. Defaults to None.\n        labels (list, optional): A list of labels to use for the legend. Defaults to None.\n        scheme (str, optional): Name of a choropleth classification scheme (requires mapclassify).\n            Name of a choropleth classification scheme (requires mapclassify).\n            A mapclassify.MapClassifier object will be used\n            under the hood. Supported are all schemes provided by mapclassify (e.g.\n            'BoxPlot', 'EqualInterval', 'FisherJenks', 'FisherJenksSampled',\n            'HeadTailBreaks', 'JenksCaspall', 'JenksCaspallForced',\n            'JenksCaspallSampled', 'MaxP', 'MaximumBreaks',\n            'NaturalBreaks', 'Quantiles', 'Percentiles', 'StdMean',\n            'UserDefined'). Arguments can be passed in classification_kwds.\n        k (int, optional): Number of classes (ignored if scheme is None or if column is categorical). Default to 5.\n        legend_kwds (dict, optional): Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or `matplotlib.pyplot.colorbar`. Defaults to None.\n            Keyword arguments to pass to :func:`matplotlib.pyplot.legend` or\n            Additional accepted keywords when `scheme` is specified:\n            fmt : string\n                A formatting specification for the bin edges of the classes in the\n                legend. For example, to have no decimals: ``{\"fmt\": \"{:.0f}\"}``.\n            labels : list-like\n                A list of legend labels to override the auto-generated labblels.\n                Needs to have the same number of elements as the number of\n                classes (`k`).\n            interval : boolean (default False)\n                An option to control brackets from mapclassify legend.\n                If True, open/closed interval brackets are shown in the legend.\n        classification_kwds (dict, optional): Keyword arguments to pass to mapclassify. Defaults to None.\n\n    Returns:\n        pd.DataFrame, dict: A pandas dataframe with the classification applied and a legend dictionary.\n    \"\"\"\n\n    import numpy as np\n    import pandas as pd\n    import geopandas as gpd\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n\n    try:\n        import mapclassify\n    except ImportError:\n        raise ImportError(\n            \"mapclassify is required for this function. Install with `pip install mapclassify`.\"\n        )\n\n    if (\n        isinstance(data, gpd.GeoDataFrame)\n        or isinstance(data, pd.DataFrame)\n        or isinstance(data, pd.Series)\n    ):\n        df = data\n    else:\n        try:\n            df = gpd.read_file(data)\n        except Exception:\n            raise TypeError(\n                \"Data must be a GeoDataFrame or a path to a file that can be read by geopandas.read_file().\"\n            )\n\n    if df.empty:\n        warnings.warn(\n            \"The GeoDataFrame you are attempting to plot is \"\n            \"empty. Nothing has been displayed.\",\n            UserWarning,\n        )\n        return\n\n    columns = df.columns.values.tolist()\n    if column not in columns:\n        raise ValueError(\n            f\"{column} is not a column in the GeoDataFrame. It must be one of {columns}.\"\n        )\n\n    # Convert categorical data to numeric\n    init_column = None\n    value_list = None\n    if np.issubdtype(df[column].dtype, np.object0):\n        value_list = df[column].unique().tolist()\n        value_list.sort()\n        df[\"category\"] = df[column].replace(value_list, range(0, len(value_list)))\n        init_column = column\n        column = \"category\"\n        k = len(value_list)\n\n    if legend_kwds is not None:\n        legend_kwds = legend_kwds.copy()\n\n    # To accept pd.Series and np.arrays as column\n    if isinstance(column, (np.ndarray, pd.Series)):\n        if column.shape[0] != df.shape[0]:\n            raise ValueError(\n                \"The dataframe and given column have different number of rows.\"\n            )\n        else:\n            values = column\n\n            # Make sure index of a Series matches index of df\n            if isinstance(values, pd.Series):\n                values = values.reindex(df.index)\n    else:\n        values = df[column]\n\n    values = df[column]\n    nan_idx = np.asarray(pd.isna(values), dtype=\"bool\")\n\n    if cmap is None:\n        cmap = \"Blues\"\n    cmap = plt.cm.get_cmap(cmap, k)\n    if colors is None:\n        colors = [mpl.colors.rgb2hex(cmap(i))[1:] for i in range(cmap.N)]\n        colors = [\"#\" + i for i in colors]\n    elif isinstance(colors, list):\n        colors = [check_color(i) for i in colors]\n    elif isinstance(colors, str):\n        colors = [check_color(colors)] * k\n\n    allowed_schemes = [\n        \"BoxPlot\",\n        \"EqualInterval\",\n        \"FisherJenks\",\n        \"FisherJenksSampled\",\n        \"HeadTailBreaks\",\n        \"JenksCaspall\",\n        \"JenksCaspallForced\",\n        \"JenksCaspallSampled\",\n        \"MaxP\",\n        \"MaximumBreaks\",\n        \"NaturalBreaks\",\n        \"Quantiles\",\n        \"Percentiles\",\n        \"StdMean\",\n        \"UserDefined\",\n    ]\n\n    if scheme.lower() not in [s.lower() for s in allowed_schemes]:\n        raise ValueError(\n            f\"{scheme} is not a valid scheme. It must be one of {allowed_schemes}.\"\n        )\n\n    if classification_kwds is None:\n        classification_kwds = {}\n    if \"k\" not in classification_kwds:\n        classification_kwds[\"k\"] = k\n\n    binning = mapclassify.classify(\n        np.asarray(values[~nan_idx]), scheme, **classification_kwds\n    )\n    df[\"category\"] = binning.yb\n    df[\"color\"] = [colors[i] for i in df[\"category\"]]\n\n    if legend_kwds is None:\n        legend_kwds = {}\n\n    if \"interval\" not in legend_kwds:\n        legend_kwds[\"interval\"] = True\n\n    if \"fmt\" not in legend_kwds:\n        if np.issubdtype(df[column].dtype, np.floating):\n            legend_kwds[\"fmt\"] = \"{:.2f}\"\n        else:\n            legend_kwds[\"fmt\"] = \"{:.0f}\"\n\n    if labels is None:\n        # set categorical to True for creating the legend\n        if legend_kwds is not None and \"labels\" in legend_kwds:\n            if len(legend_kwds[\"labels\"]) != binning.k:\n                raise ValueError(\n                    \"Number of labels must match number of bins, \"\n                    \"received {} labels for {} bins\".format(\n                        len(legend_kwds[\"labels\"]), binning.k\n                    )\n                )\n            else:\n                labels = list(legend_kwds.pop(\"labels\"))\n        else:\n            # fmt = \"{:.2f}\"\n            if legend_kwds is not None and \"fmt\" in legend_kwds:\n                fmt = legend_kwds.pop(\"fmt\")\n\n            labels = binning.get_legend_classes(fmt)\n            if legend_kwds is not None:\n                show_interval = legend_kwds.pop(\"interval\", False)\n            else:\n                show_interval = False\n            if not show_interval:\n                labels = [c[1:-1] for c in labels]\n\n        if init_column is not None:\n            labels = value_list\n    elif isinstance(labels, list):\n        if len(labels) != len(colors):\n            raise ValueError(\"The number of labels must match the number of colors.\")\n    else:\n        raise ValueError(\"labels must be a list or None.\")\n\n    legend_dict = dict(zip(labels, colors))\n    df[\"category\"] = df[\"category\"] + 1\n    return df, legend_dict\n</code></pre>"},{"location":"common/#geojp.common.clip_image","title":"<code>clip_image(image, mask, output, to_cog=True)</code>","text":"<p>Clip an image by mask.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>Path to the image file in GeoTIFF format.</p> required <code>mask</code> <code>str | list | dict</code> <p>The mask used to extract the image. It can be a path to vector datasets (e.g., GeoJSON, Shapefile), a list of coordinates, or m.user_roi.</p> required <code>output</code> <code>str</code> <p>Path to the output file.</p> required <code>to_cog</code> <code>bool</code> <p>Flags to indicate if you want to convert the output to COG. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the fiona or rasterio package is not installed.</p> <code>FileNotFoundError</code> <p>If the image is not found.</p> <code>ValueError</code> <p>If the mask is not a valid GeoJSON or raster file.</p> <code>FileNotFoundError</code> <p>If the mask file is not found.</p> Source code in <code>geojp/common.py</code> <pre><code>def clip_image(image, mask, output, to_cog=True):\n    \"\"\"Clip an image by mask.\n\n    Args:\n        image (str): Path to the image file in GeoTIFF format.\n        mask (str | list | dict): The mask used to extract the image. It can be a path to vector datasets (e.g., GeoJSON, Shapefile), a list of coordinates, or m.user_roi.\n        output (str): Path to the output file.\n        to_cog (bool, optional): Flags to indicate if you want to convert the output to COG. Defaults to True.\n\n    Raises:\n        ImportError: If the fiona or rasterio package is not installed.\n        FileNotFoundError: If the image is not found.\n        ValueError: If the mask is not a valid GeoJSON or raster file.\n        FileNotFoundError: If the mask file is not found.\n    \"\"\"\n    try:\n        import json\n        import fiona\n        import rasterio\n        import rasterio.mask\n    except ImportError as e:\n        raise ImportError(e)\n\n    if not os.path.exists(image):\n        raise FileNotFoundError(f\"{image} does not exist.\")\n\n    if not output.endswith(\".tif\"):\n        raise ValueError(\"Output must be a tif file.\")\n\n    output = check_file_path(output)\n\n    if isinstance(mask, str):\n        if mask.startswith(\"http\"):\n            mask = download_file(mask, output)\n        if not os.path.exists(mask):\n            raise FileNotFoundError(f\"{mask} does not exist.\")\n    elif isinstance(mask, list) or isinstance(mask, dict):\n        if isinstance(mask, list):\n            geojson = {\n                \"type\": \"FeatureCollection\",\n                \"features\": [\n                    {\n                        \"type\": \"Feature\",\n                        \"properties\": {},\n                        \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [mask]},\n                    }\n                ],\n            }\n        else:\n            geojson = {\n                \"type\": \"FeatureCollection\",\n                \"features\": [mask],\n            }\n        mask = temp_file_path(\".geojson\")\n        with open(mask, \"w\") as f:\n            json.dump(geojson, f)\n\n    with fiona.open(mask, \"r\") as shapefile:\n        shapes = [feature[\"geometry\"] for feature in shapefile]\n\n    with rasterio.open(image) as src:\n        out_image, out_transform = rasterio.mask.mask(src, shapes, crop=True)\n        out_meta = src.meta\n\n    out_meta.update(\n        {\n            \"driver\": \"GTiff\",\n            \"height\": out_image.shape[1],\n            \"width\": out_image.shape[2],\n            \"transform\": out_transform,\n        }\n    )\n\n    with rasterio.open(output, \"w\", **out_meta) as dest:\n        dest.write(out_image)\n\n    if to_cog:\n        image_to_cog(output, output)\n</code></pre>"},{"location":"common/#geojp.common.cog_validate","title":"<code>cog_validate(source, verbose=False)</code>","text":"<p>Validate Cloud Optimized Geotiff.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>A dataset path or URL. Will be opened in \"r\" mode.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print the output of the validation. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the rio-cogeo package is not installed.</p> <code>FileNotFoundError</code> <p>If the provided file could not be found.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the validation results (True is src_path is a valid COG, List of validation errors, and a list of validation warnings).</p> Source code in <code>geojp/common.py</code> <pre><code>def cog_validate(source, verbose=False):\n    \"\"\"Validate Cloud Optimized Geotiff.\n\n    Args:\n        source (str): A dataset path or URL. Will be opened in \"r\" mode.\n        verbose (bool, optional): Whether to print the output of the validation. Defaults to False.\n\n    Raises:\n        ImportError: If the rio-cogeo package is not installed.\n        FileNotFoundError: If the provided file could not be found.\n\n    Returns:\n        tuple: A tuple containing the validation results (True is src_path is a valid COG, List of validation errors, and a list of validation warnings).\n    \"\"\"\n    try:\n        from rio_cogeo.cogeo import cog_validate, cog_info\n    except ImportError:\n        raise ImportError(\n            \"The rio-cogeo package is not installed. Please install it with `pip install rio-cogeo` or `conda install rio-cogeo -c conda-forge`.\"\n        )\n\n    if not source.startswith(\"http\"):\n        source = check_file_path(source)\n\n        if not os.path.exists(source):\n            raise FileNotFoundError(\"The provided input file could not be found.\")\n\n    if verbose:\n        return cog_info(source)\n    else:\n        return cog_validate(source)\n</code></pre>"},{"location":"common/#geojp.common.connect_postgis","title":"<code>connect_postgis(database, host='localhost', user=None, password=None, port=5432, use_env_var=False)</code>","text":"<p>Connects to a PostGIS database.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str</code> <p>Name of the database</p> required <code>host</code> <code>str</code> <p>Hosting server for the database. Defaults to \"localhost\".</p> <code>'localhost'</code> <code>user</code> <code>str</code> <p>User name to access the database. Defaults to None.</p> <code>None</code> <code>password</code> <code>str</code> <p>Password to access the database. Defaults to None.</p> <code>None</code> <code>port</code> <code>int</code> <p>Port number to connect to at the server host. Defaults to 5432.</p> <code>5432</code> <code>use_env_var</code> <code>bool</code> <p>Whether to use environment variables. It set to True, user and password are treated as an environment variables with default values user=\"SQL_USER\" and password=\"SQL_PASSWORD\". Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If user is not specified.</p> <code>ValueError</code> <p>If password is not specified.</p> <p>Returns:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>geojp/common.py</code> <pre><code>def connect_postgis(\n    database, host=\"localhost\", user=None, password=None, port=5432, use_env_var=False\n):\n    \"\"\"Connects to a PostGIS database.\n\n    Args:\n        database (str): Name of the database\n        host (str, optional): Hosting server for the database. Defaults to \"localhost\".\n        user (str, optional): User name to access the database. Defaults to None.\n        password (str, optional): Password to access the database. Defaults to None.\n        port (int, optional): Port number to connect to at the server host. Defaults to 5432.\n        use_env_var (bool, optional): Whether to use environment variables. It set to True, user and password are treated as an environment variables with default values user=\"SQL_USER\" and password=\"SQL_PASSWORD\". Defaults to False.\n\n    Raises:\n        ValueError: If user is not specified.\n        ValueError: If password is not specified.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    check_package(\n        name=\"sqlalchemy\",\n        URL=\"https://docs.sqlalchemy.org/en/14/intro.html#installation\",\n    )\n\n    from sqlalchemy import create_engine\n\n    if use_env_var:\n        if user is not None:\n            user = os.getenv(user)\n        else:\n            user = os.getenv(\"SQL_USER\")\n\n        if password is not None:\n            password = os.getenv(password)\n        else:\n            password = os.getenv(\"SQL_PASSWORD\")\n\n        if user is None:\n            raise ValueError(\"user is not specified.\")\n        if password is None:\n            raise ValueError(\"password is not specified.\")\n\n    connection_string = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n    engine = create_engine(connection_string)\n\n    return engine\n</code></pre>"},{"location":"common/#geojp.common.convert_coordinates","title":"<code>convert_coordinates(x, y, source_crs, target_crs='epsg:4326')</code>","text":"<p>Convert coordinates from the source EPSG code to the target EPSG code.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate of the point.</p> required <code>y</code> <code>float</code> <p>The y-coordinate of the point.</p> required <code>source_crs</code> <code>str</code> <p>The EPSG code of the source coordinate system.</p> required <code>target_crs</code> <code>str</code> <p>The EPSG code of the target coordinate system. Defaults to '4326' (EPSG code for WGS84).</p> <code>'epsg:4326'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the converted longitude and latitude.</p> Source code in <code>geojp/common.py</code> <pre><code>def convert_coordinates(x, y, source_crs, target_crs=\"epsg:4326\"):\n    \"\"\"Convert coordinates from the source EPSG code to the target EPSG code.\n\n    Args:\n        x (float): The x-coordinate of the point.\n        y (float): The y-coordinate of the point.\n        source_crs (str): The EPSG code of the source coordinate system.\n        target_crs (str, optional): The EPSG code of the target coordinate system.\n            Defaults to '4326' (EPSG code for WGS84).\n\n    Returns:\n        tuple: A tuple containing the converted longitude and latitude.\n    \"\"\"\n    import pyproj\n\n    # Create the transformer\n    transformer = pyproj.Transformer.from_crs(source_crs, target_crs, always_xy=True)\n\n    # Perform the transformation\n    lon, lat = transformer.transform(x, y)\n\n    # Return the converted coordinates\n    return lon, lat\n</code></pre>"},{"location":"common/#geojp.common.convert_lidar","title":"<code>convert_lidar(source, destination=None, point_format_id=None, file_version=None, **kwargs)</code>","text":"<p>Converts a Las from one point format to another Automatically upgrades the file version if source file version     is not compatible with the new point_format_id</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | laspy.lasdatas.base.LasBase</code> <p>The source data to be converted.</p> required <code>destination</code> <code>str</code> <p>The destination file path. Defaults to None.</p> <code>None</code> <code>point_format_id</code> <code>int</code> <p>The new point format id (the default is None, which won't change the source format id).</p> <code>None</code> <code>file_version</code> <code>str</code> <p>The new file version. None by default which means that the file_version may be upgraded for compatibility with the new point_format. The file version will not be downgraded.</p> <code>None</code> <p>Returns:</p> Type Description <code>aspy.lasdatas.base.LasBase</code> <p>The converted LasData object.</p> Source code in <code>geojp/common.py</code> <pre><code>def convert_lidar(\n    source, destination=None, point_format_id=None, file_version=None, **kwargs\n):\n    \"\"\"Converts a Las from one point format to another Automatically upgrades the file version if source file version\n        is not compatible with the new point_format_id\n\n    Args:\n        source (str | laspy.lasdatas.base.LasBase): The source data to be converted.\n        destination (str, optional): The destination file path. Defaults to None.\n        point_format_id (int, optional): The new point format id (the default is None, which won't change the source format id).\n        file_version (str, optional): The new file version. None by default which means that the file_version may be upgraded\n            for compatibility with the new point_format. The file version will not be downgraded.\n\n    Returns:\n        aspy.lasdatas.base.LasBase: The converted LasData object.\n    \"\"\"\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if isinstance(source, str):\n        source = read_lidar(source)\n\n    las = laspy.convert(\n        source, point_format_id=point_format_id, file_version=file_version\n    )\n\n    if destination is None:\n        return las\n    else:\n        destination = check_file_path(destination)\n        write_lidar(las, destination, **kwargs)\n        return destination\n</code></pre>"},{"location":"common/#geojp.common.coords_to_geojson","title":"<code>coords_to_geojson(coords)</code>","text":"<p>Convert a list of bbox coordinates representing [left, bottom, right, top] to geojson FeatureCollection.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list</code> <p>A list of bbox coordinates representing [left, bottom, right, top].</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A geojson FeatureCollection.</p> Source code in <code>geojp/common.py</code> <pre><code>def coords_to_geojson(coords):\n    \"\"\"Convert a list of bbox coordinates representing [left, bottom, right, top] to geojson FeatureCollection.\n\n    Args:\n        coords (list): A list of bbox coordinates representing [left, bottom, right, top].\n\n    Returns:\n        dict: A geojson FeatureCollection.\n    \"\"\"\n\n    features = []\n    for bbox in coords:\n        features.append(bbox_to_geojson(bbox))\n    return {\"type\": \"FeatureCollection\", \"features\": features}\n</code></pre>"},{"location":"common/#geojp.common.coords_to_vector","title":"<code>coords_to_vector(coords, output=None, crs='EPSG:4326', **kwargs)</code>","text":"<p>Convert a list of coordinates to a GeoDataFrame or a vector file.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list</code> <p>A list of coordinates in the format of [(x1, y1), (x2, y2), ...].</p> required <code>output</code> <code>str</code> <p>The path to the output vector file. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The CRS of the coordinates. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFraem</code> <p>A GeoDataFrame of the coordinates.</p> Source code in <code>geojp/common.py</code> <pre><code>def coords_to_vector(coords, output=None, crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Convert a list of coordinates to a GeoDataFrame or a vector file.\n\n    Args:\n        coords (list): A list of coordinates in the format of [(x1, y1), (x2, y2), ...].\n        output (str, optional): The path to the output vector file. Defaults to None.\n        crs (str, optional): The CRS of the coordinates. Defaults to \"EPSG:4326\".\n\n    Returns:\n        gpd.GeoDataFraem: A GeoDataFrame of the coordinates.\n    \"\"\"\n    import geopandas as gpd\n    from shapely.geometry import Point\n\n    if not isinstance(coords, list):\n        raise TypeError(\"coords must be a list of coordinates\")\n\n    if isinstance(coords[0], int) or isinstance(coords[0], float):\n        coords = [(coords[0], coords[1])]\n\n    # convert the points to a GeoDataFrame\n    geometry = [Point(xy) for xy in coords]\n    gdf = gpd.GeoDataFrame(geometry=geometry, crs=\"EPSG:4326\")\n    gdf.to_crs(crs, inplace=True)\n\n    if output is not None:\n        gdf.to_file(output, **kwargs)\n    else:\n        return gdf\n</code></pre>"},{"location":"common/#geojp.common.coords_to_xy","title":"<code>coords_to_xy(src_fp, coords, coord_crs='epsg:4326', request_payer='bucket-owner', env_args={}, open_args={}, **kwargs)</code>","text":"<p>Converts a list of coordinates to pixel coordinates, i.e., (col, row) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>src_fp</code> <code>str</code> <p>The source raster file path.</p> required <code>coords</code> <code>list</code> <p>A list of coordinates in the format of [[x1, y1], [x2, y2], ...]</p> required <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> <code>request_payer</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>env_args</code> <p>Additional keyword arguments to pass to rasterio.Env.</p> <code>{}</code> <code>open_args</code> <p>Additional keyword arguments to pass to rasterio.open.</p> <code>{}</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to rasterio.transform.rowcol.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of pixel coordinates in the format of [[x1, y1], [x2, y2], ...]</p> Source code in <code>geojp/common.py</code> <pre><code>def coords_to_xy(\n    src_fp: str,\n    coords: list,\n    coord_crs: str = \"epsg:4326\",\n    request_payer=\"bucket-owner\",\n    env_args={},\n    open_args={},\n    **kwargs,\n) -&gt; list:\n    \"\"\"Converts a list of coordinates to pixel coordinates, i.e., (col, row) coordinates.\n\n    Args:\n        src_fp: The source raster file path.\n        coords: A list of coordinates in the format of [[x1, y1], [x2, y2], ...]\n        coord_crs: The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".\n        request_payer: Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        env_args: Additional keyword arguments to pass to rasterio.Env.\n        open_args: Additional keyword arguments to pass to rasterio.open.\n        **kwargs: Additional keyword arguments to pass to rasterio.transform.rowcol.\n\n    Returns:\n        A list of pixel coordinates in the format of [[x1, y1], [x2, y2], ...]\n    \"\"\"\n    import numpy as np\n    import rasterio\n\n    if isinstance(coords, np.ndarray):\n        coords = coords.tolist()\n\n    if len(coords) == 4 and all([isinstance(c, (int, float)) for c in coords]):\n        coords = [[coords[0], coords[1]], [coords[2], coords[3]]]\n\n    xs, ys = zip(*coords)\n    with rasterio.Env(AWS_REQUEST_PAYER=request_payer, **env_args):\n        with rasterio.open(src_fp, **open_args) as src:\n            width = src.width\n            height = src.height\n            if coord_crs != src.crs:\n                xs, ys = transform_coords(xs, ys, coord_crs, src.crs, **kwargs)\n            rows, cols = rasterio.transform.rowcol(src.transform, xs, ys, **kwargs)\n        result = [[col, row] for col, row in zip(cols, rows)]\n\n        result = [\n            [x, y] for x, y in result if x &gt;= 0 and y &gt;= 0 and x &lt; width and y &lt; height\n        ]\n        if len(result) == 0:\n            print(\"No valid pixel coordinates found.\")\n        elif len(result) &lt; len(coords):\n            print(\"Some coordinates are out of the image boundary.\")\n\n        return result\n</code></pre>"},{"location":"common/#geojp.common.create_code_cell","title":"<code>create_code_cell(code='', where='below')</code>","text":"<p>Creates a code cell in the IPython Notebook.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Code to fill the new code cell with. Defaults to ''.</p> <code>''</code> <code>where</code> <code>str</code> <p>Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'.</p> <code>'below'</code> Source code in <code>geojp/common.py</code> <pre><code>def create_code_cell(code=\"\", where=\"below\"):\n    \"\"\"Creates a code cell in the IPython Notebook.\n\n    Args:\n        code (str, optional): Code to fill the new code cell with. Defaults to ''.\n        where (str, optional): Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'.\n    \"\"\"\n\n    import base64\n    from IPython.display import Javascript, display\n\n    encoded_code = (base64.b64encode(str.encode(code))).decode()\n    display(\n        Javascript(\n            \"\"\"\n        var code = IPython.notebook.insert_cell_{0}('code');\n        code.set_text(atob(\"{1}\"));\n    \"\"\".format(\n                where, encoded_code\n            )\n        )\n    )\n</code></pre>"},{"location":"common/#geojp.common.create_download_link","title":"<code>create_download_link(filename, title='Click here to download: ')</code>","text":"<p>Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file path to the file to download</p> required <code>title</code> <code>str</code> <p>str. Defaults to \"Click here to download: \".</p> <code>'Click here to download: '</code> <p>Returns:</p> Type Description <code>str</code> <p>HTML download URL.</p> Source code in <code>geojp/common.py</code> <pre><code>def create_download_link(filename, title=\"Click here to download: \"):\n    \"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578\n\n    Args:\n        filename (str): The file path to the file to download\n        title (str, optional): str. Defaults to \"Click here to download: \".\n\n    Returns:\n        str: HTML download URL.\n    \"\"\"\n    import base64\n    from IPython.display import HTML\n\n    data = open(filename, \"rb\").read()\n    b64 = base64.b64encode(data)\n    payload = b64.decode()\n    basename = os.path.basename(filename)\n    html = '&lt;a download=\"{filename}\" href=\"data:text/csv;base64,{payload}\" style=\"color:#0000FF;\" target=\"_blank\"&gt;{title}&lt;/a&gt;'\n    html = html.format(payload=payload, title=title + f\" {basename}\", filename=basename)\n    return HTML(html)\n</code></pre>"},{"location":"common/#geojp.common.create_legend","title":"<code>create_legend(title='Legend', labels=None, colors=None, legend_dict=None, builtin_legend=None, opacity=1.0, position='bottomright', draggable=True, output=None, style={})</code>","text":"<p>Create a legend in HTML format. Reference: https://bit.ly/3oV6vnH</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".</p> <code>'Legend'</code> <code>colors</code> <code>list</code> <p>A list of legend colors. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>A list of legend labels. Defaults to None.</p> <code>None</code> <code>legend_dict</code> <code>dict</code> <p>A dictionary containing legend items as keys and color as values. If provided, legend_keys and legend_colors will be ignored. Defaults to None.</p> <code>None</code> <code>builtin_legend</code> <code>str</code> <p>Name of the builtin legend to add to the map. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the legend. Defaults to 1.0.</p> <code>1.0</code> <code>position</code> <code>str</code> <p>The position of the legend, can be one of the following: \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>draggable</code> <code>bool</code> <p>If True, the legend can be dragged to a new position. Defaults to True.</p> <code>True</code> <code>output</code> <code>str</code> <p>The output file path (*.html) to save the legend. Defaults to None.</p> <code>None</code> <code>style</code> <p>Additional keyword arguments to style the legend, such as position, bottom, right, z-index, border, background-color, border-radius, padding, font-size, etc. The default style is: style = {     'position': 'fixed',     'z-index': '9999',     'border': '2px solid grey',     'background-color': 'rgba(255, 255, 255, 0.8)',     'border-radius': '5px',     'padding': '10px',     'font-size': '14px',     'bottom': '20px',     'right': '5px' }</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of the legend.</p> Source code in <code>geojp/common.py</code> <pre><code>def create_legend(\n    title=\"Legend\",\n    labels=None,\n    colors=None,\n    legend_dict=None,\n    builtin_legend=None,\n    opacity=1.0,\n    position=\"bottomright\",\n    draggable=True,\n    output=None,\n    style={},\n):\n    \"\"\"Create a legend in HTML format. Reference: https://bit.ly/3oV6vnH\n\n    Args:\n        title (str, optional): Title of the legend. Defaults to 'Legend'. Defaults to \"Legend\".\n        colors (list, optional): A list of legend colors. Defaults to None.\n        labels (list, optional): A list of legend labels. Defaults to None.\n        legend_dict (dict, optional): A dictionary containing legend items as keys and color as values.\n            If provided, legend_keys and legend_colors will be ignored. Defaults to None.\n        builtin_legend (str, optional): Name of the builtin legend to add to the map. Defaults to None.\n        opacity (float, optional): The opacity of the legend. Defaults to 1.0.\n        position (str, optional): The position of the legend, can be one of the following:\n            \"topleft\", \"topright\", \"bottomleft\", \"bottomright\". Defaults to \"bottomright\".\n        draggable (bool, optional): If True, the legend can be dragged to a new position. Defaults to True.\n        output (str, optional): The output file path (*.html) to save the legend. Defaults to None.\n        style: Additional keyword arguments to style the legend, such as position, bottom, right, z-index,\n            border, background-color, border-radius, padding, font-size, etc. The default style is:\n            style = {\n                'position': 'fixed',\n                'z-index': '9999',\n                'border': '2px solid grey',\n                'background-color': 'rgba(255, 255, 255, 0.8)',\n                'border-radius': '5px',\n                'padding': '10px',\n                'font-size': '14px',\n                'bottom': '20px',\n                'right': '5px'\n            }\n\n    Returns:\n        str: The HTML code of the legend.\n    \"\"\"\n\n    import pkg_resources\n    from .legends import builtin_legends\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"leafmap\", \"leafmap.py\"))\n    legend_template = os.path.join(pkg_dir, \"data/template/legend_style.html\")\n\n    if draggable:\n        legend_template = os.path.join(pkg_dir, \"data/template/legend.txt\")\n\n    if not os.path.exists(legend_template):\n        raise FileNotFoundError(\"The legend template does not exist.\")\n\n    if labels is not None:\n        if not isinstance(labels, list):\n            print(\"The legend keys must be a list.\")\n            return\n    else:\n        labels = [\"One\", \"Two\", \"Three\", \"Four\", \"etc\"]\n\n    if colors is not None:\n        if not isinstance(colors, list):\n            print(\"The legend colors must be a list.\")\n            return\n        elif all(isinstance(item, tuple) for item in colors):\n            try:\n                colors = [rgb_to_hex(x) for x in colors]\n            except Exception as e:\n                print(e)\n        elif all((item.startswith(\"#\") and len(item) == 7) for item in colors):\n            pass\n        elif all((len(item) == 6) for item in colors):\n            pass\n        else:\n            print(\"The legend colors must be a list of tuples.\")\n            return\n    else:\n        colors = [\n            \"#8DD3C7\",\n            \"#FFFFB3\",\n            \"#BEBADA\",\n            \"#FB8072\",\n            \"#80B1D3\",\n        ]\n\n    if len(labels) != len(colors):\n        print(\"The legend keys and values must be the same length.\")\n        return\n\n    allowed_builtin_legends = builtin_legends.keys()\n    if builtin_legend is not None:\n        if builtin_legend not in allowed_builtin_legends:\n            print(\n                \"The builtin legend must be one of the following: {}\".format(\n                    \", \".join(allowed_builtin_legends)\n                )\n            )\n            return\n        else:\n            legend_dict = builtin_legends[builtin_legend]\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n\n    if legend_dict is not None:\n        if not isinstance(legend_dict, dict):\n            print(\"The legend dict must be a dictionary.\")\n            return\n        else:\n            labels = list(legend_dict.keys())\n            colors = list(legend_dict.values())\n            if all(isinstance(item, tuple) for item in colors):\n                try:\n                    colors = [rgb_to_hex(x) for x in colors]\n                except Exception as e:\n                    print(e)\n\n    allowed_positions = [\n        \"topleft\",\n        \"topright\",\n        \"bottomleft\",\n        \"bottomright\",\n    ]\n    if position not in allowed_positions:\n        raise ValueError(\n            \"The position must be one of the following: {}\".format(\n                \", \".join(allowed_positions)\n            )\n        )\n\n    if position == \"bottomright\":\n        if \"bottom\" not in style:\n            style[\"bottom\"] = \"20px\"\n        if \"right\" not in style:\n            style[\"right\"] = \"5px\"\n        if \"left\" in style:\n            del style[\"left\"]\n        if \"top\" in style:\n            del style[\"top\"]\n    elif position == \"bottomleft\":\n        if \"bottom\" not in style:\n            style[\"bottom\"] = \"5px\"\n        if \"left\" not in style:\n            style[\"left\"] = \"5px\"\n        if \"right\" in style:\n            del style[\"right\"]\n        if \"top\" in style:\n            del style[\"top\"]\n    elif position == \"topright\":\n        if \"top\" not in style:\n            style[\"top\"] = \"5px\"\n        if \"right\" not in style:\n            style[\"right\"] = \"5px\"\n        if \"left\" in style:\n            del style[\"left\"]\n        if \"bottom\" in style:\n            del style[\"bottom\"]\n    elif position == \"topleft\":\n        if \"top\" not in style:\n            style[\"top\"] = \"5px\"\n        if \"left\" not in style:\n            style[\"left\"] = \"5px\"\n        if \"right\" in style:\n            del style[\"right\"]\n        if \"bottom\" in style:\n            del style[\"bottom\"]\n\n    if \"position\" not in style:\n        style[\"position\"] = \"fixed\"\n    if \"z-index\" not in style:\n        style[\"z-index\"] = \"9999\"\n    if \"background-color\" not in style:\n        style[\"background-color\"] = \"rgba(255, 255, 255, 0.8)\"\n    if \"padding\" not in style:\n        style[\"padding\"] = \"10px\"\n    if \"border-radius\" not in style:\n        style[\"border-radius\"] = \"5px\"\n    if \"font-size\" not in style:\n        style[\"font-size\"] = \"14px\"\n\n    content = []\n\n    with open(legend_template) as f:\n        lines = f.readlines()\n\n    if draggable:\n        for index, line in enumerate(lines):\n            if index &lt; 36:\n                content.append(line)\n            elif index == 36:\n                line = lines[index].replace(\"Legend\", title)\n                content.append(line)\n            elif index &lt; 39:\n                content.append(line)\n            elif index == 39:\n                for i, color in enumerate(colors):\n                    item = f\"    &lt;li&gt;&lt;span style='background:{check_color(color)};opacity:{opacity};'&gt;&lt;/span&gt;{labels[i]}&lt;/li&gt;\\n\"\n                    content.append(item)\n            elif index &gt; 41:\n                content.append(line)\n        content = content[3:-1]\n\n    else:\n        for index, line in enumerate(lines):\n            if index &lt; 8:\n                content.append(line)\n            elif index == 8:\n                for key, value in style.items():\n                    content.append(\n                        \"              {}: {};\\n\".format(key.replace(\"_\", \"-\"), value)\n                    )\n            elif index &lt; 17:\n                pass\n            elif index &lt; 19:\n                content.append(line)\n            elif index == 19:\n                content.append(line.replace(\"Legend\", title))\n            elif index &lt; 22:\n                content.append(line)\n            elif index == 22:\n                for index, key in enumerate(labels):\n                    color = colors[index]\n                    if not color.startswith(\"#\"):\n                        color = \"#\" + color\n                    item = \"                    &lt;li&gt;&lt;span style='background:{};opacity:{};'&gt;&lt;/span&gt;{}&lt;/li&gt;\\n\".format(\n                        color, opacity, key\n                    )\n                    content.append(item)\n            elif index &lt; 33:\n                pass\n            else:\n                content.append(line)\n\n    legend_text = \"\".join(content)\n\n    if output is not None:\n        with open(output, \"w\") as f:\n            f.write(legend_text)\n    else:\n        return legend_text\n</code></pre>"},{"location":"common/#geojp.common.create_timelapse","title":"<code>create_timelapse(images, out_gif, ext='.tif', bands=None, size=None, bbox=None, fps=5, loop=0, add_progress_bar=True, progress_bar_color='blue', progress_bar_height=5, add_text=False, text_xy=None, text_sequence=None, font_type='arial.ttf', font_size=20, font_color='black', mp4=False, quiet=True, reduce_size=False, clean_up=True, **kwargs)</code>","text":"<p>Creates a timelapse gif from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list | str</code> <p>The list of images or input directory to create the gif from. For example, '/path/to/images/*.tif' or ['/path/to/image1.tif', '/path/to/image2.tif', ...]</p> required <code>out_gif</code> <code>str</code> <p>File path to the output gif.</p> required <code>ext</code> <code>str</code> <p>The extension of the images. Defaults to '.tif'.</p> <code>'.tif'</code> <code>bands</code> <code>list</code> <p>The bands to use for the gif. For example, [0, 1, 2] for RGB, and [0] for grayscale. Defaults to None.</p> <code>None</code> <code>size</code> <code>tuple</code> <p>The size of the gif. For example, (500, 500). Defaults to None, using the original size.</p> <code>None</code> <code>bbox</code> <code>list</code> <p>The bounding box of the gif. For example, [xmin, ymin, xmax, ymax]. Defaults to None, using the original bounding box.</p> <code>None</code> <code>fps</code> <code>int</code> <p>The frames per second of the gif. Defaults to 5.</p> <code>5</code> <code>loop</code> <code>int</code> <p>The number of times to loop the gif. Defaults to 0, looping forever.</p> <code>0</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar to the gif. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>The color of the progress bar, can be color name or hex code. Defaults to 'blue'.</p> <code>'blue'</code> <code>progress_bar_height</code> <code>int</code> <p>The height of the progress bar. Defaults to 5.</p> <code>5</code> <code>add_text</code> <code>bool</code> <p>Whether to add text to the gif. Defaults to False.</p> <code>False</code> <code>text_xy</code> <code>tuple</code> <p>The x, y coordinates of the text. For example, ('10%', '10%'). Defaults to None, using the bottom left corner.</p> <code>None</code> <code>text_sequence</code> <code>list</code> <p>The sequence of text to add to the gif. For example, ['year 1', 'year 2', ...].</p> <code>None</code> <code>font_type</code> <code>str</code> <p>The font type of the text, can be 'arial.ttf' or 'alibaba.otf', or any system font. Defaults to 'arial.ttf'.</p> <code>'arial.ttf'</code> <code>font_size</code> <code>int</code> <p>The font size of the text. Defaults to 20.</p> <code>20</code> <code>font_color</code> <code>str</code> <p>The color of the text, can be color name or hex code. Defaults to 'black'.</p> <code>'black'</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the gif to mp4. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Whether to print the progress. Defaults to False.</p> <code>True</code> <code>reduce_size</code> <code>bool</code> <p>Whether to reduce the size of the gif using ffmpeg. Defaults to False.</p> <code>False</code> <code>clean_up</code> <code>bool</code> <p>Whether to clean up the temporary files. Defaults to True.</p> <code>True</code> Source code in <code>geojp/common.py</code> <pre><code>def create_timelapse(\n    images: Union[List, str],\n    out_gif: str,\n    ext: str = \".tif\",\n    bands: Optional[List] = None,\n    size: Optional[Tuple] = None,\n    bbox: Optional[List] = None,\n    fps: int = 5,\n    loop: int = 0,\n    add_progress_bar: bool = True,\n    progress_bar_color: str = \"blue\",\n    progress_bar_height: int = 5,\n    add_text: bool = False,\n    text_xy: Optional[Tuple] = None,\n    text_sequence: Optional[List] = None,\n    font_type: str = \"arial.ttf\",\n    font_size: int = 20,\n    font_color: str = \"black\",\n    mp4: bool = False,\n    quiet: bool = True,\n    reduce_size: bool = False,\n    clean_up: bool = True,\n    **kwargs,\n):\n    \"\"\"Creates a timelapse gif from a list of images.\n\n    Args:\n        images (list | str): The list of images or input directory to create the gif from.\n            For example, '/path/to/images/*.tif' or ['/path/to/image1.tif', '/path/to/image2.tif', ...]\n        out_gif (str): File path to the output gif.\n        ext (str, optional): The extension of the images. Defaults to '.tif'.\n        bands (list, optional): The bands to use for the gif. For example, [0, 1, 2] for RGB, and [0] for grayscale. Defaults to None.\n        size (tuple, optional): The size of the gif. For example, (500, 500). Defaults to None, using the original size.\n        bbox (list, optional): The bounding box of the gif. For example, [xmin, ymin, xmax, ymax]. Defaults to None, using the original bounding box.\n        fps (int, optional): The frames per second of the gif. Defaults to 5.\n        loop (int, optional): The number of times to loop the gif. Defaults to 0, looping forever.\n        add_progress_bar (bool, optional): Whether to add a progress bar to the gif. Defaults to True.\n        progress_bar_color (str, optional): The color of the progress bar, can be color name or hex code. Defaults to 'blue'.\n        progress_bar_height (int, optional): The height of the progress bar. Defaults to 5.\n        add_text (bool, optional): Whether to add text to the gif. Defaults to False.\n        text_xy (tuple, optional): The x, y coordinates of the text. For example, ('10%', '10%').\n            Defaults to None, using the bottom left corner.\n        text_sequence (list, optional): The sequence of text to add to the gif. For example, ['year 1', 'year 2', ...].\n        font_type (str, optional): The font type of the text, can be 'arial.ttf' or 'alibaba.otf', or any system font. Defaults to 'arial.ttf'.\n        font_size (int, optional): The font size of the text. Defaults to 20.\n        font_color (str, optional): The color of the text, can be color name or hex code. Defaults to 'black'.\n        mp4 (bool, optional): Whether to convert the gif to mp4. Defaults to False.\n        quiet (bool, optional): Whether to print the progress. Defaults to False.\n        reduce_size (bool, optional): Whether to reduce the size of the gif using ffmpeg. Defaults to False.\n        clean_up (bool, optional): Whether to clean up the temporary files. Defaults to True.\n\n    \"\"\"\n\n    import glob\n    import tempfile\n\n    if isinstance(images, str):\n        if not images.endswith(ext):\n            images = os.path.join(images, f\"*{ext}\")\n        images = list(glob.glob(images))\n\n    if not isinstance(images, list):\n        raise ValueError(\"images must be a list or a path to the image directory.\")\n\n    images.sort()\n\n    temp_dir = os.path.join(tempfile.gettempdir(), \"timelapse\")\n    if not os.path.exists(temp_dir):\n        os.makedirs(temp_dir)\n\n    if bbox is not None:\n        clip_dir = os.path.join(tempfile.gettempdir(), \"clip\")\n        if not os.path.exists(clip_dir):\n            os.makedirs(clip_dir)\n\n        if len(bbox) == 4:\n            bbox = bbox_to_geojson(bbox)\n\n    else:\n        clip_dir = None\n\n    output = widgets.Output()\n\n    if \"out_ext\" in kwargs:\n        out_ext = kwargs[\"out_ext\"].lower()\n    else:\n        out_ext = \".jpg\"\n\n    try:\n        for index, image in enumerate(images):\n            if bbox is not None:\n                clip_file = os.path.join(clip_dir, os.path.basename(image))\n                with output:\n                    clip_image(image, mask=bbox, output=clip_file, to_cog=False)\n                image = clip_file\n\n            if \"add_prefix\" in kwargs:\n                basename = (\n                    str(f\"{index + 1}\").zfill(len(str(len(images))))\n                    + \"-\"\n                    + os.path.basename(image).replace(ext, out_ext)\n                )\n            else:\n                basename = os.path.basename(image).replace(ext, out_ext)\n            if not quiet:\n                print(f\"Processing {index+1}/{len(images)}: {basename} ...\")\n\n            # ignore GDAL warnings\n            with output:\n                numpy_to_image(\n                    image, os.path.join(temp_dir, basename), bands=bands, size=size\n                )\n        make_gif(\n            temp_dir,\n            out_gif,\n            ext=out_ext,\n            fps=fps,\n            loop=loop,\n            mp4=mp4,\n            clean_up=clean_up,\n        )\n\n        if clip_dir is not None:\n            shutil.rmtree(clip_dir)\n\n        if add_text:\n            add_text_to_gif(\n                out_gif,\n                out_gif,\n                text_xy,\n                text_sequence,\n                font_type,\n                font_size,\n                font_color,\n                add_progress_bar,\n                progress_bar_color,\n                progress_bar_height,\n                1000 / fps,\n                loop,\n            )\n        elif add_progress_bar:\n            add_progress_bar_to_gif(\n                out_gif,\n                out_gif,\n                progress_bar_color,\n                progress_bar_height,\n                1000 / fps,\n                loop,\n            )\n\n        if reduce_size:\n            reduce_gif_size(out_gif)\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geojp.common.csv_points_to_shp","title":"<code>csv_points_to_shp(in_csv, out_shp, latitude='latitude', longitude='longitude')</code>","text":"<p>Converts a csv file containing points (latitude, longitude) into a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path or HTTP URL to the input csv file. For example, https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv</p> required <code>out_shp</code> <code>str</code> <p>File path to the output shapefile.</p> required <code>latitude</code> <code>str</code> <p>Column name for the latitude column. Defaults to 'latitude'.</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>Column name for the longitude column. Defaults to 'longitude'.</p> <code>'longitude'</code> Source code in <code>geojp/common.py</code> <pre><code>def csv_points_to_shp(in_csv, out_shp, latitude=\"latitude\", longitude=\"longitude\"):\n    \"\"\"Converts a csv file containing points (latitude, longitude) into a shapefile.\n\n    Args:\n        in_csv (str): File path or HTTP URL to the input csv file. For example, https://raw.githubusercontent.com/opengeos/data/main/world/world_cities.csv\n        out_shp (str): File path to the output shapefile.\n        latitude (str, optional): Column name for the latitude column. Defaults to 'latitude'.\n        longitude (str, optional): Column name for the longitude column. Defaults to 'longitude'.\n\n    \"\"\"\n\n    if in_csv.startswith(\"http\") and in_csv.endswith(\".csv\"):\n        out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        out_name = os.path.basename(in_csv)\n\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n        download_from_url(in_csv, out_dir=out_dir)\n        in_csv = os.path.join(out_dir, out_name)\n\n    wbt = whitebox.WhiteboxTools()\n    in_csv = os.path.abspath(in_csv)\n    out_shp = os.path.abspath(out_shp)\n\n    if not os.path.exists(in_csv):\n        raise Exception(\"The provided csv file does not exist.\")\n\n    with open(in_csv, encoding=\"utf-8\") as csv_file:\n        reader = csv.DictReader(csv_file)\n        fields = reader.fieldnames\n        xfield = fields.index(longitude)\n        yfield = fields.index(latitude)\n\n    wbt.csv_points_to_vector(in_csv, out_shp, xfield=xfield, yfield=yfield, epsg=4326)\n</code></pre>"},{"location":"common/#geojp.common.csv_to_df","title":"<code>csv_to_df(in_csv, **kwargs)</code>","text":"<p>Converts a CSV file to pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>File path to the input CSV.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pandas DataFrame</p> Source code in <code>geojp/common.py</code> <pre><code>def csv_to_df(in_csv, **kwargs):\n    \"\"\"Converts a CSV file to pandas dataframe.\n\n    Args:\n        in_csv (str): File path to the input CSV.\n\n    Returns:\n        pd.DataFrame: pandas DataFrame\n    \"\"\"\n    import pandas as pd\n\n    try:\n        return pd.read_csv(in_csv, **kwargs)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.csv_to_gdf","title":"<code>csv_to_gdf(in_csv, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Creates points for a CSV file and converts them to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>object</code> <p>GeoDataFrame.</p> Source code in <code>geojp/common.py</code> <pre><code>def csv_to_gdf(in_csv, latitude=\"latitude\", longitude=\"longitude\", encoding=\"utf-8\"):\n    \"\"\"Creates points for a CSV file and converts them to a GeoDataFrame.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    Returns:\n        object: GeoDataFrame.\n    \"\"\"\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    out_dir = os.getcwd()\n\n    out_geojson = os.path.join(out_dir, random_string() + \".geojson\")\n    csv_to_geojson(in_csv, out_geojson, latitude, longitude, encoding)\n\n    gdf = gpd.read_file(out_geojson)\n    os.remove(out_geojson)\n    return gdf\n</code></pre>"},{"location":"common/#geojp.common.csv_to_geojson","title":"<code>csv_to_geojson(in_csv, out_geojson=None, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Creates points for a CSV file and exports data as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the exported GeoJSON. Default to None.</p> <code>None</code> <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>geojp/common.py</code> <pre><code>def csv_to_geojson(\n    in_csv,\n    out_geojson=None,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    encoding=\"utf-8\",\n):\n    \"\"\"Creates points for a CSV file and exports data as a GeoJSON.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        out_geojson (str): The file path to the exported GeoJSON. Default to None.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    \"\"\"\n\n    import pandas as pd\n\n    in_csv = github_raw_url(in_csv)\n\n    if out_geojson is not None:\n        out_geojson = check_file_path(out_geojson)\n\n    df = pd.read_csv(in_csv)\n    geojson = df_to_geojson(\n        df, latitude=latitude, longitude=longitude, encoding=encoding\n    )\n\n    if out_geojson is None:\n        return geojson\n    else:\n        with open(out_geojson, \"w\", encoding=encoding) as f:\n            f.write(json.dumps(geojson))\n</code></pre>"},{"location":"common/#geojp.common.csv_to_shp","title":"<code>csv_to_shp(in_csv, out_shp, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Converts a csv file with latlon info to a point shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The input csv file containing longitude and latitude columns.</p> required <code>out_shp</code> <code>str</code> <p>The file path to the output shapefile.</p> required <code>latitude</code> <code>str</code> <p>The column name of the latitude column. Defaults to 'latitude'.</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of the longitude column. Defaults to 'longitude'.</p> <code>'longitude'</code> Source code in <code>geojp/common.py</code> <pre><code>def csv_to_shp(\n    in_csv, out_shp, latitude=\"latitude\", longitude=\"longitude\", encoding=\"utf-8\"\n):\n    \"\"\"Converts a csv file with latlon info to a point shapefile.\n\n    Args:\n        in_csv (str): The input csv file containing longitude and latitude columns.\n        out_shp (str): The file path to the output shapefile.\n        latitude (str, optional): The column name of the latitude column. Defaults to 'latitude'.\n        longitude (str, optional): The column name of the longitude column. Defaults to 'longitude'.\n    \"\"\"\n    import shapefile as shp\n\n    if in_csv.startswith(\"http\") and in_csv.endswith(\".csv\"):\n        in_csv = github_raw_url(in_csv)\n        in_csv = download_file(in_csv, quiet=True, overwrite=True)\n\n    try:\n        points = shp.Writer(out_shp, shapeType=shp.POINT)\n        with open(in_csv, encoding=encoding) as csvfile:\n            csvreader = csv.DictReader(csvfile)\n            header = csvreader.fieldnames\n            [points.field(field) for field in header]\n            for row in csvreader:\n                points.point((float(row[longitude])), (float(row[latitude])))\n                points.record(*tuple([row[f] for f in header]))\n\n        out_prj = out_shp.replace(\".shp\", \".prj\")\n        with open(out_prj, \"w\") as f:\n            prj_str = 'GEOGCS[\"GCS_WGS_1984\",DATUM[\"D_WGS_1984\",SPHEROID[\"WGS_1984\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"Degree\",0.0174532925199433]] '\n            f.write(prj_str)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.csv_to_vector","title":"<code>csv_to_vector(in_csv, output, latitude='latitude', longitude='longitude', encoding='utf-8', **kwargs)</code>","text":"<p>Creates points for a CSV file and converts them to a vector dataset.</p> <p>Parameters:</p> Name Type Description Default <code>in_csv</code> <code>str</code> <p>The file path to the input CSV file.</p> required <code>output</code> <code>str</code> <p>The file path to the output vector dataset.</p> required <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>geojp/common.py</code> <pre><code>def csv_to_vector(\n    in_csv,\n    output,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"Creates points for a CSV file and converts them to a vector dataset.\n\n    Args:\n        in_csv (str): The file path to the input CSV file.\n        output (str): The file path to the output vector dataset.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    \"\"\"\n    gdf = csv_to_gdf(in_csv, latitude, longitude, encoding)\n    gdf.to_file(output, **kwargs)\n</code></pre>"},{"location":"common/#geojp.common.delete_shp","title":"<code>delete_shp(in_shp, verbose=False)</code>","text":"<p>Deletes a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>The input shapefile to delete.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print out descriptive text. Defaults to True.</p> <code>False</code> Source code in <code>geojp/common.py</code> <pre><code>def delete_shp(in_shp, verbose=False):\n    \"\"\"Deletes a shapefile.\n\n    Args:\n        in_shp (str): The input shapefile to delete.\n        verbose (bool, optional): Whether to print out descriptive text. Defaults to True.\n    \"\"\"\n    from pathlib import Path\n\n    in_shp = os.path.abspath(in_shp)\n    in_dir = os.path.dirname(in_shp)\n    basename = os.path.basename(in_shp).replace(\".shp\", \"\")\n\n    files = Path(in_dir).rglob(basename + \".*\")\n\n    for file in files:\n        filepath = os.path.join(in_dir, str(file))\n        os.remove(filepath)\n        if verbose:\n            print(f\"Deleted {filepath}\")\n</code></pre>"},{"location":"common/#geojp.common.df_to_gdf","title":"<code>df_to_gdf(df, geometry='geometry', src_crs='EPSG:4326', dst_crs=None, **kwargs)</code>","text":"<p>Converts a pandas DataFrame to a GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>The pandas DataFrame to convert.</p> required <code>geometry</code> <code>str</code> <p>The name of the geometry column in the DataFrame.</p> <code>'geometry'</code> <code>src_crs</code> <code>str</code> <p>The coordinate reference system (CRS) of the GeoDataFrame. Default is \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>dst_crs</code> <code>str</code> <p>The target CRS of the GeoDataFrame. Default is None</p> <code>None</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>The converted GeoPandas GeoDataFrame.</p> Source code in <code>geojp/common.py</code> <pre><code>def df_to_gdf(df, geometry=\"geometry\", src_crs=\"EPSG:4326\", dst_crs=None, **kwargs):\n    \"\"\"\n    Converts a pandas DataFrame to a GeoPandas GeoDataFrame.\n\n    Args:\n        df (pandas.DataFrame): The pandas DataFrame to convert.\n        geometry (str): The name of the geometry column in the DataFrame.\n        src_crs (str): The coordinate reference system (CRS) of the GeoDataFrame. Default is \"EPSG:4326\".\n        dst_crs (str): The target CRS of the GeoDataFrame. Default is None\n\n    Returns:\n        geopandas.GeoDataFrame: The converted GeoPandas GeoDataFrame.\n    \"\"\"\n    import geopandas as gpd\n    from shapely import wkt\n\n    # Convert the geometry column to Shapely geometry objects\n    df[geometry] = df[geometry].apply(lambda x: wkt.loads(x))\n\n    # Convert the pandas DataFrame to a GeoPandas GeoDataFrame\n    gdf = gpd.GeoDataFrame(df, geometry=geometry, crs=src_crs, **kwargs)\n    if dst_crs is not None and dst_crs != src_crs:\n        gdf = gdf.to_crs(dst_crs)\n\n    return gdf\n</code></pre>"},{"location":"common/#geojp.common.df_to_geojson","title":"<code>df_to_geojson(df, out_geojson=None, latitude='latitude', longitude='longitude', encoding='utf-8')</code>","text":"<p>Creates points for a Pandas DataFrame and exports data as a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pandas.DataFrame</code> <p>The input Pandas DataFrame.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the exported GeoJSON. Default to None.</p> <code>None</code> <code>latitude</code> <code>str</code> <p>The name of the column containing latitude coordinates. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The name of the column containing longitude coordinates. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>encoding</code> <code>str</code> <p>The encoding of characters. Defaults to \"utf-8\".</p> <code>'utf-8'</code> Source code in <code>geojp/common.py</code> <pre><code>def df_to_geojson(\n    df,\n    out_geojson=None,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    encoding=\"utf-8\",\n):\n    \"\"\"Creates points for a Pandas DataFrame and exports data as a GeoJSON.\n\n    Args:\n        df (pandas.DataFrame): The input Pandas DataFrame.\n        out_geojson (str): The file path to the exported GeoJSON. Default to None.\n        latitude (str, optional): The name of the column containing latitude coordinates. Defaults to \"latitude\".\n        longitude (str, optional): The name of the column containing longitude coordinates. Defaults to \"longitude\".\n        encoding (str, optional): The encoding of characters. Defaults to \"utf-8\".\n\n    \"\"\"\n\n    import json\n    from geojson import Feature, FeatureCollection, Point\n\n    if out_geojson is not None:\n        out_dir = os.path.dirname(os.path.abspath(out_geojson))\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n    features = df.apply(\n        lambda row: Feature(\n            geometry=Point((float(row[longitude]), float(row[latitude]))),\n            properties=dict(row),\n        ),\n        axis=1,\n    ).tolist()\n\n    geojson = FeatureCollection(features=features)\n\n    if out_geojson is None:\n        return geojson\n    else:\n        with open(out_geojson, \"w\", encoding=encoding) as f:\n            f.write(json.dumps(geojson))\n</code></pre>"},{"location":"common/#geojp.common.dict_to_json","title":"<code>dict_to_json(data, file_path, indent=4)</code>","text":"<p>Writes a dictionary to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary.</p> required <code>file_path</code> <code>str</code> <p>The path to the JSON file.</p> required <code>indent</code> <code>int</code> <p>The indentation of the JSON file. Defaults to 4.</p> <code>4</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the input data is not a dictionary.</p> Source code in <code>geojp/common.py</code> <pre><code>def dict_to_json(data, file_path, indent=4):\n    \"\"\"Writes a dictionary to a JSON file.\n\n    Args:\n        data (dict): A dictionary.\n        file_path (str): The path to the JSON file.\n        indent (int, optional): The indentation of the JSON file. Defaults to 4.\n\n    Raises:\n        TypeError: If the input data is not a dictionary.\n    \"\"\"\n    import json\n\n    file_path = check_file_path(file_path)\n\n    if isinstance(data, dict):\n        with open(file_path, \"w\") as f:\n            json.dump(data, f, indent=indent)\n    else:\n        raise TypeError(\"The provided data must be a dictionary.\")\n</code></pre>"},{"location":"common/#geojp.common.disjoint","title":"<code>disjoint(input_features, selecting_features, output=None, **kwargs)</code>","text":"<p>Find the features in the input_features that do not intersect the selecting_features.</p> <p>Parameters:</p> Name Type Description Default <code>input_features</code> <code>str | GeoDataFrame</code> <p>The input features to select from. Can be a file path or a GeoDataFrame.</p> required <code>selecting_features</code> <code>str | GeoDataFrame</code> <p>The features in the Input Features parameter will be selected based on their relationship to the features from this layer.</p> required <code>output</code> <code>are</code> <p>The output path to save the GeoDataFrame in a vector format (e.g., shapefile). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str | GeoDataFrame</code> <p>The path to the output file or the GeoDataFrame.</p> Source code in <code>geojp/common.py</code> <pre><code>def disjoint(input_features, selecting_features, output=None, **kwargs):\n    \"\"\"Find the features in the input_features that do not intersect the selecting_features.\n\n    Args:\n        input_features (str | GeoDataFrame): The input features to select from. Can be a file path or a GeoDataFrame.\n        selecting_features (str | GeoDataFrame): The features in the Input Features parameter will be selected based\n            on their relationship to the features from this layer.\n        output (are, optional): The output path to save the GeoDataFrame in a vector format (e.g., shapefile). Defaults to None.\n\n    Returns:\n        str | GeoDataFrame: The path to the output file or the GeoDataFrame.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(input_features, str):\n        input_features = gpd.read_file(input_features, **kwargs)\n    elif not isinstance(input_features, gpd.GeoDataFrame):\n        raise TypeError(\"input_features must be a file path or a GeoDataFrame\")\n\n    if isinstance(selecting_features, str):\n        selecting_features = gpd.read_file(selecting_features, **kwargs)\n    elif not isinstance(selecting_features, gpd.GeoDataFrame):\n        raise TypeError(\"selecting_features must be a file path or a GeoDataFrame\")\n\n    selecting_features = selecting_features.to_crs(input_features.crs)\n\n    input_features[\"savedindex\"] = input_features.index\n    intersecting = selecting_features.sjoin(input_features, how=\"inner\")[\"savedindex\"]\n    results = input_features[~input_features.savedindex.isin(intersecting)].drop(\n        columns=[\"savedindex\"], axis=1\n    )\n\n    if output is not None:\n        results.to_file(output, **kwargs)\n    else:\n        return results\n</code></pre>"},{"location":"common/#geojp.common.display_html","title":"<code>display_html(filename, width='100%', height='600px', **kwargs)</code>","text":"<p>Show an HTML file in a Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the HTML file.</p> required <code>width</code> <code>str</code> <p>The width of the HTML file. Defaults to \"100%\".</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the HTML file. Defaults to \"600px\".</p> <code>'600px'</code> <p>Returns:</p> Type Description <code>IFrame</code> <p>An IFrame object.</p> Source code in <code>geojp/common.py</code> <pre><code>def display_html(filename, width=\"100%\", height=\"600px\", **kwargs):\n    \"\"\"Show an HTML file in a Jupyter notebook.\n\n    Args:\n        filename (str): The path to the HTML file.\n        width (str, optional): The width of the HTML file. Defaults to \"100%\".\n        height (str, optional): The height of the HTML file. Defaults to \"600px\".\n\n    Returns:\n        IFrame: An IFrame object.\n    \"\"\"\n\n    from IPython.display import IFrame\n\n    if not os.path.exists(filename):\n        raise Exception(f\"File {filename} does not exist\")\n\n    return IFrame(filename, width=width, height=height, **kwargs)\n</code></pre>"},{"location":"common/#geojp.common.download_file","title":"<code>download_file(url=None, output=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, unzip=True, overwrite=False, subfolder=False)</code>","text":"<p>Download a file from URL, including Google Drive shared URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Google Drive URL is also supported. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>Output filename. Default is basename of URL.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>unzip</code> <code>bool</code> <p>Unzip the file. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <code>subfolder</code> <code>bool</code> <p>Create a subfolder with the same name as the file. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The output file path.</p> Source code in <code>geojp/common.py</code> <pre><code>def download_file(\n    url=None,\n    output=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    unzip=True,\n    overwrite=False,\n    subfolder=False,\n):\n    \"\"\"Download a file from URL, including Google Drive shared URL.\n\n    Args:\n        url (str, optional): Google Drive URL is also supported. Defaults to None.\n        output (str, optional): Output filename. Default is basename of URL.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string,\n            in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        unzip (bool, optional): Unzip the file. Defaults to True.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n        subfolder (bool, optional): Create a subfolder with the same name as the file. Defaults to False.\n\n    Returns:\n        str: The output file path.\n    \"\"\"\n    try:\n        import gdown\n    except ImportError:\n        print(\n            \"The gdown package is required for this function. Use `pip install gdown` to install it.\"\n        )\n        return\n\n    if output is None:\n        if isinstance(url, str) and url.startswith(\"http\"):\n            output = os.path.basename(url)\n\n    out_dir = os.path.abspath(os.path.dirname(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if isinstance(url, str):\n        if os.path.exists(os.path.abspath(output)) and (not overwrite):\n            print(\n                f\"{output} already exists. Skip downloading. Set overwrite=True to overwrite.\"\n            )\n            return os.path.abspath(output)\n        else:\n            url = github_raw_url(url)\n\n    if \"https://drive.google.com/file/d/\" in url:\n        fuzzy = True\n\n    output = gdown.download(\n        url, output, quiet, proxy, speed, use_cookies, verify, id, fuzzy, resume\n    )\n\n    if unzip:\n        if output.endswith(\".zip\"):\n            with zipfile.ZipFile(output, \"r\") as zip_ref:\n                if not quiet:\n                    print(\"Extracting files...\")\n                if subfolder:\n                    basename = os.path.splitext(os.path.basename(output))[0]\n\n                    output = os.path.join(out_dir, basename)\n                    if not os.path.exists(output):\n                        os.makedirs(output)\n                    zip_ref.extractall(output)\n                else:\n                    zip_ref.extractall(os.path.dirname(output))\n        elif output.endswith(\".tar.gz\") or output.endswith(\".tar\"):\n            if output.endswith(\".tar.gz\"):\n                mode = \"r:gz\"\n            else:\n                mode = \"r\"\n\n            with tarfile.open(output, mode) as tar_ref:\n                if not quiet:\n                    print(\"Extracting files...\")\n                if subfolder:\n                    basename = os.path.splitext(os.path.basename(output))[0]\n                    output = os.path.join(out_dir, basename)\n                    if not os.path.exists(output):\n                        os.makedirs(output)\n                    tar_ref.extractall(output)\n                else:\n                    tar_ref.extractall(os.path.dirname(output))\n\n    return os.path.abspath(output)\n</code></pre>"},{"location":"common/#geojp.common.download_file_lite","title":"<code>download_file_lite(url, output=None, binary=False, overwrite=False, **kwargs)</code>  <code>async</code>","text":"<p>Download a file using Pyodide. This function is only available on JupyterLite. Call the function with await, such as await download_file_lite(url).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file.</p> required <code>output</code> <code>str</code> <p>The local path to save the file. Defaults to None.</p> <code>None</code> <code>binary</code> <code>bool</code> <p>Whether the file is binary. Defaults to False.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the file if it exists. Defaults to False.</p> <code>False</code> Source code in <code>geojp/common.py</code> <pre><code>async def download_file_lite(url, output=None, binary=False, overwrite=False, **kwargs):\n    \"\"\"Download a file using Pyodide. This function is only available on JupyterLite. Call the function with await, such as await download_file_lite(url).\n\n    Args:\n        url (str): The URL of the file.\n        output (str, optional): The local path to save the file. Defaults to None.\n        binary (bool, optional): Whether the file is binary. Defaults to False.\n        overwrite (bool, optional): Whether to overwrite the file if it exists. Defaults to False.\n    \"\"\"\n    import sys\n    import pyodide\n\n    if \"pyodide\" not in sys.modules:\n        raise ValueError(\"Pyodide is not available.\")\n\n    if output is None:\n        output = os.path.basename(url)\n\n    output = os.path.abspath(output)\n\n    ext = os.path.splitext(output)[1]\n\n    if ext in [\".png\", \"jpg\", \".tif\", \".tiff\", \"zip\", \"gz\", \"bz2\", \"xz\"]:\n        binary = True\n\n    if os.path.exists(output) and not overwrite:\n        print(f\"{output} already exists, skip downloading.\")\n        return output\n\n    if binary:\n        response = await pyodide.http.pyfetch(url)\n        with open(output, \"wb\") as f:\n            f.write(await response.bytes())\n\n    else:\n        obj = pyodide.http.open_url(url)\n        with open(output, \"w\") as fd:\n            shutil.copyfileobj(obj, fd)\n\n    return output\n</code></pre>"},{"location":"common/#geojp.common.download_files","title":"<code>download_files(urls, out_dir=None, filenames=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, unzip=True, overwrite=False, subfolder=False, multi_part=False)</code>","text":"<p>Download files from URLs, including Google Drive shared URL.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list</code> <p>The list of urls to download. Google Drive URL is also supported.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>filenames</code> <code>list</code> <p>Output filename. Default is basename of URL.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>unzip</code> <code>bool</code> <p>Unzip the file. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <code>subfolder</code> <code>bool</code> <p>Create a subfolder with the same name as the file. Defaults to False.</p> <code>False</code> <code>multi_part</code> <code>bool</code> <p>If the file is a multi-part file. Defaults to False.</p> <code>False</code> <p>Examples:</p> <p>files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"] base_url = \"https://github.com/opengeos/datasets/releases/download/models/\" urls = [base_url + f for f in files] leafmap.download_files(urls, out_dir=\"models\", multi_part=True)</p> Source code in <code>geojp/common.py</code> <pre><code>def download_files(\n    urls,\n    out_dir=None,\n    filenames=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    unzip=True,\n    overwrite=False,\n    subfolder=False,\n    multi_part=False,\n):\n    \"\"\"Download files from URLs, including Google Drive shared URL.\n\n    Args:\n        urls (list): The list of urls to download. Google Drive URL is also supported.\n        out_dir (str, optional): The output directory. Defaults to None.\n        filenames (list, optional): Output filename. Default is basename of URL.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        unzip (bool, optional): Unzip the file. Defaults to True.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n        subfolder (bool, optional): Create a subfolder with the same name as the file. Defaults to False.\n        multi_part (bool, optional): If the file is a multi-part file. Defaults to False.\n\n    Examples:\n\n        files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"]\n        base_url = \"https://github.com/opengeos/datasets/releases/download/models/\"\n        urls = [base_url + f for f in files]\n        leafmap.download_files(urls, out_dir=\"models\", multi_part=True)\n    \"\"\"\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if filenames is None:\n        filenames = [None] * len(urls)\n\n    filepaths = []\n    for url, output in zip(urls, filenames):\n        if output is None:\n            filename = os.path.join(out_dir, os.path.basename(url))\n        else:\n            filename = os.path.join(out_dir, output)\n\n        filepaths.append(filename)\n        if multi_part:\n            unzip = False\n\n        download_file(\n            url,\n            filename,\n            quiet,\n            proxy,\n            speed,\n            use_cookies,\n            verify,\n            id,\n            fuzzy,\n            resume,\n            unzip,\n            overwrite,\n            subfolder,\n        )\n\n    if multi_part:\n        archive = os.path.splitext(filename)[0] + \".zip\"\n        out_dir = os.path.dirname(filename)\n        extract_archive(archive, out_dir)\n\n        for file in filepaths:\n            os.remove(file)\n</code></pre>"},{"location":"common/#geojp.common.download_folder","title":"<code>download_folder(url=None, id=None, output=None, quiet=False, proxy=None, speed=None, use_cookies=True, remaining_ok=False)</code>","text":"<p>Downloads the entire folder from URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the Google Drive folder. Must be of the format 'https://drive.google.com/drive/folders/{url}'. Defaults to None.</p> <code>None</code> <code>id</code> <code>str</code> <p>Google Drive's folder ID. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>String containing the path of the output folder. Defaults to current working directory.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Defaults to False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of files downloaded, or None if failed.</p> Source code in <code>geojp/common.py</code> <pre><code>def download_folder(\n    url=None,\n    id=None,\n    output=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    remaining_ok=False,\n):\n    \"\"\"Downloads the entire folder from URL.\n\n    Args:\n        url (str, optional): URL of the Google Drive folder. Must be of the format 'https://drive.google.com/drive/folders/{url}'. Defaults to None.\n        id (str, optional): Google Drive's folder ID. Defaults to None.\n        output (str, optional):  String containing the path of the output folder. Defaults to current working directory.\n        quiet (bool, optional): Suppress terminal output. Defaults to False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n\n    Returns:\n        list: List of files downloaded, or None if failed.\n    \"\"\"\n\n    try:\n        import gdown\n    except ImportError:\n        print(\n            \"The gdown package is required for this function. Use `pip install gdown` to install it.\"\n        )\n        return\n\n    files = gdown.download_folder(\n        url, id, output, quiet, proxy, speed, use_cookies, remaining_ok\n    )\n    return files\n</code></pre>"},{"location":"common/#geojp.common.download_from_gdrive","title":"<code>download_from_gdrive(gfile_url, file_name, out_dir='.', unzip=True, verbose=True)</code>","text":"<p>Download a file shared via Google Drive    (e.g., https://drive.google.com/file/d/18SUo_HcDGltuWYZs1s7PpOmOq_FvFn04/view?usp=sharing)</p> <p>Parameters:</p> Name Type Description Default <code>gfile_url</code> <code>str</code> <p>The Google Drive shared file URL</p> required <code>file_name</code> <code>str</code> <p>The output file name to use.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to '.'.</p> <code>'.'</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the output file if it is a zip file. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether to display or not the output of the function</p> <code>True</code> Source code in <code>geojp/common.py</code> <pre><code>def download_from_gdrive(gfile_url, file_name, out_dir=\".\", unzip=True, verbose=True):\n    \"\"\"Download a file shared via Google Drive\n       (e.g., https://drive.google.com/file/d/18SUo_HcDGltuWYZs1s7PpOmOq_FvFn04/view?usp=sharing)\n\n    Args:\n        gfile_url (str): The Google Drive shared file URL\n        file_name (str): The output file name to use.\n        out_dir (str, optional): The output directory. Defaults to '.'.\n        unzip (bool, optional): Whether to unzip the output file if it is a zip file. Defaults to True.\n        verbose (bool, optional): Whether to display or not the output of the function\n    \"\"\"\n    try:\n        from google_drive_downloader import GoogleDriveDownloader as gdd\n    except ImportError:\n        raise ImportError(\n            'Please install googledrivedownloader using \"pip install googledrivedownloader\"'\n        )\n\n    file_id = gfile_url.split(\"/\")[5]\n    if verbose:\n        print(\"Google Drive file id: {}\".format(file_id))\n\n    out_dir = check_dir(out_dir)\n    dest_path = os.path.join(out_dir, file_name)\n    gdd.download_file_from_google_drive(file_id, dest_path, True, unzip)\n</code></pre>"},{"location":"common/#geojp.common.download_from_url","title":"<code>download_from_url(url, out_file_name=None, out_dir='.', unzip=True, verbose=True)</code>","text":"<p>Download a file from a URL (e.g., https://github.com/opengeos/whitebox-python/raw/master/examples/testdata.zip)</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The HTTP URL to download.</p> required <code>out_file_name</code> <code>str</code> <p>The output file name to use. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The output directory to use. Defaults to '.'.</p> <code>'.'</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the downloaded file if it is a zip file. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether to display or not the output of the function</p> <code>True</code> Source code in <code>geojp/common.py</code> <pre><code>def download_from_url(\n    url: str,\n    out_file_name: Optional[str] = None,\n    out_dir: Optional[str] = \".\",\n    unzip: Optional[bool] = True,\n    verbose: Optional[bool] = True,\n):\n    \"\"\"Download a file from a URL (e.g., https://github.com/opengeos/whitebox-python/raw/master/examples/testdata.zip)\n\n    Args:\n        url (str): The HTTP URL to download.\n        out_file_name (str, optional): The output file name to use. Defaults to None.\n        out_dir (str, optional): The output directory to use. Defaults to '.'.\n        unzip (bool, optional): Whether to unzip the downloaded file if it is a zip file. Defaults to True.\n        verbose (bool, optional): Whether to display or not the output of the function\n    \"\"\"\n    in_file_name = os.path.basename(url)\n    out_dir = check_dir(out_dir)\n\n    if out_file_name is None:\n        out_file_name = in_file_name\n    out_file_path = os.path.join(out_dir, out_file_name)\n\n    if verbose:\n        print(\"Downloading {} ...\".format(url))\n\n    try:\n        urllib.request.urlretrieve(url, out_file_path)\n    except Exception:\n        raise Exception(\"The URL is invalid. Please double check the URL.\")\n\n    final_path = out_file_path\n\n    if unzip:\n        # if it is a zip file\n        if \".zip\" in out_file_name:\n            if verbose:\n                print(\"Unzipping {} ...\".format(out_file_name))\n            with zipfile.ZipFile(out_file_path, \"r\") as zip_ref:\n                zip_ref.extractall(out_dir)\n            final_path = os.path.join(\n                os.path.abspath(out_dir), out_file_name.replace(\".zip\", \"\")\n            )\n\n        # if it is a tar file\n        if \".tar\" in out_file_name:\n            if verbose:\n                print(\"Unzipping {} ...\".format(out_file_name))\n            with tarfile.open(out_file_path, \"r\") as tar_ref:\n                with tarfile.open(out_file_path, \"r\") as tar_ref:\n\n                    def is_within_directory(directory, target):\n                        abs_directory = os.path.abspath(directory)\n                        abs_target = os.path.abspath(target)\n\n                        prefix = os.path.commonprefix([abs_directory, abs_target])\n\n                        return prefix == abs_directory\n\n                    def safe_extract(\n                        tar, path=\".\", members=None, *, numeric_owner=False\n                    ):\n                        for member in tar.getmembers():\n                            member_path = os.path.join(path, member.name)\n                            if not is_within_directory(path, member_path):\n                                raise Exception(\"Attempted Path Traversal in Tar File\")\n\n                        tar.extractall(path, members, numeric_owner=numeric_owner)\n\n                    safe_extract(tar_ref, out_dir)\n\n            final_path = os.path.join(\n                os.path.abspath(out_dir), out_file_name.replace(\".tart\", \"\")\n            )\n\n    if verbose:\n        print(\"Data downloaded to: {}\".format(final_path))\n</code></pre>"},{"location":"common/#geojp.common.download_google_buildings","title":"<code>download_google_buildings(location, out_dir=None, merge_output=None, head=None, keep_geojson=False, overwrite=False, quiet=False, **kwargs)</code>","text":"<p>Download Google Open Building dataset for a specific location. Check the dataset links from     https://sites.research.google/open-buildings.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>The location name for which to download the dataset.</p> required <code>out_dir</code> <code>Optional[str]</code> <p>The output directory to save the downloaded files. If not provided, the current working directory is used.</p> <code>None</code> <code>merge_output</code> <code>Optional[str]</code> <p>Optional. The output file path for merging the downloaded files into a single GeoDataFrame.</p> <code>None</code> <code>head</code> <code>Optional[int]</code> <p>Optional. The number of files to download. If not provided, all files will be downloaded.</p> <code>None</code> <code>keep_geojson</code> <code>bool</code> <p>Optional. If True, the GeoJSON files will be kept after converting them to CSV files.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Optional. If True, overwrite the existing files.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Optional. If True, suppresses the download progress messages.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>gpd.to_file</code> function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of file paths of the downloaded files.</p> Source code in <code>geojp/common.py</code> <pre><code>def download_google_buildings(\n    location: str,\n    out_dir: Optional[str] = None,\n    merge_output: Optional[str] = None,\n    head: Optional[int] = None,\n    keep_geojson: bool = False,\n    overwrite: bool = False,\n    quiet: bool = False,\n    **kwargs,\n) -&gt; List[str]:\n    \"\"\"\n    Download Google Open Building dataset for a specific location. Check the dataset links from\n        https://sites.research.google/open-buildings.\n\n    Args:\n        location: The location name for which to download the dataset.\n        out_dir: The output directory to save the downloaded files. If not provided, the current working directory is used.\n        merge_output: Optional. The output file path for merging the downloaded files into a single GeoDataFrame.\n        head: Optional. The number of files to download. If not provided, all files will be downloaded.\n        keep_geojson: Optional. If True, the GeoJSON files will be kept after converting them to CSV files.\n        overwrite: Optional. If True, overwrite the existing files.\n        quiet: Optional. If True, suppresses the download progress messages.\n        **kwargs: Additional keyword arguments to be passed to the `gpd.to_file` function.\n\n    Returns:\n        A list of file paths of the downloaded files.\n\n    \"\"\"\n\n    import pandas as pd\n    import geopandas as gpd\n    from shapely import wkt\n\n    building_url = \"https://sites.research.google/open-buildings/tiles.geojson\"\n    country_url = (\n        \"https://naciscdn.org/naturalearth/110m/cultural/ne_110m_admin_0_countries.zip\"\n    )\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    building_gdf = gpd.read_file(building_url)\n    country_gdf = gpd.read_file(country_url)\n\n    country = country_gdf[country_gdf[\"NAME\"] == location]\n\n    if len(country) == 0:\n        country = country_gdf[country_gdf[\"NAME_LONG\"] == location]\n        if len(country) == 0:\n            raise ValueError(f\"Could not find {location} in the Natural Earth dataset.\")\n\n    gdf = building_gdf[building_gdf.intersects(country.geometry.iloc[0])]\n    gdf.sort_values(by=\"size_mb\", inplace=True)\n\n    print(f\"Found {len(gdf)} links for {location}.\")\n    if head is not None:\n        gdf = gdf.head(head)\n\n    if len(gdf) &gt; 0:\n        links = gdf[\"tile_url\"].tolist()\n        download_files(links, out_dir=out_dir, quiet=quiet, **kwargs)\n        filenames = [os.path.join(out_dir, os.path.basename(link)) for link in links]\n\n        gdfs = []\n        for filename in filenames:\n            # Read the CSV file into a pandas DataFrame\n            df = pd.read_csv(filename)\n\n            # Create a geometry column from the \"geometry\" column in the DataFrame\n            df[\"geometry\"] = df[\"geometry\"].apply(wkt.loads)\n\n            # Convert the pandas DataFrame to a GeoDataFrame\n            gdf = gpd.GeoDataFrame(df, geometry=\"geometry\")\n            gdf.crs = \"EPSG:4326\"\n            if keep_geojson:\n                gdf.to_file(\n                    filename.replace(\".csv.gz\", \".geojson\"), driver=\"GeoJSON\", **kwargs\n                )\n            gdfs.append(gdf)\n\n        if merge_output:\n            if os.path.exists(merge_output) and not overwrite:\n                print(f\"File {merge_output} already exists, skip merging...\")\n            else:\n                if not quiet:\n                    print(\"Merging GeoDataFrames ...\")\n                gdf = gpd.GeoDataFrame(\n                    pd.concat(gdfs, ignore_index=True), crs=\"EPSG:4326\"\n                )\n                gdf.to_file(merge_output, **kwargs)\n\n    else:\n        print(f\"No buildings found for {location}.\")\n</code></pre>"},{"location":"common/#geojp.common.download_ms_buildings","title":"<code>download_ms_buildings(location, out_dir=None, merge_output=None, head=None, quiet=False, **kwargs)</code>","text":"<p>Download Microsoft Buildings dataset for a specific location. Check the dataset links from     https://minedbuildings.blob.core.windows.net/global-buildings/dataset-links.csv.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>The location name for which to download the dataset.</p> required <code>out_dir</code> <code>Optional[str]</code> <p>The output directory to save the downloaded files. If not provided, the current working directory is used.</p> <code>None</code> <code>merge_output</code> <code>Optional[str]</code> <p>Optional. The output file path for merging the downloaded files into a single GeoDataFrame.</p> <code>None</code> <code>head</code> <p>Optional. The number of files to download. If not provided, all files will be downloaded.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Optional. If True, suppresses the download progress messages.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>gpd.to_file</code> function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of file paths of the downloaded files.</p> Source code in <code>geojp/common.py</code> <pre><code>def download_ms_buildings(\n    location: str,\n    out_dir: Optional[str] = None,\n    merge_output: Optional[str] = None,\n    head=None,\n    quiet: bool = False,\n    **kwargs,\n) -&gt; List[str]:\n    \"\"\"\n    Download Microsoft Buildings dataset for a specific location. Check the dataset links from\n        https://minedbuildings.blob.core.windows.net/global-buildings/dataset-links.csv.\n\n    Args:\n        location: The location name for which to download the dataset.\n        out_dir: The output directory to save the downloaded files. If not provided, the current working directory is used.\n        merge_output: Optional. The output file path for merging the downloaded files into a single GeoDataFrame.\n        head: Optional. The number of files to download. If not provided, all files will be downloaded.\n        quiet: Optional. If True, suppresses the download progress messages.\n        **kwargs: Additional keyword arguments to be passed to the `gpd.to_file` function.\n\n    Returns:\n        A list of file paths of the downloaded files.\n\n    \"\"\"\n\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import shape\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    dataset_links = pd.read_csv(\n        \"https://minedbuildings.blob.core.windows.net/global-buildings/dataset-links.csv\"\n    )\n    country_links = dataset_links[dataset_links.Location == location]\n\n    if not quiet:\n        print(f\"Found {len(country_links)} links for {location}\")\n    if head is not None:\n        country_links = country_links.head(head)\n\n    filenames = []\n    i = 1\n\n    for _, row in country_links.iterrows():\n        if not quiet:\n            print(f\"Downloading {i} of {len(country_links)}: {row.QuadKey}.geojson\")\n        i += 1\n        filename = os.path.join(out_dir, f\"{row.QuadKey}.geojson\")\n        filenames.append(filename)\n        if os.path.exists(filename):\n            print(f\"File {filename} already exists, skipping...\")\n            continue\n        df = pd.read_json(row.Url, lines=True)\n        df[\"geometry\"] = df[\"geometry\"].apply(shape)\n        gdf = gpd.GeoDataFrame(df, crs=4326)\n        gdf.to_file(filename, driver=\"GeoJSON\", **kwargs)\n\n    if merge_output is not None:\n        if os.path.exists(merge_output):\n            print(f\"File {merge_output} already exists, skip merging...\")\n            return filenames\n        merge_vector(filenames, merge_output, quiet=quiet)\n\n    return filenames\n</code></pre>"},{"location":"common/#geojp.common.download_ned","title":"<code>download_ned(region, out_dir=None, return_url=False, download_args={}, geopandas_args={}, query={})</code>","text":"<p>Download the US National Elevation Datasets (NED) for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>A filepath to a vector dataset or a list of bounds in the form of [minx, miny, maxx, maxy].</p> required <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> <code>None</code> <code>return_url</code> <code>bool</code> <p>Whether to return the download URLs of the files. Defaults to False.</p> <code>False</code> <code>download_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the download_file function. Defaults to {}.</p> <code>{}</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>query</code> <code>dict</code> <p>A dictionary of arguments to pass to the The_national_map_USGS.find_details() function. See https://apps.nationalmap.gov/tnmaccess/#/product for more information.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of the download URLs of the files if return_url is True.</p> Source code in <code>geojp/common.py</code> <pre><code>def download_ned(\n    region,\n    out_dir=None,\n    return_url=False,\n    download_args={},\n    geopandas_args={},\n    query={},\n) -&gt; Union[None, List]:\n    \"\"\"Download the US National Elevation Datasets (NED) for a region.\n\n    Args:\n        region (str | list): A filepath to a vector dataset or a list of bounds in the form of [minx, miny, maxx, maxy].\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        return_url (bool, optional): Whether to return the download URLs of the files. Defaults to False.\n        download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        query (dict, optional): A dictionary of arguments to pass to the The_national_map_USGS.find_details() function.\n            See https://apps.nationalmap.gov/tnmaccess/#/product for more information.\n\n    Returns:\n        list: A list of the download URLs of the files if return_url is True.\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if not query:\n        query = {\n            \"datasets\": \"National Elevation Dataset (NED) 1/3 arc-second\",\n            \"prodFormats\": \"GeoTIFF\",\n        }\n\n    TNM = The_national_map_USGS()\n    if return_url:\n        return TNM.find_tiles(region=region, geopandas_args=geopandas_args, API=query)\n    return TNM.download_tiles(\n        region=region,\n        out_dir=out_dir,\n        download_args=download_args,\n        geopandas_args=geopandas_args,\n        API=query,\n    )\n</code></pre>"},{"location":"common/#geojp.common.download_tnm","title":"<code>download_tnm(region=None, out_dir=None, return_url=False, download_args={}, geopandas_args={}, API={})</code>","text":"<p>Download the US National Elevation Datasets (NED) for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str | list</code> <p>An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy]. Alternatively you could use API parameters such as polygon or bbox.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The directory to download the files to. Defaults to None, which uses the current working directory.</p> <code>None</code> <code>return_url</code> <code>bool</code> <p>Whether to return the download URLs of the files. Defaults to False.</p> <code>False</code> <code>download_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the download_file function. Defaults to {}.</p> <code>{}</code> <code>geopandas_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the geopandas.read_file() function. Used for reading a region URL|filepath.</p> <code>{}</code> <code>API</code> <code>dict</code> <p>A dictionary of arguments to pass to the The_national_map_USGS.find_details() function. Exposes most of the documented API. Defaults to {}</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of the download URLs of the files if return_url is True.</p> Source code in <code>geojp/common.py</code> <pre><code>def download_tnm(\n    region=None,\n    out_dir=None,\n    return_url=False,\n    download_args={},\n    geopandas_args={},\n    API={},\n) -&gt; Union[None, List]:\n    \"\"\"Download the US National Elevation Datasets (NED) for a region.\n\n    Args:\n        region (str | list, optional): An URL|filepath to a vector dataset Or a list of bounds in the form of [minx, miny, maxx, maxy].\n            Alternatively you could use API parameters such as polygon or bbox.\n        out_dir (str, optional): The directory to download the files to. Defaults to None, which uses the current working directory.\n        return_url (bool, optional): Whether to return the download URLs of the files. Defaults to False.\n        download_args (dict, optional): A dictionary of arguments to pass to the download_file function. Defaults to {}.\n        geopandas_args (dict, optional): A dictionary of arguments to pass to the geopandas.read_file() function.\n            Used for reading a region URL|filepath.\n        API (dict, optional): A dictionary of arguments to pass to the The_national_map_USGS.find_details() function.\n            Exposes most of the documented API. Defaults to {}\n\n    Returns:\n        list: A list of the download URLs of the files if return_url is True.\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    TNM = The_national_map_USGS()\n    if return_url:\n        return TNM.find_tiles(region=region, geopandas_args=geopandas_args, API=API)\n    return TNM.download_tiles(\n        region=region,\n        out_dir=out_dir,\n        download_args=download_args,\n        geopandas_args=geopandas_args,\n        API=API,\n    )\n</code></pre>"},{"location":"common/#geojp.common.edit_download_html","title":"<code>edit_download_html(htmlWidget, filename, title='Click here to download: ')</code>","text":"<p>Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058</p> <p>Parameters:</p> Name Type Description Default <code>htmlWidget</code> <code>object</code> <p>The HTML widget to display the URL.</p> required <code>filename</code> <code>str</code> <p>File path to download.</p> required <code>title</code> <code>str</code> <p>Download description. Defaults to \"Click here to download: \".</p> <code>'Click here to download: '</code> Source code in <code>geojp/common.py</code> <pre><code>def edit_download_html(htmlWidget, filename, title=\"Click here to download: \"):\n    \"\"\"Downloads a file from voila. Adopted from https://github.com/voila-dashboards/voila/issues/578#issuecomment-617668058\n\n    Args:\n        htmlWidget (object): The HTML widget to display the URL.\n        filename (str): File path to download.\n        title (str, optional): Download description. Defaults to \"Click here to download: \".\n    \"\"\"\n\n    # from IPython.display import HTML\n    # import ipywidgets as widgets\n    import base64\n\n    # Change widget html temporarily to a font-awesome spinner\n    htmlWidget.value = '&lt;i class=\"fa fa-spinner fa-spin fa-2x fa-fw\"&gt;&lt;/i&gt;&lt;span class=\"sr-only\"&gt;Loading...&lt;/span&gt;'\n\n    # Process raw data\n    data = open(filename, \"rb\").read()\n    b64 = base64.b64encode(data)\n    payload = b64.decode()\n\n    basename = os.path.basename(filename)\n\n    # Create and assign html to widget\n    html = '&lt;a download=\"{filename}\" href=\"data:text/csv;base64,{payload}\" target=\"_blank\"&gt;{title}&lt;/a&gt;'\n    htmlWidget.value = html.format(\n        payload=payload, title=title + basename, filename=basename\n    )\n</code></pre>"},{"location":"common/#geojp.common.explode","title":"<code>explode(coords)</code>","text":"<p>Explode a GeoJSON geometry's coordinates object and yield coordinate tuples. As long as the input is conforming, the type of the geometry doesn't matter.  From Fiona 1.4.8</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>list</code> <p>A list of coordinates.</p> required <p>Yields:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>geojp/common.py</code> <pre><code>def explode(coords):\n    \"\"\"Explode a GeoJSON geometry's coordinates object and yield\n    coordinate tuples. As long as the input is conforming, the type of\n    the geometry doesn't matter.  From Fiona 1.4.8\n\n    Args:\n        coords (list): A list of coordinates.\n\n    Yields:\n        [type]: [description]\n    \"\"\"\n\n    for e in coords:\n        if isinstance(e, (float, int)):\n            yield coords\n            break\n        else:\n            for f in explode(e):\n                yield f\n</code></pre>"},{"location":"common/#geojp.common.extract_archive","title":"<code>extract_archive(archive, outdir=None, **kwargs)</code>","text":"<p>Extracts a multipart archive.</p> <p>This function uses the patoolib library to extract a multipart archive. If the patoolib library is not installed, it attempts to install it. If the archive does not end with \".zip\", it appends \".zip\" to the archive name. If the extraction fails (for example, if the files already exist), it skips the extraction.</p> <p>Parameters:</p> Name Type Description Default <code>archive</code> <code>str</code> <p>The path to the archive file.</p> required <code>outdir</code> <code>str</code> <p>The directory where the archive should be extracted.</p> <code>None</code> <code>**kwargs</code> <p>Arbitrary keyword arguments for the patoolib.extract_archive function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> <p>Exceptions:</p> Type Description <code>Exception</code> <p>An exception is raised if the extraction fails for reasons other than the files already existing.</p> <p>Examples:</p> <p>files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"] base_url = \"https://github.com/opengeos/datasets/releases/download/models/\" urls = [base_url + f for f in files] leafmap.download_files(urls, out_dir=\"models\", multi_part=True)</p> Source code in <code>geojp/common.py</code> <pre><code>def extract_archive(archive, outdir=None, **kwargs):\n    \"\"\"\n    Extracts a multipart archive.\n\n    This function uses the patoolib library to extract a multipart archive.\n    If the patoolib library is not installed, it attempts to install it.\n    If the archive does not end with \".zip\", it appends \".zip\" to the archive name.\n    If the extraction fails (for example, if the files already exist), it skips the extraction.\n\n    Args:\n        archive (str): The path to the archive file.\n        outdir (str): The directory where the archive should be extracted.\n        **kwargs: Arbitrary keyword arguments for the patoolib.extract_archive function.\n\n    Returns:\n        None\n\n    Raises:\n        Exception: An exception is raised if the extraction fails for reasons other than the files already existing.\n\n    Example:\n\n        files = [\"sam_hq_vit_tiny.zip\", \"sam_hq_vit_tiny.z01\", \"sam_hq_vit_tiny.z02\", \"sam_hq_vit_tiny.z03\"]\n        base_url = \"https://github.com/opengeos/datasets/releases/download/models/\"\n        urls = [base_url + f for f in files]\n        leafmap.download_files(urls, out_dir=\"models\", multi_part=True)\n\n    \"\"\"\n    try:\n        import patoolib\n    except ImportError:\n        install_package(\"patool\")\n        import patoolib\n\n    if not archive.endswith(\".zip\"):\n        archive = archive + \".zip\"\n\n    if outdir is None:\n        outdir = os.path.dirname(archive)\n\n    try:\n        patoolib.extract_archive(archive, outdir=outdir, **kwargs)\n    except Exception as e:\n        print(\"The unzipped files might already exist. Skipping extraction.\")\n        return\n</code></pre>"},{"location":"common/#geojp.common.filter_bounds","title":"<code>filter_bounds(data, bbox, within=False, align=True, **kwargs)</code>","text":"<p>Filters a GeoDataFrame or GeoSeries by a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | GeoDataFrame</code> <p>The input data to filter. Can be a file path or a GeoDataFrame.</p> required <code>bbox</code> <code>list | GeoDataFrame</code> <p>The bounding box to filter by. Can be a list of 4 coordinates or a file path or a GeoDataFrame.</p> required <code>within</code> <code>bool</code> <p>Whether to filter by the bounding box or the bounding box's interior. Defaults to False.</p> <code>False</code> <code>align</code> <code>bool</code> <p>If True, automatically aligns GeoSeries based on their indices. If False, the order of elements is preserved.</p> <code>True</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>The filtered data.</p> Source code in <code>geojp/common.py</code> <pre><code>def filter_bounds(data, bbox, within=False, align=True, **kwargs):\n    \"\"\"Filters a GeoDataFrame or GeoSeries by a bounding box.\n\n    Args:\n        data (str | GeoDataFrame): The input data to filter. Can be a file path or a GeoDataFrame.\n        bbox (list | GeoDataFrame): The bounding box to filter by. Can be a list of 4 coordinates or a file path or a GeoDataFrame.\n        within (bool, optional): Whether to filter by the bounding box or the bounding box's interior. Defaults to False.\n        align (bool, optional): If True, automatically aligns GeoSeries based on their indices. If False, the order of elements is preserved.\n\n    Returns:\n        GeoDataFrame: The filtered data.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        data = gpd.read_file(data, **kwargs)\n    elif not isinstance(data, (gpd.GeoDataFrame, gpd.GeoSeries)):\n        raise TypeError(\"data must be a file path or a GeoDataFrame or GeoSeries\")\n\n    if isinstance(bbox, list):\n        if len(bbox) != 4:\n            raise ValueError(\"bbox must be a list of 4 coordinates\")\n        bbox = bbox_to_gdf(bbox)\n    elif isinstance(bbox, str):\n        bbox = gpd.read_file(bbox, **kwargs)\n\n    if within:\n        result = data[data.within(bbox.unary_union, align=align)]\n    else:\n        result = data[data.intersects(bbox.unary_union, align=align)]\n\n    return result\n</code></pre>"},{"location":"common/#geojp.common.filter_date","title":"<code>filter_date(data, start_date=None, end_date=None, date_field='date', date_args={}, **kwargs)</code>","text":"<p>Filters a DataFrame, GeoDataFrame or GeoSeries by a date range.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | DataFrame | GeoDataFrame</code> <p>The input data to filter. Can be a file path or a DataFrame or GeoDataFrame.</p> required <code>start_date</code> <code>str</code> <p>The start date, e.g., 2023-01-01. Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date, e.g., 2023-12-31. Defaults to None.</p> <code>None</code> <code>date_field</code> <code>str</code> <p>The name of the date field. Defaults to \"date\".</p> <code>'date'</code> <code>date_args</code> <code>dict</code> <p>Additional arguments for pd.to_datetime. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The filtered data.</p> Source code in <code>geojp/common.py</code> <pre><code>def filter_date(\n    data, start_date=None, end_date=None, date_field=\"date\", date_args={}, **kwargs\n):\n    \"\"\"Filters a DataFrame, GeoDataFrame or GeoSeries by a date range.\n\n    Args:\n        data (str | DataFrame | GeoDataFrame): The input data to filter. Can be a file path or a DataFrame or GeoDataFrame.\n        start_date (str, optional): The start date, e.g., 2023-01-01. Defaults to None.\n        end_date (str, optional): The end date, e.g., 2023-12-31. Defaults to None.\n        date_field (str, optional): The name of the date field. Defaults to \"date\".\n        date_args (dict, optional): Additional arguments for pd.to_datetime. Defaults to {}.\n\n    Returns:\n        DataFrame: The filtered data.\n    \"\"\"\n\n    import datetime\n    import pandas as pd\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        data = gpd.read_file(data, **kwargs)\n    elif not isinstance(\n        data, (gpd.GeoDataFrame, gpd.GeoSeries, pd.DataFrame, pd.Series)\n    ):\n        raise TypeError(\"data must be a file path or a GeoDataFrame or GeoSeries\")\n\n    if date_field not in data.columns:\n        raise ValueError(f\"date_field must be one of {data.columns}\")\n\n    new_field = f\"{date_field}_temp\"\n    data[new_field] = pd.to_datetime(data[date_field], **date_args)\n\n    if end_date is None:\n        end_date = datetime.datetime.now().strftime(\"%Y-%m-%d\")\n\n    if start_date is None:\n        start_date = data[new_field].min()\n\n    mask = (data[new_field] &gt;= start_date) &amp; (data[new_field] &lt;= end_date)\n    result = data.loc[mask]\n    return result.drop(columns=[new_field], axis=1)\n</code></pre>"},{"location":"common/#geojp.common.find_files","title":"<code>find_files(input_dir, ext=None, fullpath=True, recursive=True)</code>","text":"<p>Find files in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>The input directory.</p> required <code>ext</code> <code>str</code> <p>The file extension to match. Defaults to None.</p> <code>None</code> <code>fullpath</code> <code>bool</code> <p>Whether to return the full path. Defaults to True.</p> <code>True</code> <code>recursive</code> <code>bool</code> <p>Whether to search recursively. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of matching files.</p> Source code in <code>geojp/common.py</code> <pre><code>def find_files(input_dir, ext=None, fullpath=True, recursive=True):\n    \"\"\"Find files in a directory.\n\n    Args:\n        input_dir (str): The input directory.\n        ext (str, optional): The file extension to match. Defaults to None.\n        fullpath (bool, optional): Whether to return the full path. Defaults to True.\n        recursive (bool, optional): Whether to search recursively. Defaults to True.\n\n    Returns:\n        list: A list of matching files.\n    \"\"\"\n\n    from pathlib import Path\n\n    files = []\n\n    if ext is None:\n        ext = \"*\"\n    else:\n        ext = ext.replace(\".\", \"\")\n\n    ext = f\"*.{ext}\"\n\n    if recursive:\n        if fullpath:\n            files = [str(path.joinpath()) for path in Path(input_dir).rglob(ext)]\n        else:\n            files = [str(path.name) for path in Path(input_dir).rglob(ext)]\n    else:\n        if fullpath:\n            files = [str(path.joinpath()) for path in Path(input_dir).glob(ext)]\n        else:\n            files = [path.name for path in Path(input_dir).glob(ext)]\n\n    files.sort()\n    return files\n</code></pre>"},{"location":"common/#geojp.common.gdb_layer_names","title":"<code>gdb_layer_names(gdb_path)</code>","text":"<p>Get a list of layer names in a File Geodatabase (GDB).</p> <p>Parameters:</p> Name Type Description Default <code>gdb_path</code> <code>str</code> <p>The path to the File Geodatabase (GDB).</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of layer names in the GDB.</p> Source code in <code>geojp/common.py</code> <pre><code>def gdb_layer_names(gdb_path: str) -&gt; List[str]:\n    \"\"\"Get a list of layer names in a File Geodatabase (GDB).\n\n    Args:\n        gdb_path (str): The path to the File Geodatabase (GDB).\n\n    Returns:\n        List[str]: A list of layer names in the GDB.\n    \"\"\"\n\n    from osgeo import ogr\n\n    # Open the GDB\n    gdb_driver = ogr.GetDriverByName(\"OpenFileGDB\")\n    gdb_dataset = gdb_driver.Open(gdb_path, 0)\n\n    # Get the number of layers in the GDB\n    layer_count = gdb_dataset.GetLayerCount()\n    # Iterate over the layers\n    layer_names = []\n    for i in range(layer_count):\n        layer = gdb_dataset.GetLayerByIndex(i)\n        feature_class_name = layer.GetName()\n        layer_names.append(feature_class_name)\n\n    # Close the GDB dataset\n    gdb_dataset = None\n    return layer_names\n</code></pre>"},{"location":"common/#geojp.common.gdb_to_vector","title":"<code>gdb_to_vector(gdb_path, out_dir, layers=None, filenames=None, gdal_driver='GPKG', file_extension=None, overwrite=False, quiet=False, **kwargs)</code>","text":"<p>Converts layers from a File Geodatabase (GDB) to a vector format.</p> <p>Parameters:</p> Name Type Description Default <code>gdb_path</code> <code>str</code> <p>The path to the File Geodatabase (GDB).</p> required <code>out_dir</code> <code>str</code> <p>The output directory to save the converted files.</p> required <code>layers</code> <code>Optional[List[str]]</code> <p>A list of layer names to convert. If None, all layers will be converted. Default is None.</p> <code>None</code> <code>filenames</code> <code>Optional[List[str]]</code> <p>A list of output file names. If None, the layer names will be used as the file names. Default is None.</p> <code>None</code> <code>gdal_driver</code> <code>str</code> <p>The GDAL driver name for the output vector format. Default is \"GPKG\".</p> <code>'GPKG'</code> <code>file_extension</code> <code>Optional[str]</code> <p>The file extension for the output files. If None, it will be determined automatically based on the gdal_driver. Default is None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing output files. Default is False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>geojp/common.py</code> <pre><code>def gdb_to_vector(\n    gdb_path: str,\n    out_dir: str,\n    layers: Optional[List[str]] = None,\n    filenames: Optional[List[str]] = None,\n    gdal_driver: str = \"GPKG\",\n    file_extension: Optional[str] = None,\n    overwrite: bool = False,\n    quiet=False,\n    **kwargs,\n):\n    \"\"\"Converts layers from a File Geodatabase (GDB) to a vector format.\n\n    Args:\n        gdb_path (str): The path to the File Geodatabase (GDB).\n        out_dir (str): The output directory to save the converted files.\n        layers (Optional[List[str]]): A list of layer names to convert. If None, all layers will be converted. Default is None.\n        filenames (Optional[List[str]]): A list of output file names. If None, the layer names will be used as the file names. Default is None.\n        gdal_driver (str): The GDAL driver name for the output vector format. Default is \"GPKG\".\n        file_extension (Optional[str]): The file extension for the output files. If None, it will be determined automatically based on the gdal_driver. Default is None.\n        overwrite (bool): Whether to overwrite the existing output files. Default is False.\n        quiet (bool): If True, suppress the log output. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    from osgeo import ogr\n\n    # Open the GDB\n    gdb_driver = ogr.GetDriverByName(\"OpenFileGDB\")\n    gdb_dataset = gdb_driver.Open(gdb_path, 0)\n\n    # Get the number of layers in the GDB\n    layer_count = gdb_dataset.GetLayerCount()\n\n    if isinstance(layers, str):\n        layers = [layers]\n\n    if isinstance(filenames, str):\n        filenames = [filenames]\n\n    if filenames is not None:\n        if len(filenames) != len(layers):\n            raise ValueError(\"The length of filenames must match the length of layers.\")\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    ii = 0\n    # Iterate over the layers\n    for i in range(layer_count):\n        layer = gdb_dataset.GetLayerByIndex(i)\n        feature_class_name = layer.GetName()\n\n        if layers is not None:\n            if feature_class_name not in layers:\n                continue\n\n        if file_extension is None:\n            file_extension = get_gdal_file_extension(gdal_driver)\n\n        # Create the output file path\n        if filenames is not None:\n            output_file = os.path.join(out_dir, filenames[ii] + \".\" + file_extension)\n            ii += 1\n        else:\n            output_file = os.path.join(\n                out_dir, feature_class_name + \".\" + file_extension\n            )\n\n        if os.path.exists(output_file) and not overwrite:\n            print(f\"File {output_file} already exists. Skipping...\")\n            continue\n        else:\n            if not quiet:\n                print(f\"Converting layer {feature_class_name} to {output_file}...\")\n\n        # Create the output driver\n        output_driver = ogr.GetDriverByName(gdal_driver)\n        output_dataset = output_driver.CreateDataSource(output_file)\n\n        # Copy the input layer to the output format\n        output_dataset.CopyLayer(layer, feature_class_name)\n\n        output_dataset = None\n\n    # Close the GDB dataset\n    gdb_dataset = None\n</code></pre>"},{"location":"common/#geojp.common.gdf_bounds","title":"<code>gdf_bounds(gdf, return_geom=False)</code>","text":"<p>Returns the bounding box of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>return_geom</code> <code>bool</code> <p>Whether to return the bounding box as a GeoDataFrame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list | gpd.GeoDataFrame</code> <p>A bounding box in the form of a list (minx, miny, maxx, maxy) or GeoDataFrame.</p> Source code in <code>geojp/common.py</code> <pre><code>def gdf_bounds(gdf, return_geom=False):\n    \"\"\"Returns the bounding box of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        return_geom (bool, optional): Whether to return the bounding box as a GeoDataFrame. Defaults to False.\n\n    Returns:\n        list | gpd.GeoDataFrame: A bounding box in the form of a list (minx, miny, maxx, maxy) or GeoDataFrame.\n    \"\"\"\n    bounds = gdf.total_bounds\n    if return_geom:\n        return bbox_to_gdf(bbox=bounds)\n    else:\n        return bounds\n</code></pre>"},{"location":"common/#geojp.common.gdf_centroid","title":"<code>gdf_centroid(gdf, return_geom=False)</code>","text":"<p>Returns the centroid of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>return_geom</code> <code>bool</code> <p>Whether to return the bounding box as a GeoDataFrame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list | gpd.GeoDataFrame</code> <p>A bounding box in the form of a list (lon, lat) or GeoDataFrame.</p> Source code in <code>geojp/common.py</code> <pre><code>def gdf_centroid(gdf, return_geom=False):\n    \"\"\"Returns the centroid of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        return_geom (bool, optional): Whether to return the bounding box as a GeoDataFrame. Defaults to False.\n\n    Returns:\n        list | gpd.GeoDataFrame: A bounding box in the form of a list (lon, lat) or GeoDataFrame.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    centroid = gdf_bounds(gdf, return_geom=True).centroid\n    if return_geom:\n        return centroid\n    else:\n        return centroid.x[0], centroid.y[0]\n</code></pre>"},{"location":"common/#geojp.common.gdf_geom_type","title":"<code>gdf_geom_type(gdf, first_only=True)</code>","text":"<p>Returns the geometry type of a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>first_only</code> <code>bool</code> <p>Whether to return the geometry type of the first feature in the GeoDataFrame. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The geometry type of the GeoDataFrame, such as Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon.     For more info, see https://shapely.readthedocs.io/en/stable/manual.html</p> Source code in <code>geojp/common.py</code> <pre><code>def gdf_geom_type(gdf, first_only=True):\n    \"\"\"Returns the geometry type of a GeoDataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        first_only (bool, optional): Whether to return the geometry type of the first feature in the GeoDataFrame. Defaults to True.\n\n    Returns:\n        str: The geometry type of the GeoDataFrame, such as Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon.\n            For more info, see https://shapely.readthedocs.io/en/stable/manual.html\n    \"\"\"\n    import geopandas as gpd\n\n    if first_only:\n        return gdf.geometry.type[0]\n    else:\n        return gdf.geometry.type\n</code></pre>"},{"location":"common/#geojp.common.gdf_to_bokeh","title":"<code>gdf_to_bokeh(gdf)</code>","text":"<p>Function to convert a GeoPandas GeoDataFrame to a Bokeh ColumnDataSource object.</p> <p>:param: (GeoDataFrame) gdf: GeoPandas GeoDataFrame with polygon(s) under                             the column name 'geometry.'</p> <p>:return: ColumnDataSource for Bokeh.</p> Source code in <code>geojp/common.py</code> <pre><code>def gdf_to_bokeh(gdf):\n    \"\"\"\n    Function to convert a GeoPandas GeoDataFrame to a Bokeh\n    ColumnDataSource object.\n\n    :param: (GeoDataFrame) gdf: GeoPandas GeoDataFrame with polygon(s) under\n                                the column name 'geometry.'\n\n    :return: ColumnDataSource for Bokeh.\n    \"\"\"\n    from bokeh.plotting import ColumnDataSource\n\n    shape_type = gdf_geom_type(gdf)\n\n    gdf_new = gdf.drop(\"geometry\", axis=1).copy()\n    gdf_new[\"x\"] = gdf.apply(\n        get_geometry_coords,\n        geom=\"geometry\",\n        coord_type=\"x\",\n        shape_type=shape_type,\n        mercator=True,\n        axis=1,\n    )\n\n    gdf_new[\"y\"] = gdf.apply(\n        get_geometry_coords,\n        geom=\"geometry\",\n        coord_type=\"y\",\n        shape_type=shape_type,\n        mercator=True,\n        axis=1,\n    )\n\n    return ColumnDataSource(gdf_new)\n</code></pre>"},{"location":"common/#geojp.common.gdf_to_df","title":"<code>gdf_to_df(gdf, drop_geom=True)</code>","text":"<p>Converts a GeoDataFrame to a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame.</p> required <code>drop_geom</code> <code>bool</code> <p>Whether to drop the geometry column. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A pandas DataFrame containing the GeoDataFrame.</p> Source code in <code>geojp/common.py</code> <pre><code>def gdf_to_df(gdf, drop_geom=True):\n    \"\"\"Converts a GeoDataFrame to a pandas DataFrame.\n\n    Args:\n        gdf (gpd.GeoDataFrame): A GeoDataFrame.\n        drop_geom (bool, optional): Whether to drop the geometry column. Defaults to True.\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame containing the GeoDataFrame.\n    \"\"\"\n    import pandas as pd\n\n    if drop_geom:\n        df = pd.DataFrame(gdf.drop(columns=[\"geometry\"]))\n    else:\n        df = pd.DataFrame(gdf)\n\n    return df\n</code></pre>"},{"location":"common/#geojp.common.gdf_to_geojson","title":"<code>gdf_to_geojson(gdf, out_geojson=None, epsg=None, tuple_to_list=False, encoding='utf-8')</code>","text":"<p>Converts a GeoDataFame to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoPandas GeoDataFrame.</p> required <code>out_geojson</code> <code>str</code> <p>File path to he output GeoJSON. Defaults to None.</p> <code>None</code> <code>epsg</code> <code>str</code> <p>An EPSG string, e.g., \"4326\". Defaults to None.</p> <code>None</code> <code>tuple_to_list</code> <code>bool</code> <p>Whether to convert tuples to lists. Defaults to False.</p> <code>False</code> <code>encoding</code> <code>str</code> <p>The encoding to use for the GeoJSON. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>When the output file extension is incorrect.</p> <code>Exception</code> <p>When the conversion fails.</p> <p>Returns:</p> Type Description <code>dict</code> <p>When the out_json is None returns a dict.</p> Source code in <code>geojp/common.py</code> <pre><code>def gdf_to_geojson(\n    gdf, out_geojson=None, epsg=None, tuple_to_list=False, encoding=\"utf-8\"\n):\n    \"\"\"Converts a GeoDataFame to GeoJSON.\n\n    Args:\n        gdf (GeoDataFrame): A GeoPandas GeoDataFrame.\n        out_geojson (str, optional): File path to he output GeoJSON. Defaults to None.\n        epsg (str, optional): An EPSG string, e.g., \"4326\". Defaults to None.\n        tuple_to_list (bool, optional): Whether to convert tuples to lists. Defaults to False.\n        encoding (str, optional): The encoding to use for the GeoJSON. Defaults to \"utf-8\".\n\n    Raises:\n        TypeError: When the output file extension is incorrect.\n        Exception: When the conversion fails.\n\n    Returns:\n        dict: When the out_json is None returns a dict.\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    def listit(t):\n        return list(map(listit, t)) if isinstance(t, (list, tuple)) else t\n\n    try:\n        if epsg is not None:\n            if gdf.crs is not None and gdf.crs.to_epsg() != epsg:\n                gdf = gdf.to_crs(epsg=epsg)\n        geojson = gdf.__geo_interface__\n\n        if tuple_to_list:\n            for feature in geojson[\"features\"]:\n                feature[\"geometry\"][\"coordinates\"] = listit(\n                    feature[\"geometry\"][\"coordinates\"]\n                )\n\n        if out_geojson is None:\n            return geojson\n        else:\n            ext = os.path.splitext(out_geojson)[1]\n            if ext.lower() not in [\".json\", \".geojson\"]:\n                raise TypeError(\n                    \"The output file extension must be either .json or .geojson\"\n                )\n            out_dir = os.path.dirname(out_geojson)\n            if not os.path.exists(out_dir):\n                os.makedirs(out_dir)\n\n            gdf.to_file(out_geojson, driver=\"GeoJSON\", encoding=encoding)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.gedi_download_file","title":"<code>gedi_download_file(url, filename=None, username=None, password=None)</code>","text":"<p>Downloads a file from the given URL and saves it to the specified filename. If no filename is provided, the name of the file from the URL will be used.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file to download. e.g., https://daac.ornl.gov/daacdata/gedi/GEDI_L4A_AGB_Density_V2_1/data/GEDI04_A_2019298202754_O04921_01_T02899_02_002_02_V002.h5</p> required <code>filename</code> <code>str</code> <p>The name of the file to save the downloaded content to. Defaults to None.</p> <code>None</code> <code>username</code> <code>str</code> <p>Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None. Create an account at https://urs.earthdata.nasa.gov</p> <code>None</code> <code>password</code> <code>str</code> <p>Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>geojp/common.py</code> <pre><code>def gedi_download_file(\n    url: str, filename: str = None, username: str = None, password: str = None\n) -&gt; None:\n    \"\"\"\n    Downloads a file from the given URL and saves it to the specified filename.\n    If no filename is provided, the name of the file from the URL will be used.\n\n    Args:\n        url (str): The URL of the file to download.\n            e.g., https://daac.ornl.gov/daacdata/gedi/GEDI_L4A_AGB_Density_V2_1/data/GEDI04_A_2019298202754_O04921_01_T02899_02_002_02_V002.h5\n        filename (str, optional): The name of the file to save the downloaded content to. Defaults to None.\n        username (str, optional): Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None.\n            Create an account at https://urs.earthdata.nasa.gov\n        password (str, optional): Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    import requests\n    from tqdm import tqdm\n    from urllib.parse import urlparse\n\n    if username is None:\n        username = os.environ.get(\"EARTHDATA_USERNAME\", None)\n    if password is None:\n        password = os.environ.get(\"EARTHDATA_PASSWORD\", None)\n\n    if username is None or password is None:\n        raise ValueError(\n            \"Username and password must be provided. Create an account at https://urs.earthdata.nasa.gov.\"\n        )\n\n    with requests.Session() as session:\n        r1 = session.request(\"get\", url, stream=True)\n        r = session.get(r1.url, auth=(username, password), stream=True)\n        print(r.status_code)\n\n        if r.status_code == 200:\n            total_size = int(r.headers.get(\"content-length\", 0))\n            block_size = 1024  # 1 KB\n\n            # Use the filename from the URL if not provided\n            if not filename:\n                parsed_url = urlparse(url)\n                filename = parsed_url.path.split(\"/\")[-1]\n\n            progress_bar = tqdm(total=total_size, unit=\"B\", unit_scale=True)\n\n            with open(filename, \"wb\") as file:\n                for data in r.iter_content(block_size):\n                    progress_bar.update(len(data))\n                    file.write(data)\n\n            progress_bar.close()\n</code></pre>"},{"location":"common/#geojp.common.gedi_download_files","title":"<code>gedi_download_files(urls, outdir=None, filenames=None, username=None, password=None, overwrite=False)</code>","text":"<p>Downloads files from the given URLs and saves them to the specified directory. If no directory is provided, the current directory will be used. If no filenames are provided, the names of the files from the URLs will be used.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>List[str]</code> <p>The URLs of the files to download. e.g., [\"https://example.com/file1.txt\", \"https://example.com/file2.txt\"]</p> required <code>outdir</code> <code>str</code> <p>The directory to save the downloaded files to. Defaults to None.</p> <code>None</code> <code>filenames</code> <code>str</code> <p>The names of the files to save the downloaded content to. Defaults to None.</p> <code>None</code> <code>username</code> <code>str</code> <p>Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None. Create an account at https://urs.earthdata.nasa.gov</p> <code>None</code> <code>password</code> <code>str</code> <p>Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing output files. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>geojp/common.py</code> <pre><code>def gedi_download_files(\n    urls: List[str],\n    outdir: str = None,\n    filenames: str = None,\n    username: str = None,\n    password: str = None,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Downloads files from the given URLs and saves them to the specified directory.\n    If no directory is provided, the current directory will be used.\n    If no filenames are provided, the names of the files from the URLs will be used.\n\n    Args:\n        urls (List[str]): The URLs of the files to download.\n            e.g., [\"https://example.com/file1.txt\", \"https://example.com/file2.txt\"]\n        outdir (str, optional): The directory to save the downloaded files to. Defaults to None.\n        filenames (str, optional): The names of the files to save the downloaded content to. Defaults to None.\n        username (str, optional): Username for authentication. Can also be set using the EARTHDATA_USERNAME environment variable. Defaults to None.\n            Create an account at https://urs.earthdata.nasa.gov\n        password (str, optional): Password for authentication. Can also be set using the EARTHDATA_PASSWORD environment variable. Defaults to None.\n        overwrite (bool): Whether to overwrite the existing output files. Default is False.\n\n    Returns:\n        None\n    \"\"\"\n\n    import requests\n    from tqdm import tqdm\n    from urllib.parse import urlparse\n    import geopandas as gpd\n\n    if isinstance(urls, gpd.GeoDataFrame):\n        urls = urls[\"granule_url\"].tolist()\n\n    session = requests.Session()\n\n    if username is None:\n        username = os.environ.get(\"EARTHDATA_USERNAME\", None)\n    if password is None:\n        password = os.environ.get(\"EARTHDATA_PASSWORD\", None)\n\n    if username is None or password is None:\n        print(\"Username and password must be provided.\")\n        return\n\n    if outdir is None:\n        outdir = os.getcwd()\n\n    if not os.path.exists(outdir):\n        os.makedirs(outdir)\n\n    for index, url in enumerate(urls):\n        print(f\"Downloading file {index+1} of {len(urls)}...\")\n\n        if url is None:\n            continue\n\n        # Use the filename from the URL if not provided\n        if not filenames:\n            parsed_url = urlparse(url)\n            filename = parsed_url.path.split(\"/\")[-1]\n        else:\n            filename = filenames.pop(0)\n\n        filepath = os.path.join(outdir, filename)\n        if os.path.exists(filepath) and not overwrite:\n            print(f\"File {filepath} already exists. Skipping...\")\n            continue\n\n        r1 = session.request(\"get\", url, stream=True)\n        r = session.get(r1.url, auth=(username, password), stream=True)\n\n        if r.status_code == 200:\n            total_size = int(r.headers.get(\"content-length\", 0))\n            block_size = 1024  # 1 KB\n\n            progress_bar = tqdm(total=total_size, unit=\"B\", unit_scale=True)\n\n            with open(filepath, \"wb\") as file:\n                for data in r.iter_content(block_size):\n                    progress_bar.update(len(data))\n                    file.write(data)\n\n            progress_bar.close()\n\n    session.close()\n</code></pre>"},{"location":"common/#geojp.common.gedi_search","title":"<code>gedi_search(roi, start_date=None, end_date=None, add_roi=False, return_type='gdf', output=None, sort_filesize=False, **kwargs)</code>","text":"<p>Searches for GEDI data using the Common Metadata Repository (CMR) API. The source code for this function is adapted from https://github.com/ornldaac/gedi_tutorials. Credits to ORNL DAAC and Rupesh Shrestha.</p> <p>Parameters:</p> Name Type Description Default <code>roi</code> <p>A list, tuple, or file path representing the bounding box coordinates in the format (min_lon, min_lat, max_lon, max_lat), or a GeoDataFrame containing the region of interest geometry.</p> required <code>start_date</code> <code>Optional[str]</code> <p>The start date of the temporal range to search for data in the format 'YYYY-MM-DD'.</p> <code>None</code> <code>end_date</code> <code>Optional[str]</code> <p>The end date of the temporal range to search for data in the format 'YYYY-MM-DD'.</p> <code>None</code> <code>add_roi</code> <code>bool</code> <p>A boolean value indicating whether to include the region of interest as a granule in the search results. Default is False.</p> <code>False</code> <code>return_type</code> <code>str</code> <p>The type of the search results to return. Must be one of 'df' (DataFrame), 'gdf' (GeoDataFrame), or 'csv' (CSV file). Default is 'gdf'.</p> <code>'gdf'</code> <code>output</code> <code>Optional[str]</code> <p>The file path to save the CSV output when return_type is 'csv'. Optional and only applicable when return_type is 'csv'.</p> <code>None</code> <code>sort_filesize</code> <code>bool</code> <p>A boolean value indicating whether to sort the search results.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the CMR API.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The search results as a pandas DataFrame (return_type='df'), geopandas GeoDataFrame (return_type='gdf'), or a CSV file (return_type='csv').</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If roi is not a list, tuple, or file path.</p> Source code in <code>geojp/common.py</code> <pre><code>def gedi_search(\n    roi,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    add_roi: bool = False,\n    return_type: str = \"gdf\",\n    output: Optional[str] = None,\n    sort_filesize: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Searches for GEDI data using the Common Metadata Repository (CMR) API.\n    The source code for this function is adapted from https://github.com/ornldaac/gedi_tutorials.\n    Credits to ORNL DAAC and Rupesh Shrestha.\n\n    Args:\n        roi: A list, tuple, or file path representing the bounding box coordinates\n            in the format (min_lon, min_lat, max_lon, max_lat), or a GeoDataFrame\n            containing the region of interest geometry.\n        start_date: The start date of the temporal range to search for data\n            in the format 'YYYY-MM-DD'.\n        end_date: The end date of the temporal range to search for data\n            in the format 'YYYY-MM-DD'.\n        add_roi: A boolean value indicating whether to include the region of interest\n            as a granule in the search results. Default is False.\n        return_type: The type of the search results to return. Must be one of 'df'\n            (DataFrame), 'gdf' (GeoDataFrame), or 'csv' (CSV file). Default is 'gdf'.\n        output: The file path to save the CSV output when return_type is 'csv'.\n            Optional and only applicable when return_type is 'csv'.\n        sort_filesize: A boolean value indicating whether to sort the search results.\n        **kwargs: Additional keyword arguments to be passed to the CMR API.\n\n    Returns:\n        The search results as a pandas DataFrame (return_type='df'), geopandas GeoDataFrame\n        (return_type='gdf'), or a CSV file (return_type='csv').\n\n    Raises:\n        ValueError: If roi is not a list, tuple, or file path.\n\n    \"\"\"\n\n    import requests\n    import datetime as dt\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import MultiPolygon, Polygon, box\n    from shapely.ops import orient\n\n    # CMR API base url\n    cmrurl = \"https://cmr.earthdata.nasa.gov/search/\"\n\n    doi = \"10.3334/ORNLDAAC/2056\"  # GEDI L4A DOI\n\n    # Construct the DOI search URL\n    doisearch = cmrurl + \"collections.json?doi=\" + doi\n\n    # Send a request to the CMR API to get the concept ID\n    response = requests.get(doisearch)\n    response.raise_for_status()\n    concept_id = response.json()[\"feed\"][\"entry\"][0][\"id\"]\n\n    # CMR formatted start and end times\n    if start_date is not None and end_date is not None:\n        dt_format = \"%Y-%m-%dT%H:%M:%SZ\"\n        start_date = dt.datetime.strptime(start_date, \"%Y-%m-%d\")\n        end_date = dt.datetime.strptime(end_date, \"%Y-%m-%d\")\n        temporal_str = (\n            start_date.strftime(dt_format) + \",\" + end_date.strftime(dt_format)\n        )\n    else:\n        temporal_str = None\n\n    # CMR formatted bounding box\n    if isinstance(roi, list) or isinstance(roi, tuple):\n        bound_str = \",\".join(map(str, roi))\n    elif isinstance(roi, str):\n        roi = gpd.read_file(roi)\n        roi.geometry = roi.geometry.apply(orient, args=(1,))  # make counter-clockwise\n    elif isinstance(roi, gpd.GeoDataFrame):\n        roi.geometry = roi.geometry.apply(orient, args=(1,))  # make counter-clockwise\n    else:\n        raise ValueError(\"roi must be a list, tuple, or a file path.\")\n\n    page_num = 1\n    page_size = 2000  # CMR page size limit\n\n    granule_arr = []\n\n    while True:\n        # Define CMR search parameters\n        cmr_param = {\n            \"collection_concept_id\": concept_id,\n            \"page_size\": page_size,\n            \"page_num\": page_num,\n        }\n\n        if temporal_str is not None:\n            cmr_param[\"temporal\"] = temporal_str\n\n        if kwargs:\n            cmr_param.update(kwargs)\n\n        granulesearch = cmrurl + \"granules.json\"\n\n        if isinstance(roi, list) or isinstance(roi, tuple):\n            cmr_param[\"bounding_box[]\"] = bound_str\n            response = requests.get(granulesearch, params=cmr_param)\n            response.raise_for_status()\n        else:\n            cmr_param[\"simplify-shapefile\"] = \"true\"\n            geojson = {\n                \"shapefile\": (\n                    \"region.geojson\",\n                    roi.geometry.to_json(),\n                    \"application/geo+json\",\n                )\n            }\n            response = requests.post(granulesearch, data=cmr_param, files=geojson)\n\n        # Send a request to the CMR API to get the granules\n        granules = response.json()[\"feed\"][\"entry\"]\n\n        if granules:\n            for index, g in enumerate(granules):\n                granule_url = \"\"\n                granule_poly = \"\"\n\n                # Read file size\n                granule_size = float(g[\"granule_size\"])\n\n                # Read bounding geometries\n                if \"polygons\" in g:\n                    polygons = g[\"polygons\"]\n                    multipolygons = []\n                    for poly in polygons:\n                        i = iter(poly[0].split(\" \"))\n                        ltln = list(map(\" \".join, zip(i, i)))\n                        multipolygons.append(\n                            Polygon(\n                                [\n                                    [float(p.split(\" \")[1]), float(p.split(\" \")[0])]\n                                    for p in ltln\n                                ]\n                            )\n                        )\n                    granule_poly = MultiPolygon(multipolygons)\n\n                # Get URL to HDF5 files\n                for links in g[\"links\"]:\n                    if (\n                        \"title\" in links\n                        and links[\"title\"].startswith(\"Download\")\n                        and links[\"title\"].endswith(\".h5\")\n                    ):\n                        granule_url = links[\"href\"]\n\n                granule_id = g[\"id\"]\n                title = g[\"title\"]\n                time_start = g[\"time_start\"]\n                time_end = g[\"time_end\"]\n\n                granule_arr.append(\n                    [\n                        granule_id,\n                        title,\n                        time_start,\n                        time_end,\n                        granule_size,\n                        granule_url,\n                        granule_poly,\n                    ]\n                )\n\n            page_num += 1\n        else:\n            break\n\n    # Add bound as the last row into the dataframe\n    if add_roi:\n        if isinstance(roi, list) or isinstance(roi, tuple):\n            b = list(roi)\n            granule_arr.append(\n                [\"roi\", None, None, None, 0, None, box(b[0], b[1], b[2], b[3])]\n            )\n        else:\n            granule_arr.append([\"roi\", None, None, None, 0, None, roi.geometry.item()])\n\n    # Create a pandas dataframe\n    columns = [\n        \"id\",\n        \"title\",\n        \"time_start\",\n        \"time_end\",\n        \"granule_size\",\n        \"granule_url\",\n        \"granule_poly\",\n    ]\n    l4adf = pd.DataFrame(granule_arr, columns=columns)\n\n    # Drop granules with empty geometry\n    l4adf = l4adf[l4adf[\"granule_poly\"] != \"\"]\n\n    if sort_filesize:\n        l4adf = l4adf.sort_values(by=[\"granule_size\"], ascending=True)\n\n    if return_type == \"df\":\n        return l4adf\n    elif return_type == \"gdf\":\n        gdf = gpd.GeoDataFrame(l4adf, geometry=\"granule_poly\")\n        gdf.crs = \"EPSG:4326\"\n        return gdf\n    elif return_type == \"csv\":\n        columns.remove(\"granule_poly\")\n        return l4adf.to_csv(output, index=False, columns=columns)\n    else:\n        raise ValueError(\"return_type must be one of 'df', 'gdf', or 'csv'.\")\n</code></pre>"},{"location":"common/#geojp.common.gedi_subset","title":"<code>gedi_subset(spatial=None, start_date=None, end_date=None, out_dir=None, collection=None, variables=['all'], max_results=None, username=None, password=None, overwrite=False, **kwargs)</code>","text":"<p>Subsets GEDI data using the Harmony API.</p> <p>Parameters:</p> Name Type Description Default <code>spatial</code> <code>Union[str, gpd.GeoDataFrame, List[float]]</code> <p>Spatial extent for subsetting. Can be a file path to a shapefile, a GeoDataFrame, or a list of bounding box coordinates [minx, miny, maxx, maxy]. Defaults to None.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Start date for subsetting in 'YYYY-MM-DD' format. Defaults to None.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date for subsetting in 'YYYY-MM-DD' format. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>Output directory to save the subsetted files. Defaults to None, which will use the current working directory.</p> <code>None</code> <code>collection</code> <code>Collection</code> <p>GEDI data collection. If not provided, the default collection with DOI '10.3334/ORNLDAAC/2056' will be used. Defaults to None.</p> <code>None</code> <code>variables</code> <code>List[str]</code> <p>List of variable names to subset. Defaults to ['all'], which subsets all available variables.</p> <code>['all']</code> <code>max_results</code> <code>int</code> <p>Maximum number of results to return. Defaults to None, which returns all results.</p> <code>None</code> <code>username</code> <code>str</code> <p>Earthdata username. Defaults to None, which will attempt to read from the 'EARTHDATA_USERNAME' environment variable.</p> <code>None</code> <code>password</code> <code>str</code> <p>Earthdata password. Defaults to None, which will attempt to read from the 'EARTHDATA_PASSWORD' environment variable.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing files in the output directory. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Harmony API request.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the 'harmony' package is not installed.</p> <code>ValueError</code> <p>If the 'spatial', 'start_date', or 'end_date' arguments are not valid.</p> <p>Returns:</p> Type Description <code>None</code> <p>This function does not return any value.</p> Source code in <code>geojp/common.py</code> <pre><code>def gedi_subset(\n    spatial=None,\n    start_date=None,\n    end_date=None,\n    out_dir=None,\n    collection=None,\n    variables=[\"all\"],\n    max_results=None,\n    username=None,\n    password=None,\n    overwrite=False,\n    **kwargs,\n):\n    \"\"\"\n    Subsets GEDI data using the Harmony API.\n\n    Args:\n        spatial (Union[str, gpd.GeoDataFrame, List[float]], optional): Spatial extent for subsetting.\n            Can be a file path to a shapefile, a GeoDataFrame, or a list of bounding box coordinates [minx, miny, maxx, maxy].\n            Defaults to None.\n        start_date (str, optional): Start date for subsetting in 'YYYY-MM-DD' format.\n            Defaults to None.\n        end_date (str, optional): End date for subsetting in 'YYYY-MM-DD' format.\n            Defaults to None.\n        out_dir (str, optional): Output directory to save the subsetted files.\n            Defaults to None, which will use the current working directory.\n        collection (Collection, optional): GEDI data collection. If not provided,\n            the default collection with DOI '10.3334/ORNLDAAC/2056' will be used.\n            Defaults to None.\n        variables (List[str], optional): List of variable names to subset.\n            Defaults to ['all'], which subsets all available variables.\n        max_results (int, optional): Maximum number of results to return.\n            Defaults to None, which returns all results.\n        username (str, optional): Earthdata username.\n            Defaults to None, which will attempt to read from the 'EARTHDATA_USERNAME' environment variable.\n        password (str, optional): Earthdata password.\n            Defaults to None, which will attempt to read from the 'EARTHDATA_PASSWORD' environment variable.\n        overwrite (bool, optional): Whether to overwrite existing files in the output directory.\n            Defaults to False.\n        **kwargs: Additional keyword arguments to pass to the Harmony API request.\n\n    Raises:\n        ImportError: If the 'harmony' package is not installed.\n        ValueError: If the 'spatial', 'start_date', or 'end_date' arguments are not valid.\n\n    Returns:\n        None: This function does not return any value.\n    \"\"\"\n\n    try:\n        import harmony\n    except ImportError:\n        install_package(\"harmony-py\")\n\n    import requests as re\n    import geopandas as gpd\n    from datetime import datetime\n    from harmony import BBox, Client, Collection, Environment, Request\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if collection is None:\n        # GEDI L4A DOI\n        doi = \"10.3334/ORNLDAAC/2056\"\n\n        # CMR API base url\n        doisearch = f\"https://cmr.earthdata.nasa.gov/search/collections.json?doi={doi}\"\n        concept_id = re.get(doisearch).json()[\"feed\"][\"entry\"][0][\"id\"]\n        concept_id\n        collection = Collection(id=concept_id)\n\n    if username is None:\n        username = os.environ.get(\"EARTHDATA_USERNAME\", None)\n    if password is None:\n        password = os.environ.get(\"EARTHDATA_PASSWORD\", None)\n\n    if username is None or password is None:\n        raise ValueError(\"username and password must be provided.\")\n\n    harmony_client = Client(auth=(username, password))\n\n    if isinstance(spatial, str):\n        spatial = gpd.read_file(spatial)\n\n    if isinstance(spatial, gpd.GeoDataFrame):\n        spatial = spatial.total_bounds.tolist()\n\n    if isinstance(spatial, list) and len(spatial) == 4:\n        bounding_box = BBox(spatial[0], spatial[1], spatial[2], spatial[3])\n    else:\n        raise ValueError(\n            \"spatial must be a list of bounding box coordinates or a GeoDataFrame, or a file path.\"\n        )\n\n    if isinstance(start_date, str):\n        start_date = datetime.strptime(start_date, \"%Y-%m-%d\")\n\n    if isinstance(end_date, str):\n        end_date = datetime.strptime(end_date, \"%Y-%m-%d\")\n\n    if start_date is None or end_date is None:\n        print(\"start_date and end_date must be provided.\")\n        temporal_range = None\n    else:\n        temporal_range = {\"start\": start_date, \"end\": end_date}\n\n    request = Request(\n        collection=collection,\n        variables=variables,\n        temporal=temporal_range,\n        spatial=bounding_box,\n        ignore_errors=True,\n        max_results=max_results,\n        **kwargs,\n    )\n\n    # submit harmony request, will return job id\n    subset_job_id = harmony_client.submit(request)\n\n    print(f\"Processing job: {subset_job_id}\")\n\n    print(f\"Waiting for the job to finish\")\n    results = harmony_client.result_json(subset_job_id, show_progress=True)\n\n    print(f\"Downloading subset files...\")\n    futures = harmony_client.download_all(\n        subset_job_id, directory=out_dir, overwrite=overwrite\n    )\n    for f in futures:\n        # all subsetted files have this suffix\n        if f.result().endswith(\"subsetted.h5\"):\n            print(f\"Downloaded: {f.result()}\")\n\n    print(f\"Done downloading files.\")\n</code></pre>"},{"location":"common/#geojp.common.geojson_to_df","title":"<code>geojson_to_df(in_geojson, encoding='utf-8', drop_geometry=True)</code>","text":"<p>Converts a GeoJSON object to a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or dict.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON object. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <code>drop_geometry</code> <code>bool</code> <p>Whether to drop the geometry column. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the input GeoJSON file could not be found.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A pandas DataFrame containing the GeoJSON object.</p> Source code in <code>geojp/common.py</code> <pre><code>def geojson_to_df(in_geojson, encoding=\"utf-8\", drop_geometry=True):\n    \"\"\"Converts a GeoJSON object to a pandas DataFrame.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or dict.\n        encoding (str, optional): The encoding of the GeoJSON object. Defaults to \"utf-8\".\n        drop_geometry (bool, optional): Whether to drop the geometry column. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the input GeoJSON file could not be found.\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame containing the GeoJSON object.\n    \"\"\"\n\n    import json\n    import pandas as pd\n    from urllib.request import urlopen\n\n    if isinstance(in_geojson, str):\n        if in_geojson.startswith(\"http\"):\n            with urlopen(in_geojson) as f:\n                data = json.load(f)\n        else:\n            in_geojson = os.path.abspath(in_geojson)\n            if not os.path.exists(in_geojson):\n                raise FileNotFoundError(\"The provided GeoJSON file could not be found.\")\n\n            with open(in_geojson, encoding=encoding) as f:\n                data = json.load(f)\n\n    elif isinstance(in_geojson, dict):\n        data = in_geojson\n\n    df = pd.json_normalize(data[\"features\"])\n    df.columns = [col.replace(\"properties.\", \"\") for col in df.columns]\n    if drop_geometry:\n        df = df[df.columns.drop(list(df.filter(regex=\"geometry\")))]\n    return df\n</code></pre>"},{"location":"common/#geojp.common.geojson_to_gdf","title":"<code>geojson_to_gdf(in_geojson, encoding='utf-8', **kwargs)</code>","text":"<p>Converts a GeoJSON object to a geopandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or GeoJSON object as a dict.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON object. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A geopandas GeoDataFrame containing the GeoJSON object.</p> Source code in <code>geojp/common.py</code> <pre><code>def geojson_to_gdf(in_geojson, encoding=\"utf-8\", **kwargs):\n    \"\"\"Converts a GeoJSON object to a geopandas GeoDataFrame.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or GeoJSON object as a dict.\n        encoding (str, optional): The encoding of the GeoJSON object. Defaults to \"utf-8\".\n\n    Returns:\n        geopandas.GeoDataFrame: A geopandas GeoDataFrame containing the GeoJSON object.\n    \"\"\"\n\n    import geopandas as gpd\n\n    if isinstance(in_geojson, dict):\n        out_file = temp_file_path(extension=\"geojson\")\n        with open(out_file, \"w\") as f:\n            json.dump(in_geojson, f)\n            in_geojson = out_file\n\n    gdf = gpd.read_file(in_geojson, encoding=encoding, **kwargs)\n    return gdf\n</code></pre>"},{"location":"common/#geojp.common.geojson_to_gpkg","title":"<code>geojson_to_gpkg(in_geojson, out_gpkg, **kwargs)</code>","text":"<p>Converts a GeoJSON object to GeoPackage.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or dict.</p> required <code>out_gpkg</code> <code>str</code> <p>The output GeoPackage path.</p> required Source code in <code>geojp/common.py</code> <pre><code>def geojson_to_gpkg(in_geojson, out_gpkg, **kwargs):\n    \"\"\"Converts a GeoJSON object to GeoPackage.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or dict.\n        out_gpkg (str): The output GeoPackage path.\n    \"\"\"\n    import geopandas as gpd\n    import json\n\n    ext = os.path.splitext(out_gpkg)[1]\n    if ext.lower() != \".gpkg\":\n        out_gpkg = out_gpkg + \".gpkg\"\n    out_gpkg = check_file_path(out_gpkg)\n\n    if isinstance(in_geojson, dict):\n        out_file = temp_file_path(extension=\"geojson\")\n        with open(out_file, \"w\") as f:\n            json.dump(in_geojson, f)\n            in_geojson = out_file\n\n    gdf = gpd.read_file(in_geojson, **kwargs)\n    name = os.path.splitext(os.path.basename(out_gpkg))[0]\n    gdf.to_file(out_gpkg, layer=name, driver=\"GPKG\")\n</code></pre>"},{"location":"common/#geojp.common.geojson_to_mbtiles","title":"<code>geojson_to_mbtiles(input_file, output_file, layer_name=None, options=None, quiet=False)</code>","text":"<p>Converts vector data to .mbtiles using Tippecanoe.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the input vector data file (e.g., .geojson).</p> required <code>output_file</code> <code>str</code> <p>Path to the output .mbtiles file.</p> required <code>layer_name</code> <code>Optional[str]</code> <p>Optional name for the layer. Defaults to None.</p> <code>None</code> <code>options</code> <code>Optional[List[str]]</code> <p>List of additional arguments for tippecanoe. For example '-zg' for auto maxzoom. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.</p> <p>Exceptions:</p> Type Description <code>subprocess.CalledProcessError</code> <p>If there's an error executing the tippecanoe command.</p> Source code in <code>geojp/common.py</code> <pre><code>def geojson_to_mbtiles(\n    input_file: str,\n    output_file: str,\n    layer_name: Optional[str] = None,\n    options: Optional[List[str]] = None,\n    quiet: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"\n    Converts vector data to .mbtiles using Tippecanoe.\n\n    Args:\n        input_file (str): Path to the input vector data file (e.g., .geojson).\n        output_file (str): Path to the output .mbtiles file.\n        layer_name (Optional[str]): Optional name for the layer. Defaults to None.\n        options (Optional[List[str]]): List of additional arguments for tippecanoe. For example '-zg' for auto maxzoom. Defaults to None.\n        quiet (bool): If True, suppress the log output. Defaults to False.\n\n    Returns:\n        Optional[str]: Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.\n\n    Raises:\n        subprocess.CalledProcessError: If there's an error executing the tippecanoe command.\n    \"\"\"\n\n    import subprocess\n    import shutil\n\n    # Check if tippecanoe exists\n    if shutil.which(\"tippecanoe\") is None:\n        print(\"Error: tippecanoe is not installed.\")\n        print(\"You can install it using conda with the following command:\")\n        print(\"conda install -c conda-forge tippecanoe\")\n        return None\n\n    command = [\"tippecanoe\", \"-o\", output_file]\n\n    # Add layer name specification if provided\n    if layer_name:\n        command.extend([\"-L\", f\"{layer_name}:{input_file}\"])\n    else:\n        command.append(input_file)\n\n    # Append additional arguments if provided\n    if options:\n        command.extend(options)\n\n    try:\n        process = subprocess.Popen(\n            command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True\n        )\n\n        if not quiet:\n            for line in process.stdout:\n                print(line, end=\"\")\n\n        exit_code = process.wait()\n        if exit_code != 0:\n            raise subprocess.CalledProcessError(exit_code, command)\n\n    except subprocess.CalledProcessError as e:\n        print(f\"\\nError executing tippecanoe: {e}\")\n        return None\n\n    return \"Tippecanoe process completed successfully.\"\n</code></pre>"},{"location":"common/#geojp.common.geojson_to_pmtiles","title":"<code>geojson_to_pmtiles(input_file, output_file=None, layer_name=None, projection='EPSG:4326', overwrite=False, options=None, quiet=False)</code>","text":"<p>Converts vector data to PMTiles using Tippecanoe.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the input vector data file (e.g., .geojson).</p> required <code>output_file</code> <code>str</code> <p>Path to the output .mbtiles file.</p> <code>None</code> <code>layer_name</code> <code>Optional[str]</code> <p>Optional name for the layer. Defaults to None.</p> <code>None</code> <code>projection</code> <code>Optional[str]</code> <p>Projection for the output PMTiles file. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite the existing output file. Defaults to False.</p> <code>False</code> <code>options</code> <code>Optional[List[str]]</code> <p>List of additional arguments for tippecanoe. Defaults to None. To reduce the size of the output file, use '-zg' or '-z max-zoom'.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.</p> <p>Exceptions:</p> Type Description <code>subprocess.CalledProcessError</code> <p>If there's an error executing the tippecanoe command.</p> Source code in <code>geojp/common.py</code> <pre><code>def geojson_to_pmtiles(\n    input_file: str,\n    output_file: Optional[str] = None,\n    layer_name: Optional[str] = None,\n    projection: Optional[str] = \"EPSG:4326\",\n    overwrite: bool = False,\n    options: Optional[List[str]] = None,\n    quiet: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"\n    Converts vector data to PMTiles using Tippecanoe.\n\n    Args:\n        input_file (str): Path to the input vector data file (e.g., .geojson).\n        output_file (str): Path to the output .mbtiles file.\n        layer_name (Optional[str]): Optional name for the layer. Defaults to None.\n        projection (Optional[str]): Projection for the output PMTiles file. Defaults to \"EPSG:4326\".\n        overwrite (bool): If True, overwrite the existing output file. Defaults to False.\n        options (Optional[List[str]]): List of additional arguments for tippecanoe. Defaults to None.\n            To reduce the size of the output file, use '-zg' or '-z max-zoom'.\n        quiet (bool): If True, suppress the log output. Defaults to False.\n\n    Returns:\n        Optional[str]: Output from the Tippecanoe command, or None if there was an error or if Tippecanoe is not installed.\n\n    Raises:\n        subprocess.CalledProcessError: If there's an error executing the tippecanoe command.\n    \"\"\"\n\n    import subprocess\n    import shutil\n\n    # Check if tippecanoe exists\n    if shutil.which(\"tippecanoe\") is None:\n        print(\"Error: tippecanoe is not installed.\")\n        print(\"You can install it using conda with the following command:\")\n        print(\"conda install -c conda-forge tippecanoe\")\n        return None\n\n    if output_file is None:\n        output_file = os.path.splitext(input_file)[0] + \".pmtiles\"\n\n    if not output_file.endswith(\".pmtiles\"):\n        raise ValueError(\"Error: output file must be a .pmtiles file.\")\n\n    command = [\"tippecanoe\", \"-o\", output_file]\n\n    # Add layer name specification if provided\n    if layer_name:\n        command.extend([\"-L\", f\"{layer_name}:{input_file}\"])\n    else:\n        command.append(input_file)\n\n    command.extend([\"--projection\", projection])\n\n    if options is None:\n        options = []\n\n    if overwrite:\n        command.append(\"--force\")\n\n    # Append additional arguments if provided\n    if options:\n        command.extend(options)\n\n    try:\n        process = subprocess.Popen(\n            command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True\n        )\n\n        if not quiet:\n            for line in process.stdout:\n                print(line, end=\"\")\n\n        exit_code = process.wait()\n        if exit_code != 0:\n            raise subprocess.CalledProcessError(exit_code, command)\n\n    except subprocess.CalledProcessError as e:\n        print(f\"\\nError executing tippecanoe: {e}\")\n        return None\n\n    return \"Tippecanoe process completed successfully.\"\n</code></pre>"},{"location":"common/#geojp.common.geojson_to_shp","title":"<code>geojson_to_shp(in_geojson, out_shp, **kwargs)</code>","text":"<p>Converts a GeoJSON object to GeoPandas GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The input GeoJSON file or dict.</p> required <code>out_shp</code> <code>str</code> <p>The output shapefile path.</p> required Source code in <code>geojp/common.py</code> <pre><code>def geojson_to_shp(in_geojson, out_shp, **kwargs):\n    \"\"\"Converts a GeoJSON object to GeoPandas GeoDataFrame.\n\n    Args:\n        in_geojson (str | dict): The input GeoJSON file or dict.\n        out_shp (str): The output shapefile path.\n    \"\"\"\n    import geopandas as gpd\n    import json\n\n    ext = os.path.splitext(out_shp)[1]\n    if ext != \".shp\":\n        out_shp = out_shp + \".shp\"\n    out_shp = check_file_path(out_shp)\n\n    if isinstance(in_geojson, dict):\n        out_file = temp_file_path(extension=\"geojson\")\n        with open(out_file, \"w\") as f:\n            json.dump(in_geojson, f)\n            in_geojson = out_file\n\n    gdf = gpd.read_file(in_geojson, **kwargs)\n    gdf.to_file(out_shp)\n</code></pre>"},{"location":"common/#geojp.common.geom_type","title":"<code>geom_type(in_geojson, encoding='utf-8')</code>","text":"<p>Returns the geometry type of a GeoJSON object.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>dict</code> <p>A GeoJSON object.</p> required <code>encoding</code> <code>str</code> <p>The encoding of the GeoJSON object. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>str</code> <p>The geometry type of the GeoJSON object, such as Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon.     For more info, see https://shapely.readthedocs.io/en/stable/manual.html</p> Source code in <code>geojp/common.py</code> <pre><code>def geom_type(in_geojson, encoding=\"utf-8\"):\n    \"\"\"Returns the geometry type of a GeoJSON object.\n\n    Args:\n        in_geojson (dict): A GeoJSON object.\n        encoding (str, optional): The encoding of the GeoJSON object. Defaults to \"utf-8\".\n\n    Returns:\n        str: The geometry type of the GeoJSON object, such as Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon.\n            For more info, see https://shapely.readthedocs.io/en/stable/manual.html\n    \"\"\"\n    import json\n\n    try:\n        if isinstance(in_geojson, str):\n            if in_geojson.startswith(\"http\"):\n                data = requests.get(in_geojson).json()\n            else:\n                in_geojson = os.path.abspath(in_geojson)\n                if not os.path.exists(in_geojson):\n                    raise FileNotFoundError(\n                        \"The provided GeoJSON file could not be found.\"\n                    )\n\n                with open(in_geojson, encoding=encoding) as f:\n                    data = json.load(f)\n        elif isinstance(in_geojson, dict):\n            data = in_geojson\n        else:\n            raise TypeError(\"The input geojson must be a type of str or dict.\")\n\n        return data[\"features\"][0][\"geometry\"][\"type\"]\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.geometry_bounds","title":"<code>geometry_bounds(geometry, decimals=4)</code>","text":"<p>Returns the bounds of a geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>A GeoJSON geometry.</p> required <code>decimals</code> <code>int</code> <p>The number of decimal places to round the bounds to. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of bounds in the form of [minx, miny, maxx, maxy].</p> Source code in <code>geojp/common.py</code> <pre><code>def geometry_bounds(geometry, decimals=4):\n    \"\"\"Returns the bounds of a geometry.\n\n    Args:\n        geometry (dict): A GeoJSON geometry.\n        decimals (int, optional): The number of decimal places to round the bounds to. Defaults to 4.\n\n    Returns:\n        list: A list of bounds in the form of [minx, miny, maxx, maxy].\n    \"\"\"\n    if isinstance(geometry, dict):\n        if \"geometry\" in geometry:\n            coords = geometry[\"geometry\"][\"coordinates\"][0]\n        else:\n            coords = geometry[\"coordinates\"][0]\n\n    else:\n        raise ValueError(\"geometry must be a GeoJSON-like dictionary.\")\n\n    x = [p[0] for p in coords]\n    y = [p[1] for p in coords]\n    west = round(min(x), decimals)\n    east = round(max(x), decimals)\n    south = round(min(y), decimals)\n    north = round(max(y), decimals)\n    return [west, south, east, north]\n</code></pre>"},{"location":"common/#geojp.common.get_3dep_dem","title":"<code>get_3dep_dem(geometry, resolution=30, src_crs='EPSG:4326', output=None, dst_crs='EPSG:5070', to_cog=False, overwrite=False, **kwargs)</code>","text":"<p>Get DEM data at any resolution from 3DEP.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Polygon | MultiPolygon | tuple</code> <p>It can be a polygon or a bounding box of form (xmin, ymin, xmax, ymax).</p> required <code>resolution</code> <code>int</code> <p>arget DEM source resolution in meters. Defaults to 30.</p> <code>30</code> <code>src_crs</code> <code>str</code> <p>The spatial reference system of the input geometry. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>output</code> <code>str</code> <p>The output GeoTIFF file. Defaults to None.</p> <code>None</code> <code>dst_crs</code> <code>str</code> <p>The spatial reference system of the output GeoTIFF file. Defaults to \"EPSG:5070\".</p> <code>'EPSG:5070'</code> <code>to_cog</code> <code>bool</code> <p>Convert to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the output file if it exists. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>xarray.DataArray</code> <p>DEM at the specified resolution in meters and CRS.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_3dep_dem(\n    geometry,\n    resolution=30,\n    src_crs=\"EPSG:4326\",\n    output=None,\n    dst_crs=\"EPSG:5070\",\n    to_cog=False,\n    overwrite=False,\n    **kwargs,\n):\n    \"\"\"Get DEM data at any resolution from 3DEP.\n\n    Args:\n        geometry (Polygon | MultiPolygon | tuple): It can be a polygon or a bounding\n            box of form (xmin, ymin, xmax, ymax).\n        resolution (int): arget DEM source resolution in meters. Defaults to 30.\n        src_crs (str, optional): The spatial reference system of the input geometry. Defaults to \"EPSG:4326\".\n        output (str, optional): The output GeoTIFF file. Defaults to None.\n        dst_crs (str, optional): The spatial reference system of the output GeoTIFF file. Defaults to \"EPSG:5070\".\n        to_cog (bool, optional): Convert to Cloud Optimized GeoTIFF. Defaults to False.\n        overwrite (bool, optional): Whether to overwrite the output file if it exists. Defaults to False.\n\n    Returns:\n        xarray.DataArray: DEM at the specified resolution in meters and CRS.\n    \"\"\"\n\n    try:\n        import py3dep\n    except ImportError:\n        raise ImportError(\"py3dep is not installed. Install it with pip install py3dep\")\n\n    try:\n        import geopandas as gpd\n    except ImportError:\n        raise ImportError(\n            \"geopandas is not installed. Install it with pip install geopandas\"\n        )\n\n    if output is not None and os.path.exists(output) and not overwrite:\n        print(f\"File {output} already exists. Set overwrite=True to overwrite it\")\n        return\n\n    if isinstance(geometry, gpd.GeoDataFrame):\n        geometry = geometry.geometry.unary_union\n\n    dem = py3dep.get_dem(geometry, resolution=resolution, crs=src_crs)\n    dem = dem.rio.reproject(dst_crs)\n\n    if output is not None:\n        if not output.endswith(\".tif\"):\n            output += \".tif\"\n        print(output)\n        dem.rio.to_raster(output, **kwargs)\n\n        if to_cog:\n            image_to_cog(output, output)\n\n    else:\n        return dem\n</code></pre>"},{"location":"common/#geojp.common.get_api_key","title":"<code>get_api_key(token_name, m=None)</code>","text":"<p>Retrieves an API key based on a system environmen variable.</p> <p>Parameters:</p> Name Type Description Default <code>token_name</code> <code>str</code> <p>The token name.</p> required <code>m</code> <code>ipyleaflet.Map | folium.Map</code> <p>A Map instance. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The API key.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_api_key(token_name, m=None):\n    \"\"\"Retrieves an API key based on a system environmen variable.\n\n    Args:\n        token_name (str): The token name.\n        m (ipyleaflet.Map | folium.Map, optional): A Map instance. Defaults to None.\n\n    Returns:\n        str: The API key.\n    \"\"\"\n    api_key = os.environ.get(token_name)\n    if m is not None and token_name in m.api_keys:\n        api_key = m.api_keys[token_name]\n\n    return api_key\n</code></pre>"},{"location":"common/#geojp.common.get_bounds","title":"<code>get_bounds(geometry, north_up=True, transform=None)</code>","text":"<p>Bounding box of a GeoJSON geometry, GeometryCollection, or FeatureCollection. left, bottom, right, top not xmin, ymin, xmax, ymax If not north_up, y will be switched to guarantee the above. Source code adapted from https://github.com/mapbox/rasterio/blob/master/rasterio/features.py#L361</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>A GeoJSON dict.</p> required <code>north_up</code> <code>bool</code> <p>. Defaults to True.</p> <code>True</code> <code>transform</code> <code>[type]</code> <p>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of coordinates representing [left, bottom, right, top]</p> Source code in <code>geojp/common.py</code> <pre><code>def get_bounds(geometry, north_up=True, transform=None):\n    \"\"\"Bounding box of a GeoJSON geometry, GeometryCollection, or FeatureCollection.\n    left, bottom, right, top\n    *not* xmin, ymin, xmax, ymax\n    If not north_up, y will be switched to guarantee the above.\n    Source code adapted from https://github.com/mapbox/rasterio/blob/master/rasterio/features.py#L361\n\n    Args:\n        geometry (dict): A GeoJSON dict.\n        north_up (bool, optional): . Defaults to True.\n        transform ([type], optional): . Defaults to None.\n\n    Returns:\n        list: A list of coordinates representing [left, bottom, right, top]\n    \"\"\"\n\n    if \"bbox\" in geometry:\n        return tuple(geometry[\"bbox\"])\n\n    geometry = geometry.get(\"geometry\") or geometry\n\n    # geometry must be a geometry, GeometryCollection, or FeatureCollection\n    if not (\n        \"coordinates\" in geometry or \"geometries\" in geometry or \"features\" in geometry\n    ):\n        raise ValueError(\n            \"geometry must be a GeoJSON-like geometry, GeometryCollection, \"\n            \"or FeatureCollection\"\n        )\n\n    if \"features\" in geometry:\n        # Input is a FeatureCollection\n        xmins = []\n        ymins = []\n        xmaxs = []\n        ymaxs = []\n        for feature in geometry[\"features\"]:\n            xmin, ymin, xmax, ymax = get_bounds(feature[\"geometry\"])\n            xmins.append(xmin)\n            ymins.append(ymin)\n            xmaxs.append(xmax)\n            ymaxs.append(ymax)\n        if north_up:\n            return min(xmins), min(ymins), max(xmaxs), max(ymaxs)\n        else:\n            return min(xmins), max(ymaxs), max(xmaxs), min(ymins)\n\n    elif \"geometries\" in geometry:\n        # Input is a geometry collection\n        xmins = []\n        ymins = []\n        xmaxs = []\n        ymaxs = []\n        for geometry in geometry[\"geometries\"]:\n            xmin, ymin, xmax, ymax = get_bounds(geometry)\n            xmins.append(xmin)\n            ymins.append(ymin)\n            xmaxs.append(xmax)\n            ymaxs.append(ymax)\n        if north_up:\n            return min(xmins), min(ymins), max(xmaxs), max(ymaxs)\n        else:\n            return min(xmins), max(ymaxs), max(xmaxs), min(ymins)\n\n    elif \"coordinates\" in geometry:\n        # Input is a singular geometry object\n        if transform is not None:\n            xyz = list(explode(geometry[\"coordinates\"]))\n            xyz_px = [transform * point for point in xyz]\n            xyz = tuple(zip(*xyz_px))\n            return min(xyz[0]), max(xyz[1]), max(xyz[0]), min(xyz[1])\n        else:\n            xyz = tuple(zip(*list(explode(geometry[\"coordinates\"]))))\n            if north_up:\n                return min(xyz[0]), min(xyz[1]), max(xyz[0]), max(xyz[1])\n            else:\n                return min(xyz[0]), max(xyz[1]), max(xyz[0]), min(xyz[1])\n\n    # all valid inputs returned above, so whatever falls through is an error\n    raise ValueError(\n        \"geometry must be a GeoJSON-like geometry, GeometryCollection, \"\n        \"or FeatureCollection\"\n    )\n</code></pre>"},{"location":"common/#geojp.common.get_census_dict","title":"<code>get_census_dict(reset=False)</code>","text":"<p>Returns a dictionary of Census data.</p> <p>Parameters:</p> Name Type Description Default <code>reset</code> <code>bool</code> <p>Reset the dictionary. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of Census data.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_census_dict(reset=False):\n    \"\"\"Returns a dictionary of Census data.\n\n    Args:\n        reset (bool, optional): Reset the dictionary. Defaults to False.\n\n    Returns:\n        dict: A dictionary of Census data.\n    \"\"\"\n    import json\n    import pkg_resources\n\n    pkg_dir = os.path.dirname(pkg_resources.resource_filename(\"leafmap\", \"leafmap.py\"))\n    census_data = os.path.join(pkg_dir, \"data/census_data.json\")\n\n    if reset:\n        try:\n            from owslib.wms import WebMapService\n        except ImportError:\n            raise ImportError(\"Please install owslib using 'pip install owslib'.\")\n\n        census_dict = {}\n\n        names = [\n            \"Current\",\n            \"ACS 2021\",\n            \"ACS 2019\",\n            \"ACS 2018\",\n            \"ACS 2017\",\n            \"ACS 2016\",\n            \"ACS 2015\",\n            \"ACS 2014\",\n            \"ACS 2013\",\n            \"ACS 2012\",\n            \"ECON 2012\",\n            \"Census 2020\",\n            \"Census 2010\",\n            \"Physical Features\",\n            \"Decennial Census 2020\",\n            \"Decennial Census 2010\",\n            \"Decennial Census 2000\",\n            \"Decennial Physical Features\",\n        ]\n\n        links = {}\n\n        print(\"Retrieving data. Please wait ...\")\n        for name in names:\n            if \"Decennial\" not in name:\n                links[name] = (\n                    f\"https://tigerweb.geo.census.gov/arcgis/services/TIGERweb/tigerWMS_{name.replace(' ', '')}/MapServer/WMSServer\"\n                )\n            else:\n                links[name] = (\n                    f\"https://tigerweb.geo.census.gov/arcgis/services/Census2020/tigerWMS_{name.replace('Decennial', '').replace(' ', '')}/MapServer/WMSServer\"\n                )\n\n            wms = WebMapService(links[name], timeout=300)\n            layers = list(wms.contents)\n            layers.sort()\n            census_dict[name] = {\n                \"url\": links[name],\n                \"layers\": layers,\n                # \"title\": wms.identification.title,\n                # \"abstract\": wms.identification.abstract,\n            }\n\n        with open(census_data, \"w\") as f:\n            json.dump(census_dict, f, indent=4)\n\n    else:\n        with open(census_data, \"r\") as f:\n            census_dict = json.load(f)\n\n    return census_dict\n</code></pre>"},{"location":"common/#geojp.common.get_center","title":"<code>get_center(geometry, north_up=True, transform=None)</code>","text":"<p>Get the centroid of a GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>dict</code> <p>A GeoJSON dict.</p> required <code>north_up</code> <code>bool</code> <p>. Defaults to True.</p> <code>True</code> <code>transform</code> <code>[type]</code> <p>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>[lon, lat]</p> Source code in <code>geojp/common.py</code> <pre><code>def get_center(geometry, north_up=True, transform=None):\n    \"\"\"Get the centroid of a GeoJSON.\n\n    Args:\n        geometry (dict): A GeoJSON dict.\n        north_up (bool, optional): . Defaults to True.\n        transform ([type], optional): . Defaults to None.\n\n    Returns:\n        list: [lon, lat]\n    \"\"\"\n    bounds = get_bounds(geometry, north_up, transform)\n    center = ((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2)  # (lat, lon)\n    return center\n</code></pre>"},{"location":"common/#geojp.common.get_direct_url","title":"<code>get_direct_url(url)</code>","text":"<p>Get the direct URL for a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to get the direct URL for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The direct URL.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_direct_url(url):\n    \"\"\"Get the direct URL for a given URL.\n\n    Args:\n        url (str): The URL to get the direct URL for.\n\n    Returns:\n        str: The direct URL.\n    \"\"\"\n\n    if not isinstance(url, str):\n        raise ValueError(\"url must be a string.\")\n\n    if not url.startswith(\"http\"):\n        raise ValueError(\"url must start with http.\")\n\n    r = requests.head(url, allow_redirects=True)\n    return r.url\n</code></pre>"},{"location":"common/#geojp.common.get_gdal_drivers","title":"<code>get_gdal_drivers()</code>","text":"<p>Get a list of available driver names in the GDAL library.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of available driver names.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_gdal_drivers() -&gt; List[str]:\n    \"\"\"Get a list of available driver names in the GDAL library.\n\n    Returns:\n        List[str]: A list of available driver names.\n    \"\"\"\n    from osgeo import ogr\n\n    driver_list = []\n\n    # Iterate over all registered drivers\n    for i in range(ogr.GetDriverCount()):\n        driver = ogr.GetDriver(i)\n        driver_name = driver.GetName()\n        driver_list.append(driver_name)\n\n    return driver_list\n</code></pre>"},{"location":"common/#geojp.common.get_gdal_file_extension","title":"<code>get_gdal_file_extension(driver_name)</code>","text":"<p>Get the file extension corresponding to a driver name in the GDAL library.</p> <p>Parameters:</p> Name Type Description Default <code>driver_name</code> <code>str</code> <p>The name of the driver.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The file extension corresponding to the driver name, or None if the driver is not found or does not have a specific file extension.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_gdal_file_extension(driver_name: str) -&gt; Optional[str]:\n    \"\"\"Get the file extension corresponding to a driver name in the GDAL library.\n\n    Args:\n        driver_name (str): The name of the driver.\n\n    Returns:\n        Optional[str]: The file extension corresponding to the driver name, or None if the driver is not found or does not have a specific file extension.\n    \"\"\"\n    from osgeo import ogr\n\n    driver = ogr.GetDriverByName(driver_name)\n    if driver is None:\n        drivers = get_gdal_drivers()\n        raise ValueError(\n            f\"Driver {driver_name} not found. Available drivers: {drivers}\"\n        )\n\n    metadata = driver.GetMetadata()\n    if \"DMD_EXTENSION\" in metadata:\n        file_extension = driver.GetMetadataItem(\"DMD_EXTENSION\")\n    else:\n        file_extensions = driver.GetMetadataItem(\"DMD_EXTENSIONS\")\n        if file_extensions == \"json geojson\":\n            file_extension = \"geojson\"\n        else:\n            file_extension = file_extensions.split()[0].lower()\n\n    return file_extension\n</code></pre>"},{"location":"common/#geojp.common.get_geometry_coords","title":"<code>get_geometry_coords(row, geom, coord_type, shape_type, mercator=False)</code>","text":"<p>Returns the coordinates ('x' or 'y') of edges of a Polygon exterior.</p> <p>:param: (GeoPandas Series) row : The row of each of the GeoPandas DataFrame. :param: (str) geom : The column name. :param: (str) coord_type : Whether it's 'x' or 'y' coordinate. :param: (str) shape_type</p> Source code in <code>geojp/common.py</code> <pre><code>def get_geometry_coords(row, geom, coord_type, shape_type, mercator=False):\n    \"\"\"\n    Returns the coordinates ('x' or 'y') of edges of a Polygon exterior.\n\n    :param: (GeoPandas Series) row : The row of each of the GeoPandas DataFrame.\n    :param: (str) geom : The column name.\n    :param: (str) coord_type : Whether it's 'x' or 'y' coordinate.\n    :param: (str) shape_type\n    \"\"\"\n\n    # Parse the exterior of the coordinate\n    if shape_type.lower() in [\"polygon\", \"multipolygon\"]:\n        exterior = row[geom].geoms[0].exterior\n        if coord_type == \"x\":\n            # Get the x coordinates of the exterior\n            coords = list(exterior.coords.xy[0])\n            if mercator:\n                coords = [lnglat_to_meters(x, 0)[0] for x in coords]\n            return coords\n\n        elif coord_type == \"y\":\n            # Get the y coordinates of the exterior\n            coords = list(exterior.coords.xy[1])\n            if mercator:\n                coords = [lnglat_to_meters(0, y)[1] for y in coords]\n            return coords\n\n    elif shape_type.lower() in [\"linestring\", \"multilinestring\"]:\n        if coord_type == \"x\":\n            coords = list(row[geom].coords.xy[0])\n            if mercator:\n                coords = [lnglat_to_meters(x, 0)[0] for x in coords]\n            return coords\n        elif coord_type == \"y\":\n            coords = list(row[geom].coords.xy[1])\n            if mercator:\n                coords = [lnglat_to_meters(0, y)[1] for y in coords]\n            return coords\n\n    elif shape_type.lower() in [\"point\", \"multipoint\"]:\n        exterior = row[geom]\n\n        if coord_type == \"x\":\n            # Get the x coordinates of the exterior\n            coords = exterior.coords.xy[0][0]\n            if mercator:\n                coords = lnglat_to_meters(coords, 0)[0]\n            return coords\n\n        elif coord_type == \"y\":\n            # Get the y coordinates of the exterior\n            coords = exterior.coords.xy[1][0]\n            if mercator:\n                coords = lnglat_to_meters(0, coords)[1]\n            return coords\n</code></pre>"},{"location":"common/#geojp.common.get_geometry_type","title":"<code>get_geometry_type(in_geojson)</code>","text":"<p>Get the geometry type of a GeoJSON file.</p> <p>Parameters:</p> Name Type Description Default <code>in_geojson</code> <code>str | dict</code> <p>The path to the GeoJSON file or a GeoJSON dictionary.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The geometry type. Can be one of \"Point\", \"LineString\", \"Polygon\", \"MultiPoint\",     \"MultiLineString\", \"MultiPolygon\", \"GeometryCollection\", or \"Unknown\".</p> Source code in <code>geojp/common.py</code> <pre><code>def get_geometry_type(in_geojson: Union[str, Dict]) -&gt; str:\n    \"\"\"Get the geometry type of a GeoJSON file.\n\n    Args:\n        in_geojson (str | dict): The path to the GeoJSON file or a GeoJSON dictionary.\n\n    Returns:\n        str: The geometry type. Can be one of \"Point\", \"LineString\", \"Polygon\", \"MultiPoint\",\n            \"MultiLineString\", \"MultiPolygon\", \"GeometryCollection\", or \"Unknown\".\n    \"\"\"\n\n    import geojson\n\n    try:\n        if isinstance(in_geojson, str):  # If input is a file path\n            with open(in_geojson, \"r\") as geojson_file:\n                geojson_data = geojson.load(geojson_file)\n        elif isinstance(in_geojson, dict):  # If input is a GeoJSON dictionary\n            geojson_data = in_geojson\n        else:\n            return \"Invalid input type. Expected file path or dictionary.\"\n\n        if \"type\" in geojson_data:\n            if geojson_data[\"type\"] == \"FeatureCollection\":\n                features = geojson_data.get(\"features\", [])\n                if features:\n                    first_feature = features[0]\n                    geometry = first_feature.get(\"geometry\")\n                    if geometry and \"type\" in geometry:\n                        return geometry[\"type\"]\n                    else:\n                        return \"No geometry type found in the first feature.\"\n                else:\n                    return \"No features found in the FeatureCollection.\"\n            elif geojson_data[\"type\"] == \"Feature\":\n                geometry = geojson_data.get(\"geometry\")\n                if geometry and \"type\" in geometry:\n                    return geometry[\"type\"]\n                else:\n                    return \"No geometry type found in the Feature.\"\n            else:\n                return \"Unsupported GeoJSON type.\"\n        else:\n            return \"No 'type' field found in the GeoJSON data.\"\n    except Exception as e:\n        raise e\n</code></pre>"},{"location":"common/#geojp.common.get_google_map","title":"<code>get_google_map(map_type='HYBRID', show=True, api_key=None, backend='ipyleaflet', **kwargs)</code>","text":"<p>Gets Google basemap tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\". Defaults to 'HYBRID'.</p> <code>'HYBRID'</code> <code>show</code> <code>bool</code> <p>Whether to add the layer to the map. Defaults to True.</p> <code>True</code> <code>api_key</code> <code>str</code> <p>The Google Maps API key. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to ipyleaflet.TileLayer().</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def get_google_map(\n    map_type=\"HYBRID\", show=True, api_key=None, backend=\"ipyleaflet\", **kwargs\n):\n    \"\"\"Gets Google basemap tile layer.\n\n    Args:\n        map_type (str, optional): Can be one of \"ROADMAP\", \"SATELLITE\", \"HYBRID\" or \"TERRAIN\". Defaults to 'HYBRID'.\n        show (bool, optional): Whether to add the layer to the map. Defaults to True.\n        api_key (str, optional): The Google Maps API key. Defaults to None.\n        **kwargs: Additional arguments to pass to ipyleaflet.TileLayer().\n    \"\"\"\n\n    allow_types = [\"ROADMAP\", \"SATELLITE\", \"HYBRID\", \"TERRAIN\"]\n    if map_type not in allow_types:\n        print(\"map_type must be one of the following: {}\".format(allow_types))\n        return\n\n    if api_key is None:\n        api_key = os.environ.get(\"GOOGLE_MAPS_API_KEY\", \"YOUR-API-KEY\")\n\n    if api_key == \"\":\n        MAP_TILES = {\n            \"ROADMAP\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldStreetMap\",\n            },\n            \"SATELLITE\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldImagery\",\n            },\n            \"TERRAIN\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldTopoMap\",\n            },\n            \"HYBRID\": {\n                \"url\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n                \"attribution\": \"Esri\",\n                \"name\": \"Esri.WorldImagery\",\n            },\n        }\n\n        print(\n            \"Google Maps API key is required to use Google Maps. You can generate one from https://bit.ly/3sw0THG and use geemap.set_api_key(), defaulting to Esri basemaps.\"\n        )\n\n    else:\n        MAP_TILES = {\n            \"ROADMAP\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=m&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Maps\",\n            },\n            \"SATELLITE\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=s&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Satellite\",\n            },\n            \"TERRAIN\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=p&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Terrain\",\n            },\n            \"HYBRID\": {\n                \"url\": f\"https://mt1.google.com/vt/lyrs=y&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}&amp;key={api_key}\",\n                \"attribution\": \"Google\",\n                \"name\": \"Google Hybrid\",\n            },\n        }\n\n    if \"max_zoom\" not in kwargs:\n        kwargs[\"max_zoom\"] = 24\n\n    if backend == \"ipyleaflet\":\n        import ipyleaflet\n\n        layer = ipyleaflet.TileLayer(\n            url=MAP_TILES[map_type][\"url\"],\n            name=MAP_TILES[map_type][\"name\"],\n            attribution=MAP_TILES[map_type][\"attribution\"],\n            visible=show,\n            **kwargs,\n        )\n    elif backend == \"folium\":\n        import folium\n\n        layer = folium.TileLayer(\n            tiles=MAP_TILES[map_type][\"url\"],\n            name=MAP_TILES[map_type][\"name\"],\n            attr=MAP_TILES[map_type][\"attribution\"],\n            overlay=True,\n            control=True,\n            show=show,\n            **kwargs,\n        )\n    else:\n        raise ValueError(\"backend must be either 'ipyleaflet' or 'folium'\")\n\n    return layer\n</code></pre>"},{"location":"common/#geojp.common.get_local_tile_layer","title":"<code>get_local_tile_layer(source, port='default', debug=False, indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, attribution=None, tile_format='ipyleaflet', layer_name='Local COG', return_client=False, quiet=False, **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a local raster dataset or remote Cloud Optimized GeoTIFF (COG).     If you are using this function in JupyterHub on a remote server and the raster does not render properly, try     running the following two lines before calling this function:</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.</p> required <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> <code>'default'</code> <code>debug</code> <code>bool</code> <p>If True, the server will be started in debug mode. Defaults to False.</p> <code>False</code> <code>indexes</code> <code>int</code> <p>The band(s) to use. Band indexing starts at 1. Defaults to None.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>tile_format</code> <code>str</code> <p>The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>'Local COG'</code> <code>return_client</code> <code>bool</code> <p>If True, the tile client will be returned. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>If True, the error messages will be suppressed. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ipyleaflet.TileLayer | folium.TileLayer</code> <p>An ipyleaflet.TileLayer or folium.TileLayer.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_local_tile_layer(\n    source,\n    port=\"default\",\n    debug=False,\n    indexes=None,\n    colormap=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    attribution=None,\n    tile_format=\"ipyleaflet\",\n    layer_name=\"Local COG\",\n    return_client=False,\n    quiet=False,\n    **kwargs,\n):\n    \"\"\"Generate an ipyleaflet/folium TileLayer from a local raster dataset or remote Cloud Optimized GeoTIFF (COG).\n        If you are using this function in JupyterHub on a remote server and the raster does not render properly, try\n        running the following two lines before calling this function:\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = 'proxy/{port}'\n\n    Args:\n        source (str): The path to the GeoTIFF file or the URL of the Cloud Optimized GeoTIFF.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        debug (bool, optional): If True, the server will be started in debug mode. Defaults to False.\n        indexes (int, optional): The band(s) to use. Band indexing starts at 1. Defaults to None.\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        tile_format (str, optional): The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n        layer_name (str, optional): The layer name to use. Defaults to None.\n        return_client (bool, optional): If True, the tile client will be returned. Defaults to False.\n        quiet (bool, optional): If True, the error messages will be suppressed. Defaults to False.\n\n    Returns:\n        ipyleaflet.TileLayer | folium.TileLayer: An ipyleaflet.TileLayer or folium.TileLayer.\n    \"\"\"\n    import rasterio\n\n    check_package(\n        \"localtileserver\", URL=\"https://github.com/banesullivan/localtileserver\"\n    )\n\n    # Handle legacy localtileserver kwargs\n    if \"cmap\" in kwargs:\n        warnings.warn(\n            \"`cmap` is a deprecated keyword argument for get_local_tile_layer. Please use `colormap`.\"\n        )\n    if \"palette\" in kwargs:\n        warnings.warn(\n            \"`palette` is a deprecated keyword argument for get_local_tile_layer. Please use `colormap`.\"\n        )\n    if \"band\" in kwargs or \"bands\" in kwargs:\n        warnings.warn(\n            \"`band` and `bands` are deprecated keyword arguments for get_local_tile_layer. Please use `indexes`.\"\n        )\n    if \"projection\" in kwargs:\n        warnings.warn(\n            \"`projection` is a deprecated keyword argument for get_local_tile_layer and will be ignored.\"\n        )\n    if \"style\" in kwargs:\n        warnings.warn(\n            \"`style` is a deprecated keyword argument for get_local_tile_layer and will be ignored.\"\n        )\n\n    if \"max_zoom\" not in kwargs:\n        kwargs[\"max_zoom\"] = 30\n    if \"max_native_zoom\" not in kwargs:\n        kwargs[\"max_native_zoom\"] = 30\n    if \"cmap\" in kwargs:\n        colormap = kwargs.pop(\"cmap\")\n    if \"palette\" in kwargs:\n        colormap = kwargs.pop(\"palette\")\n    if \"band\" in kwargs:\n        indexes = kwargs.pop(\"band\")\n    if \"bands\" in kwargs:\n        indexes = kwargs.pop(\"bands\")\n\n    # Make it compatible with binder and JupyterHub\n    if os.environ.get(\"JUPYTERHUB_SERVICE_PREFIX\") is not None:\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = (\n            f\"{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}\"\n        )\n\n    if is_studio_lab():\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = (\n            f\"studiolab/default/jupyter/proxy/{{port}}\"\n        )\n    elif is_on_aws():\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = \"proxy/{port}\"\n    elif \"prefix\" in kwargs:\n        os.environ[\"LOCALTILESERVER_CLIENT_PREFIX\"] = kwargs[\"prefix\"]\n        kwargs.pop(\"prefix\")\n\n    from localtileserver import (\n        get_leaflet_tile_layer,\n        get_folium_tile_layer,\n        TileClient,\n    )\n\n    # if \"show_loading\" not in kwargs:\n    #     kwargs[\"show_loading\"] = False\n\n    if isinstance(source, str):\n        if not source.startswith(\"http\"):\n            if source.startswith(\"~\"):\n                source = os.path.expanduser(source)\n            # else:\n            #     source = os.path.abspath(source)\n            # if not os.path.exists(source):\n            #     raise ValueError(\"The source path does not exist.\")\n        else:\n            source = github_raw_url(source)\n    elif isinstance(source, TileClient) or isinstance(\n        source, rasterio.io.DatasetReader\n    ):\n        pass\n\n    else:\n        raise ValueError(\"The source must either be a string or TileClient\")\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    if layer_name is None:\n        if source.startswith(\"http\"):\n            layer_name = \"RemoteTile_\" + random_string(3)\n        else:\n            layer_name = \"LocalTile_\" + random_string(3)\n\n    if isinstance(source, str) or isinstance(source, rasterio.io.DatasetReader):\n        tile_client = TileClient(source, port=port, debug=debug)\n    else:\n        tile_client = source\n\n    if quiet:\n        output = widgets.Output()\n        with output:\n            if tile_format == \"ipyleaflet\":\n                tile_layer = get_leaflet_tile_layer(\n                    tile_client,\n                    port=port,\n                    debug=debug,\n                    indexes=indexes,\n                    colormap=colormap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    nodata=nodata,\n                    attribution=attribution,\n                    name=layer_name,\n                    **kwargs,\n                )\n            else:\n                tile_layer = get_folium_tile_layer(\n                    tile_client,\n                    port=port,\n                    debug=debug,\n                    indexes=indexes,\n                    colormap=colormap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    nodata=nodata,\n                    attr=attribution,\n                    overlay=True,\n                    name=layer_name,\n                    **kwargs,\n                )\n    else:\n        if tile_format == \"ipyleaflet\":\n            tile_layer = get_leaflet_tile_layer(\n                tile_client,\n                port=port,\n                debug=debug,\n                indexes=indexes,\n                colormap=colormap,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attribution=attribution,\n                name=layer_name,\n                **kwargs,\n            )\n        else:\n            tile_layer = get_folium_tile_layer(\n                tile_client,\n                port=port,\n                debug=debug,\n                indexes=indexes,\n                colormap=colormap,\n                vmin=vmin,\n                vmax=vmax,\n                nodata=nodata,\n                attr=attribution,\n                overlay=True,\n                name=layer_name,\n                **kwargs,\n            )\n\n    if return_client:\n        return tile_layer, tile_client\n    else:\n        return tile_layer\n\n    # center = tile_client.center()\n    # bounds = tile_client.bounds()  # [ymin, ymax, xmin, xmax]\n    # bounds = (bounds[2], bounds[0], bounds[3], bounds[1])  # [minx, miny, maxx, maxy]\n\n    # if get_center and get_bounds:\n    #     return tile_layer, center, bounds\n    # elif get_center:\n    #     return tile_layer, center\n    # elif get_bounds:\n    #     return tile_layer, bounds\n    # else:\n    #     return tile_layer\n</code></pre>"},{"location":"common/#geojp.common.get_nhd_basins","title":"<code>get_nhd_basins(feature_ids, fsource='nwissite', split_catchment=False, simplified=True, **kwargs)</code>","text":"<p>Get NHD basins for a list of station IDs.</p> <p>Parameters:</p> Name Type Description Default <code>feature_ids</code> <code>str | list</code> <p>Target feature ID(s).</p> required <code>fsource</code> <code>str</code> <p>The name of feature(s) source, defaults to <code>nwissite</code>. The valid sources are: * 'comid' for NHDPlus comid. * 'ca_gages' for Streamgage catalog for CA SB19 * 'gfv11_pois' for USGS Geospatial Fabric V1.1 Points of Interest * 'huc12pp' for HUC12 Pour Points * 'nmwdi-st' for New Mexico Water Data Initiative Sites * 'nwisgw' for NWIS Groundwater Sites * 'nwissite' for NWIS Surface Water Sites * 'ref_gage' for geoconnex.us reference gauges * 'vigil' for Vigil Network Data * 'wade' for Water Data Exchange 2.0 Sites * 'WQP' for Water Quality Portal</p> <code>'nwissite'</code> <code>split_catchment</code> <code>bool</code> <p>If True, split basins at their outlet locations</p> <code>False</code> <code>simplified</code> <code>bool</code> <p>If True, return a simplified version of basin geometries. Default to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If pynhd is not installed.</p> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>NLDI indexed basins in EPSG:4326. If some IDs don't return any features     a list of missing ID(s) are returned as well.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_nhd_basins(\n    feature_ids,\n    fsource=\"nwissite\",\n    split_catchment=False,\n    simplified=True,\n    **kwargs,\n):\n    \"\"\"Get NHD basins for a list of station IDs.\n\n    Args:\n        feature_ids (str | list): Target feature ID(s).\n        fsource (str, optional): The name of feature(s) source, defaults to ``nwissite``.\n            The valid sources are:\n            * 'comid' for NHDPlus comid.\n            * 'ca_gages' for Streamgage catalog for CA SB19\n            * 'gfv11_pois' for USGS Geospatial Fabric V1.1 Points of Interest\n            * 'huc12pp' for HUC12 Pour Points\n            * 'nmwdi-st' for New Mexico Water Data Initiative Sites\n            * 'nwisgw' for NWIS Groundwater Sites\n            * 'nwissite' for NWIS Surface Water Sites\n            * 'ref_gage' for geoconnex.us reference gauges\n            * 'vigil' for Vigil Network Data\n            * 'wade' for Water Data Exchange 2.0 Sites\n            * 'WQP' for Water Quality Portal\n        split_catchment (bool, optional): If True, split basins at their outlet locations\n        simplified (bool, optional): If True, return a simplified version of basin geometries.\n            Default to True.\n\n    Raises:\n        ImportError: If pynhd is not installed.\n\n    Returns:\n        geopandas.GeoDataFrame: NLDI indexed basins in EPSG:4326. If some IDs don't return any features\n            a list of missing ID(s) are returned as well.\n    \"\"\"\n\n    try:\n        from pynhd import NLDI\n    except ImportError:\n        raise ImportError(\"pynhd is not installed. Install it with pip install pynhd\")\n\n    return NLDI().get_basins(\n        feature_ids, fsource, split_catchment, simplified, **kwargs\n    )\n</code></pre>"},{"location":"common/#geojp.common.get_overlap","title":"<code>get_overlap(img1, img2, overlap, out_img1=None, out_img2=None, to_cog=True)</code>","text":"<p>Get overlapping area of two images.</p> <p>Parameters:</p> Name Type Description Default <code>img1</code> <code>str</code> <p>Path to the first image.</p> required <code>img2</code> <code>str</code> <p>Path to the second image.</p> required <code>overlap</code> <code>str</code> <p>Path to the output overlap area in GeoJSON format.</p> required <code>out_img1</code> <code>str</code> <p>Path to the cropped image of the first image.</p> <code>None</code> <code>out_img2</code> <code>str</code> <p>Path to the cropped image of the second image.</p> <code>None</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the output images to COG.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the overlap area in GeoJSON format.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_overlap(img1, img2, overlap, out_img1=None, out_img2=None, to_cog=True):\n    \"\"\"Get overlapping area of two images.\n\n    Args:\n        img1 (str): Path to the first image.\n        img2 (str): Path to the second image.\n        overlap (str): Path to the output overlap area in GeoJSON format.\n        out_img1 (str, optional): Path to the cropped image of the first image.\n        out_img2 (str, optional): Path to the cropped image of the second image.\n        to_cog (bool, optional): Whether to convert the output images to COG.\n\n    Returns:\n        str: Path to the overlap area in GeoJSON format.\n    \"\"\"\n    import json\n    from osgeo import gdal, ogr, osr\n    import geopandas as gpd\n\n    extent = gdal.Info(img1, format=\"json\")[\"wgs84Extent\"]\n    poly1 = ogr.CreateGeometryFromJson(json.dumps(extent))\n    extent = gdal.Info(img2, format=\"json\")[\"wgs84Extent\"]\n    poly2 = ogr.CreateGeometryFromJson(json.dumps(extent))\n    intersection = poly1.Intersection(poly2)\n    gg = gdal.OpenEx(intersection.ExportToJson())\n    ds = gdal.VectorTranslate(\n        overlap,\n        srcDS=gg,\n        format=\"GeoJSON\",\n        layerCreationOptions=[\"RFC7946=YES\", \"WRITE_BBOX=YES\"],\n    )\n    ds = None\n\n    d = gdal.Open(img1)\n    proj = osr.SpatialReference(wkt=d.GetProjection())\n    epsg = proj.GetAttrValue(\"AUTHORITY\", 1)\n\n    gdf = gpd.read_file(overlap)\n    gdf.to_crs(epsg=epsg, inplace=True)\n    gdf.to_file(overlap)\n\n    if out_img1 is not None:\n        clip_image(img1, overlap, out_img1, to_cog=to_cog)\n\n    if out_img2 is not None:\n        clip_image(img2, overlap, out_img2, to_cog=to_cog)\n\n    return overlap\n</code></pre>"},{"location":"common/#geojp.common.get_palettable","title":"<code>get_palettable(types=None)</code>","text":"<p>Get a list of palettable color palettes.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>list</code> <p>A list of palettable types to return, e.g., types=['matplotlib', 'cartocolors']. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of palettable color palettes.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_palettable(types=None):\n    \"\"\"Get a list of palettable color palettes.\n\n    Args:\n        types (list, optional): A list of palettable types to return, e.g., types=['matplotlib', 'cartocolors']. Defaults to None.\n\n    Returns:\n        list: A list of palettable color palettes.\n    \"\"\"\n    try:\n        import palettable\n    except ImportError:\n        raise ImportError(\n            \"Please install the palettable package using 'pip install palettable'.\"\n        )\n\n    if types is not None and (not isinstance(types, list)):\n        raise ValueError(\"The types must be a list.\")\n\n    allowed_palettes = [\n        \"cartocolors\",\n        \"cmocean\",\n        \"colorbrewer\",\n        \"cubehelix\",\n        \"lightbartlein\",\n        \"matplotlib\",\n        \"mycarta\",\n        \"scientific\",\n        \"tableau\",\n        \"wesanderson\",\n    ]\n\n    if types is None:\n        types = allowed_palettes[:]\n\n    if all(x in allowed_palettes for x in types):\n        pass\n    else:\n        raise ValueError(\n            \"The types must be one of the following: \" + \", \".join(allowed_palettes)\n        )\n\n    palettes = []\n\n    if \"cartocolors\" in types:\n        cartocolors_diverging = [\n            f\"cartocolors.diverging.{c}\"\n            for c in dir(palettable.cartocolors.diverging)[:-19]\n        ]\n        cartocolors_qualitative = [\n            f\"cartocolors.qualitative.{c}\"\n            for c in dir(palettable.cartocolors.qualitative)[:-19]\n        ]\n        cartocolors_sequential = [\n            f\"cartocolors.sequential.{c}\"\n            for c in dir(palettable.cartocolors.sequential)[:-41]\n        ]\n\n        palettes = (\n            palettes\n            + cartocolors_diverging\n            + cartocolors_qualitative\n            + cartocolors_sequential\n        )\n\n    if \"cmocean\" in types:\n        cmocean_diverging = [\n            f\"cmocean.diverging.{c}\" for c in dir(palettable.cmocean.diverging)[:-19]\n        ]\n        cmocean_sequential = [\n            f\"cmocean.sequential.{c}\" for c in dir(palettable.cmocean.sequential)[:-19]\n        ]\n\n        palettes = palettes + cmocean_diverging + cmocean_sequential\n\n    if \"colorbrewer\" in types:\n        colorbrewer_diverging = [\n            f\"colorbrewer.diverging.{c}\"\n            for c in dir(palettable.colorbrewer.diverging)[:-19]\n        ]\n        colorbrewer_qualitative = [\n            f\"colorbrewer.qualitative.{c}\"\n            for c in dir(palettable.colorbrewer.qualitative)[:-19]\n        ]\n        colorbrewer_sequential = [\n            f\"colorbrewer.sequential.{c}\"\n            for c in dir(palettable.colorbrewer.sequential)[:-41]\n        ]\n\n        palettes = (\n            palettes\n            + colorbrewer_diverging\n            + colorbrewer_qualitative\n            + colorbrewer_sequential\n        )\n\n    if \"cubehelix\" in types:\n        cubehelix = [\n            \"classic_16\",\n            \"cubehelix1_16\",\n            \"cubehelix2_16\",\n            \"cubehelix3_16\",\n            \"jim_special_16\",\n            \"perceptual_rainbow_16\",\n            \"purple_16\",\n            \"red_16\",\n        ]\n        cubehelix = [f\"cubehelix.{c}\" for c in cubehelix]\n        palettes = palettes + cubehelix\n\n    if \"lightbartlein\" in types:\n        lightbartlein_diverging = [\n            f\"lightbartlein.diverging.{c}\"\n            for c in dir(palettable.lightbartlein.diverging)[:-19]\n        ]\n        lightbartlein_sequential = [\n            f\"lightbartlein.sequential.{c}\"\n            for c in dir(palettable.lightbartlein.sequential)[:-19]\n        ]\n\n        palettes = palettes + lightbartlein_diverging + lightbartlein_sequential\n\n    if \"matplotlib\" in types:\n        matplotlib_colors = [\n            f\"matplotlib.{c}\" for c in dir(palettable.matplotlib)[:-16]\n        ]\n        palettes = palettes + matplotlib_colors\n\n    if \"mycarta\" in types:\n        mycarta = [f\"mycarta.{c}\" for c in dir(palettable.mycarta)[:-16]]\n        palettes = palettes + mycarta\n\n    if \"scientific\" in types:\n        scientific_diverging = [\n            f\"scientific.diverging.{c}\"\n            for c in dir(palettable.scientific.diverging)[:-19]\n        ]\n        scientific_sequential = [\n            f\"scientific.sequential.{c}\"\n            for c in dir(palettable.scientific.sequential)[:-19]\n        ]\n\n        palettes = palettes + scientific_diverging + scientific_sequential\n\n    if \"tableau\" in types:\n        tableau = [f\"tableau.{c}\" for c in dir(palettable.tableau)[:-14]]\n        palettes = palettes + tableau\n\n    return palettes\n</code></pre>"},{"location":"common/#geojp.common.get_palette_colors","title":"<code>get_palette_colors(cmap_name=None, n_class=None, hashtag=False)</code>","text":"<p>Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.</p> <p>Parameters:</p> Name Type Description Default <code>cmap_name</code> <code>str</code> <p>The name of the matplotlib colormap. Defaults to None.</p> <code>None</code> <code>n_class</code> <code>int</code> <p>The number of colors. Defaults to None.</p> <code>None</code> <code>hashtag</code> <code>bool</code> <p>Whether to return a list of hex colors. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of hex colors.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_palette_colors(cmap_name=None, n_class=None, hashtag=False):\n    \"\"\"Get a palette from a matplotlib colormap. See the list of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.\n\n    Args:\n        cmap_name (str, optional): The name of the matplotlib colormap. Defaults to None.\n        n_class (int, optional): The number of colors. Defaults to None.\n        hashtag (bool, optional): Whether to return a list of hex colors. Defaults to False.\n\n    Returns:\n        list: A list of hex colors.\n    \"\"\"\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n\n    cmap = plt.cm.get_cmap(cmap_name, n_class)\n    colors = [mpl.colors.rgb2hex(cmap(i))[1:] for i in range(cmap.N)]\n    if hashtag:\n        colors = [\"#\" + i for i in colors]\n    return colors\n</code></pre>"},{"location":"common/#geojp.common.get_solar_data","title":"<code>get_solar_data(lat, lon, radiusMeters=50, view='FULL_LAYERS', requiredQuality='HIGH', pixelSizeMeters=0.1, api_key=None, header=None, out_dir=None, basename=None, quiet=False, **kwargs)</code>","text":"<p>Retrieve solar data for a specific location from Google's Solar API https://developers.google.com/maps/documentation/solar. You need to enable Solar API from https://console.cloud.google.com/google/maps-apis/api-list.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude of the location.</p> required <code>lon</code> <code>float</code> <p>Longitude of the location.</p> required <code>radiusMeters</code> <code>int</code> <p>Radius in meters for the data retrieval (default is 50).</p> <code>50</code> <code>view</code> <code>str</code> <p>View type (default is \"FULL_LAYERS\"). For more options, see https://bit.ly/3LazuBi.</p> <code>'FULL_LAYERS'</code> <code>requiredQuality</code> <code>str</code> <p>Required quality level (default is \"HIGH\").</p> <code>'HIGH'</code> <code>pixelSizeMeters</code> <code>float</code> <p>Pixel size in meters (default is 0.1).</p> <code>0.1</code> <code>api_key</code> <code>str</code> <p>Google API key for authentication (if not provided, checks 'GOOGLE_API_KEY' environment variable).</p> <code>None</code> <code>header</code> <code>dict</code> <p>Additional HTTP headers to include in the request.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>Directory where downloaded files will be saved.</p> <code>None</code> <code>basename</code> <code>str</code> <p>Base name for the downloaded files (default is generated from imagery date).</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>If True, suppress progress messages during file downloads (default is False).</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the download_file function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>A dictionary mapping file names to their corresponding paths.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_solar_data(\n    lat: float,\n    lon: float,\n    radiusMeters: int = 50,\n    view: str = \"FULL_LAYERS\",\n    requiredQuality: str = \"HIGH\",\n    pixelSizeMeters: float = 0.1,\n    api_key: Optional[str] = None,\n    header: Optional[Dict[str, str]] = None,\n    out_dir: Optional[str] = None,\n    basename: Optional[str] = None,\n    quiet: bool = False,\n    **kwargs: Any,\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Retrieve solar data for a specific location from Google's Solar API https://developers.google.com/maps/documentation/solar.\n    You need to enable Solar API from https://console.cloud.google.com/google/maps-apis/api-list.\n\n    Args:\n        lat (float): Latitude of the location.\n        lon (float): Longitude of the location.\n        radiusMeters (int, optional): Radius in meters for the data retrieval (default is 50).\n        view (str, optional): View type (default is \"FULL_LAYERS\"). For more options, see https://bit.ly/3LazuBi.\n        requiredQuality (str, optional): Required quality level (default is \"HIGH\").\n        pixelSizeMeters (float, optional): Pixel size in meters (default is 0.1).\n        api_key (str, optional): Google API key for authentication (if not provided, checks 'GOOGLE_API_KEY' environment variable).\n        header (dict, optional): Additional HTTP headers to include in the request.\n        out_dir (str, optional): Directory where downloaded files will be saved.\n        basename (str, optional): Base name for the downloaded files (default is generated from imagery date).\n        quiet (bool, optional): If True, suppress progress messages during file downloads (default is False).\n        **kwargs: Additional keyword arguments to be passed to the download_file function.\n\n    Returns:\n        Dict[str, str]: A dictionary mapping file names to their corresponding paths.\n    \"\"\"\n\n    if api_key is None:\n        api_key = os.environ.get(\"GOOGLE_API_KEY\", \"\")\n\n    if api_key == \"\":\n        raise ValueError(\"GOOGLE_API_KEY is required to use this function.\")\n\n    url = \"https://solar.googleapis.com/v1/dataLayers:get\"\n    params = {\n        \"location.latitude\": lat,\n        \"location.longitude\": lon,\n        \"radiusMeters\": radiusMeters,\n        \"view\": view,\n        \"requiredQuality\": requiredQuality,\n        \"pixelSizeMeters\": pixelSizeMeters,\n        \"key\": api_key,\n    }\n\n    solar_data = requests.get(url, params=params, headers=header).json()\n\n    links = {}\n\n    for key in solar_data.keys():\n        if \"Url\" in key:\n            if isinstance(solar_data[key], list):\n                urls = [url + \"&amp;key=\" + api_key for url in solar_data[key]]\n                links[key] = urls\n            else:\n                links[key] = solar_data[key] + \"&amp;key=\" + api_key\n\n    if basename is None:\n        date = solar_data[\"imageryDate\"]\n        year = date[\"year\"]\n        month = date[\"month\"]\n        day = date[\"day\"]\n        basename = f\"{year}_{str(month).zfill(2)}_{str(day).zfill(2)}\"\n\n    filenames = {}\n\n    for link in links:\n        if isinstance(links[link], list):\n            for i, url in enumerate(links[link]):\n                filename = (\n                    f\"{basename}_{link.replace('Urls', '')}_{str(i+1).zfill(2)}.tif\"\n                )\n                if out_dir is not None:\n                    filename = os.path.join(out_dir, filename)\n                download_file(url, filename, quiet=quiet, **kwargs)\n                filenames[link.replace(\"Urls\", \"\") + \"_\" + str(i).zfill(2)] = filename\n        else:\n            name = link.replace(\"Url\", \"\")\n            filename = f\"{basename}_{name}.tif\"\n            if out_dir is not None:\n                filename = os.path.join(out_dir, filename)\n            download_file(links[link], filename, quiet=quiet, **kwargs)\n            filenames[name] = filename\n\n    return filenames\n</code></pre>"},{"location":"common/#geojp.common.get_stac_collections","title":"<code>get_stac_collections(url, **kwargs)</code>","text":"<p>Retrieve a list of STAC collections from a URL. This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L31. Credits to Mykola Kozyr.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A URL to a STAC catalog.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the pystac Client.open() method. See https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.open</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of STAC collections.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_stac_collections(url, **kwargs):\n    \"\"\"Retrieve a list of STAC collections from a URL.\n    This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L31.\n    Credits to Mykola Kozyr.\n\n    Args:\n        url (str): A URL to a STAC catalog.\n        **kwargs: Additional keyword arguments to pass to the pystac Client.open() method.\n            See https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.open\n\n    Returns:\n        list: A list of STAC collections.\n    \"\"\"\n    from pystac_client import Client\n\n    # Expensive function. Added cache for it.\n\n    # Empty list that would be used for a dataframe to collect and visualize info about collections\n    root_catalog = Client.open(url, **kwargs)\n    collections_list = []\n    # Reading collections in the Catalog\n    collections = list(root_catalog.get_collections())\n    print(collections)\n    for collection in collections:\n        id = collection.id\n        title = collection.title\n        # bbox = collection.extent.spatial.bboxes # not in use for the first release\n        # interval = collection.extent.temporal.intervals # not in use for the first release\n        description = collection.description\n\n        # creating a list of lists of values\n        collections_list.append([id, title, description])\n    return collections_list\n</code></pre>"},{"location":"common/#geojp.common.get_stac_items","title":"<code>get_stac_items(url, collection, limit=None, bbox=None, datetime=None, intersects=None, ids=None, open_args=None, **kwargs)</code>","text":"<p>Retrieve a list of STAC items from a URL and a collection. This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L49. Credits to Mykola Kozyr. Available parameters can be found at https://github.com/radiantearth/stac-api-spec/tree/master/item-search</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A URL to a STAC catalog.</p> required <code>collection</code> <code>str</code> <p>A STAC collection ID.</p> required <code>limit</code> <code>int</code> <p>The maximum number of results to return (page size). Defaults to None.</p> <code>None</code> <code>bbox</code> <code>tuple</code> <p>Requested bounding box in the format of (minx, miny, maxx, maxy). Defaults to None.</p> <code>None</code> <code>datetime</code> <code>str</code> <p>Single date+time, or a range ('/' separator), formatted to RFC 3339, section 5.6. Use double dots .. for open date ranges.</p> <code>None</code> <code>intersects</code> <code>dict</code> <p>A dictionary representing a GeoJSON Geometry. Searches items by performing intersection between their geometry and provided GeoJSON geometry. All GeoJSON geometry types must be supported.</p> <code>None</code> <code>ids</code> <code>list</code> <p>A list of item ids to return.</p> <code>None</code> <code>open_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the pystac Client.open() method. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Catalog.search() method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoPandas.GeoDataFraem</code> <p>A GeoDataFrame with the STAC items.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_stac_items(\n    url,\n    collection,\n    limit=None,\n    bbox=None,\n    datetime=None,\n    intersects=None,\n    ids=None,\n    open_args=None,\n    **kwargs,\n):\n    \"\"\"Retrieve a list of STAC items from a URL and a collection.\n    This function is adapted from https://github.com/mykolakozyr/stacdiscovery/blob/a5d1029aec9c428a7ce7ae615621ea8915162824/app.py#L49.\n    Credits to Mykola Kozyr.\n    Available parameters can be found at https://github.com/radiantearth/stac-api-spec/tree/master/item-search\n\n    Args:\n        url (str): A URL to a STAC catalog.\n        collection (str): A STAC collection ID.\n        limit (int, optional): The maximum number of results to return (page size). Defaults to None.\n        bbox (tuple, optional): Requested bounding box in the format of (minx, miny, maxx, maxy). Defaults to None.\n        datetime (str, optional): Single date+time, or a range ('/' separator), formatted to RFC 3339, section 5.6. Use double dots .. for open date ranges.\n        intersects (dict, optional): A dictionary representing a GeoJSON Geometry. Searches items by performing intersection between their geometry and provided GeoJSON geometry. All GeoJSON geometry types must be supported.\n        ids (list, optional): A list of item ids to return.\n        open_args (dict, optional): A dictionary of arguments to pass to the pystac Client.open() method. Defaults to None.\n        **kwargs: Additional keyword arguments to pass to the Catalog.search() method.\n\n    Returns:\n        GeoPandas.GeoDataFraem: A GeoDataFrame with the STAC items.\n    \"\"\"\n\n    import itertools\n    import geopandas as gpd\n    from shapely.geometry import shape\n    from pystac_client import Client\n\n    # Empty list that would be used for a dataframe to collect and visualize info about collections\n    items_list = []\n\n    if open_args is None:\n        open_args = {}\n\n    root_catalog = Client.open(url)\n\n    if limit:\n        kwargs[\"limit\"] = limit\n    if bbox:\n        kwargs[\"bbox\"] = bbox\n    if datetime:\n        kwargs[\"datetime\"] = datetime\n    if intersects:\n        kwargs[\"intersects\"] = intersects\n    if ids:\n        kwargs[\"ids\"] = ids\n\n    if kwargs:\n        try:\n            catalog = root_catalog.search(collections=collection, **kwargs)\n        except NotImplementedError:\n            catalog = root_catalog\n    else:\n        catalog = root_catalog\n\n    iterable = catalog.get_all_items()\n    items = list(\n        itertools.islice(iterable, limit)\n    )  # getting first 25000 items. To Do some smarter logic\n    if len(items) == 0:\n        try:\n            catalog = root_catalog.get_child(collection)\n            iterable = catalog.get_all_items()\n            items = list(itertools.islice(iterable, limit))\n        except Exception as _:\n            print(\"Ooops, it looks like this collection does not have items.\")\n            return None\n    # Iterating over items to collect main information\n    for item in items:\n        id = item.id\n        geometry = shape(item.geometry)\n        datetime = (\n            item.datetime\n            or item.properties[\"datetime\"]\n            or item.properties[\"end_datetime\"]\n            or item.properties[\"start_datetime\"]\n        )\n        links = item.links\n        for link in links:\n            if link.rel == \"self\":\n                self_url = link.target\n        assets_list = []\n        assets = item.assets\n        for asset in assets:\n            assets_list.append(asset)\n\n        # creating a list of lists of values\n        items_list.append([id, geometry, datetime, self_url, assets_list])\n\n    if limit is not None:\n        items_list = items_list[:limit]\n    items_df = gpd.GeoDataFrame(items_list)\n    items_df.columns = [\"id\", \"geometry\", \"datetime\", \"self_url\", \"assets_list\"]\n\n    items_gdf = items_df.set_geometry(\"geometry\")\n    items_gdf[\"datetime\"] = items_gdf[\"datetime\"].astype(\n        str\n    )  # specifically for KeplerGL. See https://github.com/keplergl/kepler.gl/issues/602\n    # items_gdf[\"assets_list\"] = items_gdf[\"assets_list\"].astype(str) #specifically for KeplerGL. See https://github.com/keplergl/kepler.gl/issues/602\n    items_gdf.set_crs(epsg=4326, inplace=True)\n    return items_gdf\n</code></pre>"},{"location":"common/#geojp.common.get_wms_layers","title":"<code>get_wms_layers(url)</code>","text":"<p>Returns a list of WMS layers from a WMS service.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the WMS service.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of WMS layers.</p> Source code in <code>geojp/common.py</code> <pre><code>def get_wms_layers(url):\n    \"\"\"Returns a list of WMS layers from a WMS service.\n\n    Args:\n        url (str): The URL of the WMS service.\n\n    Returns:\n        list: A list of WMS layers.\n    \"\"\"\n    try:\n        from owslib.wms import WebMapService\n    except ImportError:\n        raise ImportError(\"Please install owslib using 'pip install owslib'.\")\n\n    wms = WebMapService(url)\n    layers = list(wms.contents)\n    layers.sort()\n    return layers\n</code></pre>"},{"location":"common/#geojp.common.gif_fading","title":"<code>gif_fading(in_gif, out_gif, duration=1, verbose=True)</code>","text":"<p>Fade in/out the gif.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"</p> required <code>out_gif</code> <code>str</code> <p>The output gif file.</p> required <code>duration</code> <code>float</code> <p>The duration of the fading. Defaults to 1.</p> <code>1</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>Raise exception when the input gif does not exist.</p> <code>Exception</code> <p>Raise exception when ffmpeg is not installed.</p> Source code in <code>geojp/common.py</code> <pre><code>def gif_fading(in_gif, out_gif, duration=1, verbose=True):\n    \"\"\"Fade in/out the gif.\n\n    Args:\n        in_gif (str): The input gif file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"\n        out_gif (str): The output gif file.\n        duration (float, optional): The duration of the fading. Defaults to 1.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n\n    Raises:\n        FileNotFoundError: Raise exception when the input gif does not exist.\n        Exception: Raise exception when ffmpeg is not installed.\n    \"\"\"\n    import glob\n    import tempfile\n\n    current_dir = os.getcwd()\n\n    if isinstance(in_gif, str) and in_gif.startswith(\"http\"):\n        ext = os.path.splitext(in_gif)[1]\n        file_path = temp_file_path(ext)\n        download_from_url(in_gif, file_path, verbose=verbose)\n        in_gif = file_path\n\n    in_gif = os.path.abspath(in_gif)\n    if not in_gif.endswith(\".gif\"):\n        raise Exception(\"in_gif must be a gif file.\")\n\n    if \" \" in in_gif:\n        raise Exception(\"The filename cannot contain spaces.\")\n\n    out_gif = os.path.abspath(out_gif)\n    if not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    basename = os.path.basename(in_gif).replace(\".gif\", \"\")\n    temp_dir = os.path.join(tempfile.gettempdir(), basename)\n    if os.path.exists(temp_dir):\n        shutil.rmtree(temp_dir)\n\n    gif_to_png(in_gif, temp_dir, verbose=verbose)\n\n    os.chdir(temp_dir)\n\n    images = list(glob.glob(os.path.join(temp_dir, \"*.png\")))\n    count = len(images)\n\n    files = []\n    for i in range(1, count + 1):\n        files.append(f\"-loop 1 -t {duration} -i {i}.png\")\n    inputs = \" \".join(files)\n\n    filters = []\n    for i in range(1, count):\n        if i == 1:\n            filters.append(\n                f\"\\\"[1:v][0:v]blend=all_expr='A*(if(gte(T,3),1,T/3))+B*(1-(if(gte(T,3),1,T/3)))'[v0];\"\n            )\n        else:\n            filters.append(\n                f\"[{i}:v][{i-1}:v]blend=all_expr='A*(if(gte(T,3),1,T/3))+B*(1-(if(gte(T,3),1,T/3)))'[v{i-1}];\"\n            )\n\n    last_filter = \"\"\n    for i in range(count - 1):\n        last_filter += f\"[v{i}]\"\n    last_filter += f'concat=n={count-1}:v=1:a=0[v]\" -map \"[v]\"'\n    filters.append(last_filter)\n    filters = \" \".join(filters)\n\n    cmd = f\"ffmpeg -y -loglevel error {inputs} -filter_complex {filters} {out_gif}\"\n\n    os.system(cmd)\n    try:\n        shutil.rmtree(temp_dir)\n    except Exception as e:\n        print(e)\n\n    os.chdir(current_dir)\n</code></pre>"},{"location":"common/#geojp.common.gif_to_mp4","title":"<code>gif_to_mp4(in_gif, out_mp4)</code>","text":"<p>Converts a gif to mp4.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file.</p> required <code>out_mp4</code> <code>str</code> <p>The output mp4 file.</p> required Source code in <code>geojp/common.py</code> <pre><code>def gif_to_mp4(in_gif, out_mp4):\n    \"\"\"Converts a gif to mp4.\n\n    Args:\n        in_gif (str): The input gif file.\n        out_mp4 (str): The output mp4 file.\n    \"\"\"\n    from PIL import Image\n\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    out_mp4 = os.path.abspath(out_mp4)\n    if not out_mp4.endswith(\".mp4\"):\n        out_mp4 = out_mp4 + \".mp4\"\n\n    if not os.path.exists(os.path.dirname(out_mp4)):\n        os.makedirs(os.path.dirname(out_mp4))\n\n    if not is_tool(\"ffmpeg\"):\n        print(\"ffmpeg is not installed on your computer.\")\n        return\n\n    width, height = Image.open(in_gif).size\n\n    if width % 2 == 0 and height % 2 == 0:\n        cmd = f\"ffmpeg -loglevel error -i {in_gif} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n        os.system(cmd)\n    else:\n        width += width % 2\n        height += height % 2\n        cmd = f\"ffmpeg -loglevel error -i {in_gif} -vf scale={width}:{height} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n        os.system(cmd)\n\n    if not os.path.exists(out_mp4):\n        raise Exception(f\"Failed to create mp4 file.\")\n</code></pre>"},{"location":"common/#geojp.common.gif_to_png","title":"<code>gif_to_png(in_gif, out_dir=None, prefix='', verbose=True)</code>","text":"<p>Converts a gif to png.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input gif file.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>The prefix of the output png files. Defaults to None.</p> <code>''</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>Raise exception when the input gif does not exist.</p> <code>Exception</code> <p>Raise exception when ffmpeg is not installed.</p> Source code in <code>geojp/common.py</code> <pre><code>def gif_to_png(in_gif, out_dir=None, prefix=\"\", verbose=True):\n    \"\"\"Converts a gif to png.\n\n    Args:\n        in_gif (str): The input gif file.\n        out_dir (str, optional): The output directory. Defaults to None.\n        prefix (str, optional): The prefix of the output png files. Defaults to None.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n\n    Raises:\n        FileNotFoundError: Raise exception when the input gif does not exist.\n        Exception: Raise exception when ffmpeg is not installed.\n    \"\"\"\n    import tempfile\n\n    in_gif = os.path.abspath(in_gif)\n    if \" \" in in_gif:\n        raise Exception(\"in_gif cannot contain spaces.\")\n    if not os.path.exists(in_gif):\n        raise FileNotFoundError(f\"{in_gif} does not exist.\")\n\n    basename = os.path.basename(in_gif).replace(\".gif\", \"\")\n    if out_dir is None:\n        out_dir = os.path.join(tempfile.gettempdir(), basename)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n    elif isinstance(out_dir, str) and not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n    elif not isinstance(out_dir, str):\n        raise Exception(\"out_dir must be a string.\")\n\n    out_dir = os.path.abspath(out_dir)\n    cmd = f\"ffmpeg -loglevel error -i {in_gif} -vsync 0 {out_dir}/{prefix}%d.png\"\n    os.system(cmd)\n\n    if verbose:\n        print(f\"Images are saved to {out_dir}\")\n</code></pre>"},{"location":"common/#geojp.common.github_raw_url","title":"<code>github_raw_url(url)</code>","text":"<p>Get the raw URL for a GitHub file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The GitHub URL.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The raw URL.</p> Source code in <code>geojp/common.py</code> <pre><code>def github_raw_url(url):\n    \"\"\"Get the raw URL for a GitHub file.\n\n    Args:\n        url (str): The GitHub URL.\n    Returns:\n        str: The raw URL.\n    \"\"\"\n    if isinstance(url, str) and url.startswith(\"https://github.com/\") and \"blob\" in url:\n        url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\"\n        )\n    return url\n</code></pre>"},{"location":"common/#geojp.common.google_buildings_csv_to_vector","title":"<code>google_buildings_csv_to_vector(filename, output=None, **kwargs)</code>","text":"<p>Convert a CSV file containing Google Buildings data to a GeoJSON vector file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the input CSV file.</p> required <code>output</code> <code>str</code> <p>The path to the output GeoJSON file. If not provided, the output file will have the same name as the input file with the extension changed to '.geojson'.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments that are passed to the <code>to_file</code> method of the GeoDataFrame.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>geojp/common.py</code> <pre><code>def google_buildings_csv_to_vector(\n    filename: str, output: Optional[str] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Convert a CSV file containing Google Buildings data to a GeoJSON vector file.\n\n    Args:\n        filename (str): The path to the input CSV file.\n        output (str, optional): The path to the output GeoJSON file. If not provided, the output file will have the same\n            name as the input file with the extension changed to '.geojson'.\n        **kwargs: Additional keyword arguments that are passed to the `to_file` method of the GeoDataFrame.\n\n    Returns:\n        None\n    \"\"\"\n    import pandas as pd\n    import geopandas as gpd\n    from shapely import wkt\n\n    df = pd.read_csv(filename)\n\n    # Create a geometry column from the \"geometry\" column in the DataFrame\n    df[\"geometry\"] = df[\"geometry\"].apply(wkt.loads)\n\n    # Convert the pandas DataFrame to a GeoDataFrame\n    gdf = gpd.GeoDataFrame(df, geometry=\"geometry\")\n    gdf.crs = \"EPSG:4326\"\n\n    if output is None:\n        output = os.path.splitext(filename)[0] + \".geojson\"\n\n    gdf.to_file(output, **kwargs)\n</code></pre>"},{"location":"common/#geojp.common.h5_keys","title":"<code>h5_keys(filename)</code>","text":"<p>Retrieve the keys (dataset names) within an HDF5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the HDF5 file.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of dataset names present in the HDF5 file.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if h5py is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; keys = h5_keys('data.h5')\n&gt;&gt;&gt; print(keys)\n[\n</code></pre> Source code in <code>geojp/common.py</code> <pre><code>def h5_keys(filename: str) -&gt; List[str]:\n    \"\"\"\n    Retrieve the keys (dataset names) within an HDF5 file.\n\n    Args:\n        filename (str): The filename of the HDF5 file.\n\n    Returns:\n        List[str]: A list of dataset names present in the HDF5 file.\n\n    Raises:\n        ImportError: Raised if h5py is not installed.\n\n    Example:\n        &gt;&gt;&gt; keys = h5_keys('data.h5')\n        &gt;&gt;&gt; print(keys)\n        [\n    \"\"\"\n    try:\n        import h5py\n    except ImportError:\n        raise ImportError(\n            \"h5py must be installed to use this function. Please install it with 'pip install h5py'.\"\n        )\n\n    with h5py.File(filename, \"r\") as f:\n        keys = list(f.keys())\n\n    return keys\n</code></pre>"},{"location":"common/#geojp.common.h5_to_gdf","title":"<code>h5_to_gdf(filenames, dataset, lat='lat_lowestmode', lon='lon_lowestmode', columns=None, crs='EPSG:4326', nodata=None, **kwargs)</code>","text":"<p>Read data from one or multiple HDF5 files and return as a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>filenames</code> <code>str or List[str]</code> <p>The filename(s) of the HDF5 file(s).</p> required <code>dataset</code> <code>str</code> <p>The dataset name within the H5 file(s).</p> required <code>lat</code> <code>str</code> <p>The column name representing latitude. Default is 'lat_lowestmode'.</p> <code>'lat_lowestmode'</code> <code>lon</code> <code>str</code> <p>The column name representing longitude. Default is 'lon_lowestmode'.</p> <code>'lon_lowestmode'</code> <code>columns</code> <code>List[str]</code> <p>List of column names to include. If None, all columns will be included. Default is None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system code. Default is \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the GeoDataFrame constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A GeoDataFrame containing the data from the H5 file(s).</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if h5py is not installed.</p> <code>ValueError</code> <p>Raised if the provided filenames argument is not a valid type or if a specified file does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = h5_to_gdf('data.h5', 'dataset1', 'lat', 'lon', columns=['column1', 'column2'], crs='EPSG:4326')\n&gt;&gt;&gt; print(gdf.head())\n   column1  column2        lat        lon                    geometry\n0        10       20  40.123456 -75.987654  POINT (-75.987654 40.123456)\n1        15       25  40.234567 -75.876543  POINT (-75.876543 40.234567)\n...\n</code></pre> Source code in <code>geojp/common.py</code> <pre><code>def h5_to_gdf(\n    filenames: str,\n    dataset: str,\n    lat: str = \"lat_lowestmode\",\n    lon: str = \"lon_lowestmode\",\n    columns: Optional[List[str]] = None,\n    crs: str = \"EPSG:4326\",\n    nodata=None,\n    **kwargs,\n):\n    \"\"\"\n    Read data from one or multiple HDF5 files and return as a GeoDataFrame.\n\n    Args:\n        filenames (str or List[str]): The filename(s) of the HDF5 file(s).\n        dataset (str): The dataset name within the H5 file(s).\n        lat (str): The column name representing latitude. Default is 'lat_lowestmode'.\n        lon (str): The column name representing longitude. Default is 'lon_lowestmode'.\n        columns (List[str], optional): List of column names to include. If None, all columns will be included. Default is None.\n        crs (str, optional): The coordinate reference system code. Default is \"EPSG:4326\".\n        **kwargs: Additional keyword arguments to be passed to the GeoDataFrame constructor.\n\n    Returns:\n        geopandas.GeoDataFrame: A GeoDataFrame containing the data from the H5 file(s).\n\n    Raises:\n        ImportError: Raised if h5py is not installed.\n        ValueError: Raised if the provided filenames argument is not a valid type or if a specified file does not exist.\n\n    Example:\n        &gt;&gt;&gt; gdf = h5_to_gdf('data.h5', 'dataset1', 'lat', 'lon', columns=['column1', 'column2'], crs='EPSG:4326')\n        &gt;&gt;&gt; print(gdf.head())\n           column1  column2        lat        lon                    geometry\n        0        10       20  40.123456 -75.987654  POINT (-75.987654 40.123456)\n        1        15       25  40.234567 -75.876543  POINT (-75.876543 40.234567)\n        ...\n\n    \"\"\"\n    try:\n        import h5py\n    except ImportError:\n        install_package(\"h5py\")\n        import h5py\n\n    import glob\n    import pandas as pd\n    import geopandas as gpd\n\n    if isinstance(filenames, str):\n        if os.path.exists(filenames):\n            files = [filenames]\n        else:\n            files = glob.glob(filenames)\n            if not files:\n                raise ValueError(f\"File {filenames} does not exist.\")\n            files.sort()\n    elif isinstance(filenames, list):\n        files = filenames\n    else:\n        raise ValueError(\"h5_file must be a string or a list of strings.\")\n\n    out_df = pd.DataFrame()\n\n    for file in files:\n        h5 = h5py.File(file, \"r\")\n        try:\n            data = h5[dataset]\n        except KeyError:\n            print(f\"Dataset {dataset} not found in file {file}. Skipping...\")\n            continue\n        col_names = []\n        col_val = []\n\n        for key, value in data.items():\n            if columns is None or key in columns or key == lat or key == lon:\n                col_names.append(key)\n                col_val.append(value[:].tolist())\n\n        df = pd.DataFrame(map(list, zip(*col_val)), columns=col_names)\n        out_df = pd.concat([out_df, df])\n        h5.close()\n\n    if nodata is not None and columns is not None:\n        out_df = out_df[out_df[columns[0]] != nodata]\n\n    gdf = gpd.GeoDataFrame(\n        out_df, geometry=gpd.points_from_xy(out_df[lon], out_df[lat]), crs=crs, **kwargs\n    )\n\n    return gdf\n</code></pre>"},{"location":"common/#geojp.common.h5_variables","title":"<code>h5_variables(filename, key)</code>","text":"<p>Retrieve the variables (column names) within a specific key (dataset) in an H5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the H5 file.</p> required <code>key</code> <code>str</code> <p>The key (dataset name) within the H5 file.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of variable names (column names) within the specified key.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if h5py is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; variables = h5_variables('data.h5', 'dataset1')\n&gt;&gt;&gt; print(variables)\n['var1', 'var2', 'var3']\n</code></pre> Source code in <code>geojp/common.py</code> <pre><code>def h5_variables(filename: str, key: str) -&gt; List[str]:\n    \"\"\"\n    Retrieve the variables (column names) within a specific key (dataset) in an H5 file.\n\n    Args:\n        filename (str): The filename of the H5 file.\n        key (str): The key (dataset name) within the H5 file.\n\n    Returns:\n        List[str]: A list of variable names (column names) within the specified key.\n\n    Raises:\n        ImportError: Raised if h5py is not installed.\n\n    Example:\n        &gt;&gt;&gt; variables = h5_variables('data.h5', 'dataset1')\n        &gt;&gt;&gt; print(variables)\n        ['var1', 'var2', 'var3']\n    \"\"\"\n    try:\n        import h5py\n    except ImportError:\n        raise ImportError(\n            \"h5py must be installed to use this function. Please install it with 'pip install h5py'.\"\n        )\n\n    with h5py.File(filename, \"r\") as f:\n        cols = list(f[key].keys())\n\n    return cols\n</code></pre>"},{"location":"common/#geojp.common.has_transparency","title":"<code>has_transparency(img)</code>","text":"<p>Checks whether an image has transparency.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>object</code> <p>a PIL Image object.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it has transparency, False otherwise.</p> Source code in <code>geojp/common.py</code> <pre><code>def has_transparency(img) -&gt; bool:\n    \"\"\"Checks whether an image has transparency.\n\n    Args:\n        img (object):  a PIL Image object.\n\n    Returns:\n        bool: True if it has transparency, False otherwise.\n    \"\"\"\n\n    if img.mode == \"P\":\n        transparent = img.info.get(\"transparency\", -1)\n        for _, index in img.getcolors():\n            if index == transparent:\n                return True\n    elif img.mode == \"RGBA\":\n        extrema = img.getextrema()\n        if extrema[3][0] &lt; 255:\n            return True\n\n    return False\n</code></pre>"},{"location":"common/#geojp.common.hex_to_rgb","title":"<code>hex_to_rgb(value='FFFFFF')</code>","text":"<p>Converts hex color to RGB color.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Hex color code as a string. Defaults to 'FFFFFF'.</p> <code>'FFFFFF'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>RGB color as a tuple.</p> Source code in <code>geojp/common.py</code> <pre><code>def hex_to_rgb(value: Optional[str] = \"FFFFFF\") -&gt; Tuple[int, int, int]:\n    \"\"\"Converts hex color to RGB color.\n\n    Args:\n        value (str, optional): Hex color code as a string. Defaults to 'FFFFFF'.\n\n    Returns:\n        tuple: RGB color as a tuple.\n    \"\"\"\n    value = value.lstrip(\"#\")\n    lv = len(value)\n    return tuple(int(value[i : i + lv // 3], 16) for i in range(0, lv, lv // 3))\n</code></pre>"},{"location":"common/#geojp.common.html_to_gradio","title":"<code>html_to_gradio(html, width='100%', height='500px', **kwargs)</code>","text":"<p>Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as     attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>The width of the map. Defaults to '100%'.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>The height of the map. Defaults to '500px'.</p> <code>'500px'</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML string to use in Gradio.</p> Source code in <code>geojp/common.py</code> <pre><code>def html_to_gradio(html, width=\"100%\", height=\"500px\", **kwargs):\n    \"\"\"Converts the map to an HTML string that can be used in Gradio. Removes unsupported elements, such as\n        attribution and any code blocks containing functions. See https://github.com/gradio-app/gradio/issues/3190\n\n    Args:\n        width (str, optional): The width of the map. Defaults to '100%'.\n        height (str, optional): The height of the map. Defaults to '500px'.\n\n    Returns:\n        str: The HTML string to use in Gradio.\n    \"\"\"\n\n    if isinstance(width, int):\n        width = f\"{width}px\"\n\n    if isinstance(height, int):\n        height = f\"{height}px\"\n\n    if isinstance(html, str):\n        with open(html, \"r\") as f:\n            lines = f.readlines()\n    elif isinstance(html, list):\n        lines = html\n    else:\n        raise TypeError(\"html must be a file path or a list of strings\")\n\n    output = []\n    skipped_lines = []\n    for index, line in enumerate(lines):\n        if index in skipped_lines:\n            continue\n        if line.lstrip().startswith('{\"attribution\":'):\n            continue\n        elif \"on(L.Draw.Event.CREATED, function(e)\" in line:\n            for i in range(14):\n                skipped_lines.append(index + i)\n        elif \"L.Control.geocoder\" in line:\n            for i in range(5):\n                skipped_lines.append(index + i)\n        elif \"function(e)\" in line:\n            print(\n                f\"Warning: The folium plotting backend does not support functions in code blocks. Please delete line {index + 1}.\"\n            )\n        else:\n            output.append(line + \"\\n\")\n\n    return f\"\"\"&lt;iframe style=\"width: {width}; height: {height}\" name=\"result\" allow=\"midi; geolocation; microphone; camera;\n    display-capture; encrypted-media;\" sandbox=\"allow-modals allow-forms\n    allow-scripts allow-same-origin allow-popups\n    allow-top-navigation-by-user-activation allow-downloads\" allowfullscreen=\"\"\n    allowpaymentrequest=\"\" frameborder=\"0\" srcdoc='{\"\".join(output)}'&gt;&lt;/iframe&gt;\"\"\"\n</code></pre>"},{"location":"common/#geojp.common.html_to_streamlit","title":"<code>html_to_streamlit(filename, width=None, height=None, scrolling=False, replace_dict={})</code>","text":"<p>Renders an HTML file as a Streamlit component.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the HTML file.</p> required <code>width</code> <code>int</code> <p>Width of the map. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the map. Defaults to 600.</p> <code>None</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow the map to scroll. Defaults to False.</p> <code>False</code> <code>replace_dict</code> <code>dict</code> <p>A dictionary of strings to replace in the HTML file. Defaults to {}.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the filename does not exist.</p> <p>Returns:</p> Type Description <code>streamlit.components</code> <p>components.html object.</p> Source code in <code>geojp/common.py</code> <pre><code>def html_to_streamlit(\n    filename, width=None, height=None, scrolling=False, replace_dict={}\n):\n    \"\"\"Renders an HTML file as a Streamlit component.\n    Args:\n        filename (str): The filename of the HTML file.\n        width (int, optional): Width of the map. Defaults to None.\n        height (int, optional): Height of the map. Defaults to 600.\n        scrolling (bool, optional): Whether to allow the map to scroll. Defaults to False.\n        replace_dict (dict, optional): A dictionary of strings to replace in the HTML file. Defaults to {}.\n\n    Raises:\n        ValueError: If the filename does not exist.\n\n    Returns:\n        streamlit.components: components.html object.\n    \"\"\"\n\n    import streamlit.components.v1 as components\n\n    if not os.path.exists(filename):\n        raise ValueError(\"filename must exist.\")\n\n    f = open(filename, \"r\")\n\n    html = f.read()\n\n    for key, value in replace_dict.items():\n        html = html.replace(key, value)\n\n    f.close()\n    return components.html(html, width=width, height=height, scrolling=scrolling)\n</code></pre>"},{"location":"common/#geojp.common.image_bandcount","title":"<code>image_bandcount(image, **kwargs)</code>","text":"<p>Get the number of bands in an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of bands in the image.</p> Source code in <code>geojp/common.py</code> <pre><code>def image_bandcount(image, **kwargs):\n    \"\"\"Get the number of bands in an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        int: The number of bands in the image.\n    \"\"\"\n\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return len(client.metadata()[\"bands\"])\n</code></pre>"},{"location":"common/#geojp.common.image_bounds","title":"<code>image_bounds(image, **kwargs)</code>","text":"<p>Get the bounds of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of bounds in the form of [(south, west), (north, east)].</p> Source code in <code>geojp/common.py</code> <pre><code>def image_bounds(image, **kwargs):\n    \"\"\"Get the bounds of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        list: A list of bounds in the form of [(south, west), (north, east)].\n    \"\"\"\n\n    image_check(image)\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    bounds = client.bounds()\n    return [(bounds[0], bounds[2]), (bounds[1], bounds[3])]\n</code></pre>"},{"location":"common/#geojp.common.image_center","title":"<code>image_center(image, **kwargs)</code>","text":"<p>Get the center of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (latitude, longitude).</p> Source code in <code>geojp/common.py</code> <pre><code>def image_center(image, **kwargs):\n    \"\"\"Get the center of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        tuple: A tuple of (latitude, longitude).\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.center()\n</code></pre>"},{"location":"common/#geojp.common.image_client","title":"<code>image_client(image, **kwargs)</code>","text":"<p>Get a LocalTileserver TileClient from an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>TileClient</code> <p>A LocalTileserver TileClient.</p> Source code in <code>geojp/common.py</code> <pre><code>def image_client(image, **kwargs):\n    \"\"\"Get a LocalTileserver TileClient from an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        TileClient: A LocalTileserver TileClient.\n    \"\"\"\n    image_check(image)\n\n    _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    return client\n</code></pre>"},{"location":"common/#geojp.common.image_comparison","title":"<code>image_comparison(img1, img2, label1='1', label2='2', width=704, show_labels=True, starting_position=50, make_responsive=True, in_memory=True, out_html=None)</code>","text":"<p>Create a comparison slider for two images. The source code is adapted from     https://github.com/fcakyon/streamlit-image-comparison. Credits to the GitHub user @fcakyon.     Users can also use https://juxtapose.knightlab.com to create a comparison slider.</p> <p>Parameters:</p> Name Type Description Default <code>img1</code> <code>str</code> <p>Path to the first image. It can be a local file path, a URL, or a numpy array.</p> required <code>img2</code> <code>str</code> <p>Path to the second image. It can be a local file path, a URL, or a numpy array.</p> required <code>label1</code> <code>str</code> <p>Label for the first image. Defaults to \"1\".</p> <code>'1'</code> <code>label2</code> <code>str</code> <p>Label for the second image. Defaults to \"2\".</p> <code>'2'</code> <code>width</code> <code>int</code> <p>Width of the component in pixels. Defaults to 704.</p> <code>704</code> <code>show_labels</code> <code>bool</code> <p>Whether to show labels on the images. Default is True.</p> <code>True</code> <code>starting_position</code> <code>int</code> <p>Starting position of the slider as a percentage (0-100). Default is 50.</p> <code>50</code> <code>make_responsive</code> <code>bool</code> <p>Whether to enable responsive mode. Default is True.</p> <code>True</code> <code>in_memory</code> <code>bool</code> <p>Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.</p> <code>True</code> <code>out_html</code> <code>str</code> <p>Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.</p> <code>None</code> Source code in <code>geojp/common.py</code> <pre><code>def image_comparison(\n    img1: str,\n    img2: str,\n    label1: str = \"1\",\n    label2: str = \"2\",\n    width: int = 704,\n    show_labels: bool = True,\n    starting_position: int = 50,\n    make_responsive: bool = True,\n    in_memory: bool = True,\n    out_html: str = None,\n):\n    \"\"\"Create a comparison slider for two images. The source code is adapted from\n        https://github.com/fcakyon/streamlit-image-comparison. Credits to the GitHub user @fcakyon.\n        Users can also use https://juxtapose.knightlab.com to create a comparison slider.\n\n    Args:\n        img1 (str): Path to the first image. It can be a local file path, a URL, or a numpy array.\n        img2 (str): Path to the second image. It can be a local file path, a URL, or a numpy array.\n        label1 (str, optional): Label for the first image. Defaults to \"1\".\n        label2 (str, optional): Label for the second image. Defaults to \"2\".\n        width (int, optional): Width of the component in pixels. Defaults to 704.\n        show_labels (bool, optional): Whether to show labels on the images. Default is True.\n        starting_position (int, optional): Starting position of the slider as a percentage (0-100). Default is 50.\n        make_responsive (bool, optional): Whether to enable responsive mode. Default is True.\n        in_memory (bool, optional): Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.\n        out_html (str, optional): Whether to handle pillow to base64 conversion in memory without saving to local. Default is True.\n\n    \"\"\"\n\n    from PIL import Image\n    import base64\n    import io\n    import os\n    import uuid\n    from typing import Union\n    import requests\n    import tempfile\n    import numpy as np\n    from IPython.display import HTML, display\n\n    TEMP_DIR = os.path.join(tempfile.gettempdir(), random_string(6))\n    os.makedirs(TEMP_DIR, exist_ok=True)\n\n    def exif_transpose(image: Image.Image):\n        \"\"\"\n        Transpose a PIL image accordingly if it has an EXIF Orientation tag.\n        Inplace version of https://github.com/python-pillow/Pillow/blob/master/src/PIL/ImageOps.py exif_transpose()\n        :param image: The image to transpose.\n        :return: An image.\n        \"\"\"\n        exif = image.getexif()\n        orientation = exif.get(0x0112, 1)  # default 1\n        if orientation &gt; 1:\n            method = {\n                2: Image.FLIP_LEFT_RIGHT,\n                3: Image.ROTATE_180,\n                4: Image.FLIP_TOP_BOTTOM,\n                5: Image.TRANSPOSE,\n                6: Image.ROTATE_270,\n                7: Image.TRANSVERSE,\n                8: Image.ROTATE_90,\n            }.get(orientation)\n            if method is not None:\n                image = image.transpose(method)\n                del exif[0x0112]\n                image.info[\"exif\"] = exif.tobytes()\n        return image\n\n    def read_image_as_pil(\n        image: Union[Image.Image, str, np.ndarray], exif_fix: bool = False\n    ):\n        \"\"\"\n        Loads an image as PIL.Image.Image.\n        Args:\n            image : Can be image path or url (str), numpy image (np.ndarray) or PIL.Image\n        \"\"\"\n        # https://stackoverflow.com/questions/56174099/how-to-load-images-larger-than-max-image-pixels-with-pil\n        Image.MAX_IMAGE_PIXELS = None\n\n        if isinstance(image, Image.Image):\n            image_pil = image.convert(\"RGB\")\n        elif isinstance(image, str):\n            # read image if str image path is provided\n            try:\n                image_pil = Image.open(\n                    requests.get(image, stream=True).raw\n                    if str(image).startswith(\"http\")\n                    else image\n                ).convert(\"RGB\")\n                if exif_fix:\n                    image_pil = exif_transpose(image_pil)\n            except:  # handle large/tiff image reading\n                try:\n                    import skimage.io\n                except ImportError:\n                    raise ImportError(\n                        \"Please run 'pip install -U scikit-image imagecodecs' for large image handling.\"\n                    )\n                image_sk = skimage.io.imread(image).astype(np.uint8)\n                if len(image_sk.shape) == 2:  # b&amp;w\n                    image_pil = Image.fromarray(image_sk, mode=\"1\").convert(\"RGB\")\n                elif image_sk.shape[2] == 4:  # rgba\n                    image_pil = Image.fromarray(image_sk, mode=\"RGBA\").convert(\"RGB\")\n                elif image_sk.shape[2] == 3:  # rgb\n                    image_pil = Image.fromarray(image_sk, mode=\"RGB\")\n                else:\n                    raise TypeError(\n                        f\"image with shape: {image_sk.shape[3]} is not supported.\"\n                    )\n        elif isinstance(image, np.ndarray):\n            if image.shape[0] &lt; 5:  # image in CHW\n                image = image[:, :, ::-1]\n            image_pil = Image.fromarray(image).convert(\"RGB\")\n        else:\n            raise TypeError(\"read image with 'pillow' using 'Image.open()'\")\n\n        return image_pil\n\n    def pillow_to_base64(image: Image.Image) -&gt; str:\n        \"\"\"\n        Convert a PIL image to a base64-encoded string.\n\n        Parameters\n        ----------\n        image: PIL.Image.Image\n            The image to be converted.\n\n        Returns\n        -------\n        str\n            The base64-encoded string.\n        \"\"\"\n        in_mem_file = io.BytesIO()\n        image.save(in_mem_file, format=\"JPEG\", subsampling=0, quality=100)\n        img_bytes = in_mem_file.getvalue()  # bytes\n        image_str = base64.b64encode(img_bytes).decode(\"utf-8\")\n        base64_src = f\"data:image/jpg;base64,{image_str}\"\n        return base64_src\n\n    def local_file_to_base64(image_path: str) -&gt; str:\n        \"\"\"\n        Convert a local image file to a base64-encoded string.\n\n        Parameters\n        ----------\n        image_path: str\n            The path to the image file.\n\n        Returns\n        -------\n        str\n            The base64-encoded string.\n        \"\"\"\n        file_ = open(image_path, \"rb\")\n        img_bytes = file_.read()\n        image_str = base64.b64encode(img_bytes).decode(\"utf-8\")\n        file_.close()\n        base64_src = f\"data:image/jpg;base64,{image_str}\"\n        return base64_src\n\n    def pillow_local_file_to_base64(image: Image.Image, temp_dir: str):\n        \"\"\"\n        Convert a Pillow image to a base64 string, using a temporary file on disk.\n\n        Parameters\n        ----------\n        image : PIL.Image.Image\n            The Pillow image to convert.\n        temp_dir : str\n            The directory to use for the temporary file.\n\n        Returns\n        -------\n        str\n            A base64-encoded string representing the image.\n        \"\"\"\n        # Create temporary file path using os.path.join()\n        img_path = os.path.join(temp_dir, str(uuid.uuid4()) + \".jpg\")\n\n        # Save image to temporary file\n        image.save(img_path, subsampling=0, quality=100)\n\n        # Convert temporary file to base64 string\n        base64_src = local_file_to_base64(img_path)\n\n        return base64_src\n\n    # Prepare images\n    img1_pillow = read_image_as_pil(img1)\n    img2_pillow = read_image_as_pil(img2)\n\n    img_width, img_height = img1_pillow.size\n    h_to_w = img_height / img_width\n    height = int((width * h_to_w) * 0.95)\n\n    if in_memory:\n        # Convert images to base64 strings\n        img1 = pillow_to_base64(img1_pillow)\n        img2 = pillow_to_base64(img2_pillow)\n    else:\n        # Create base64 strings from temporary files\n        os.makedirs(TEMP_DIR, exist_ok=True)\n        for file_ in os.listdir(TEMP_DIR):\n            if file_.endswith(\".jpg\"):\n                os.remove(os.path.join(TEMP_DIR, file_))\n        img1 = pillow_local_file_to_base64(img1_pillow, TEMP_DIR)\n        img2 = pillow_local_file_to_base64(img2_pillow, TEMP_DIR)\n\n    # Load CSS and JS\n    cdn_path = \"https://cdn.knightlab.com/libs/juxtapose/latest\"\n    css_block = f'&lt;link rel=\"stylesheet\" href=\"{cdn_path}/css/juxtapose.css\"&gt;'\n    js_block = f'&lt;script src=\"{cdn_path}/js/juxtapose.min.js\"&gt;&lt;/script&gt;'\n\n    # write html block\n    htmlcode = f\"\"\"\n        &lt;html&gt;\n        &lt;head&gt;\n        &lt;style&gt;body {{ margin: unset; }}&lt;/style&gt;\n        {css_block}\n        {js_block}\n        &lt;div id=\"foo\" style=\"height: {height}; width: {width or '100%'};\"&gt;&lt;/div&gt;\n        &lt;script&gt;\n        slider = new juxtapose.JXSlider('#foo',\n            [\n                {{\n                    src: '{img1}',\n                    label: '{label1}',\n                }},\n                {{\n                    src: '{img2}',\n                    label: '{label2}',\n                }}\n            ],\n            {{\n                animate: true,\n                showLabels: {'true' if show_labels else 'false'},\n                showCredits: true,\n                startingPosition: \"{starting_position}%\",\n                makeResponsive: {'true' if make_responsive else 'false'},\n            }});\n        &lt;/script&gt;\n        &lt;/head&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n    if out_html is not None:\n        with open(out_html, \"w\") as f:\n            f.write(htmlcode)\n\n    shutil.rmtree(TEMP_DIR)\n\n    display(HTML(htmlcode))\n</code></pre>"},{"location":"common/#geojp.common.image_filesize","title":"<code>image_filesize(region, cellsize, bands=1, dtype='uint8', unit='MB', source_crs='epsg:4326', dst_crs='epsg:3857', bbox=False)</code>","text":"<p>Calculate the size of an image in a given region and cell size.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>list</code> <p>A bounding box in the format of [minx, miny, maxx, maxy].</p> required <code>cellsize</code> <code>float</code> <p>The resolution of the image.</p> required <code>bands</code> <code>int</code> <p>Number of bands. Defaults to 1.</p> <code>1</code> <code>dtype</code> <code>str</code> <p>Data type, such as unit8, float32. For more info, see https://numpy.org/doc/stable/user/basics.types.html. Defaults to 'uint8'.</p> <code>'uint8'</code> <code>unit</code> <code>str</code> <p>The unit of the output. Defaults to 'MB'.</p> <code>'MB'</code> <code>source_crs</code> <code>str</code> <p>The CRS of the region. Defaults to 'epsg:4326'.</p> <code>'epsg:4326'</code> <code>dst_crs</code> <code>str</code> <p>The destination CRS to calculate the area. Defaults to 'epsg:3857'.</p> <code>'epsg:3857'</code> <code>bbox</code> <code>bool</code> <p>Whether to use the bounding box of the region to calculate the area. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>The size of the image in a given unit.</p> Source code in <code>geojp/common.py</code> <pre><code>def image_filesize(\n    region,\n    cellsize,\n    bands=1,\n    dtype=\"uint8\",\n    unit=\"MB\",\n    source_crs=\"epsg:4326\",\n    dst_crs=\"epsg:3857\",\n    bbox=False,\n):\n    \"\"\"Calculate the size of an image in a given region and cell size.\n\n    Args:\n        region (list): A bounding box in the format of [minx, miny, maxx, maxy].\n        cellsize (float): The resolution of the image.\n        bands (int, optional): Number of bands. Defaults to 1.\n        dtype (str, optional): Data type, such as unit8, float32. For more info,\n            see https://numpy.org/doc/stable/user/basics.types.html. Defaults to 'uint8'.\n        unit (str, optional): The unit of the output. Defaults to 'MB'.\n        source_crs (str, optional): The CRS of the region. Defaults to 'epsg:4326'.\n        dst_crs (str, optional): The destination CRS to calculate the area. Defaults to 'epsg:3857'.\n        bbox (bool, optional): Whether to use the bounding box of the region to calculate the area. Defaults to False.\n\n    Returns:\n        float: The size of the image in a given unit.\n    \"\"\"\n    import numpy as np\n    import geopandas as gpd\n\n    if bbox:\n        if isinstance(region, gpd.GeoDataFrame):\n            region = region.to_crs(dst_crs).total_bounds.tolist()\n        elif isinstance(region, str) and os.path.exists(region):\n            region = gpd.read_file(region).to_crs(dst_crs).total_bounds.tolist()\n        elif isinstance(region, list):\n            region = (\n                bbox_to_gdf(region, crs=source_crs)\n                .to_crs(dst_crs)\n                .total_bounds.tolist()\n            )\n        else:\n            raise ValueError(\"Invalid input region.\")\n\n        bytes = (\n            np.prod(\n                [\n                    int((region[2] - region[0]) / cellsize),\n                    int((region[3] - region[1]) / cellsize),\n                    bands,\n                ]\n            )\n            * np.dtype(dtype).itemsize\n        )\n    else:\n        if isinstance(region, list):\n            region = bbox_to_gdf(region, crs=source_crs)\n\n        bytes = (\n            vector_area(region, crs=dst_crs)\n            / pow(cellsize, 2)\n            * np.dtype(dtype).itemsize\n            * bands\n        )\n\n    unit = unit.upper()\n\n    if unit == \"KB\":\n        return bytes / 1024\n    elif unit == \"MB\":\n        return bytes / pow(1024, 2)\n    elif unit == \"GB\":\n        return bytes / pow(1024, 3)\n    elif unit == \"TB\":\n        return bytes / pow(1024, 4)\n    elif unit == \"PB\":\n        return bytes / pow(1024, 5)\n    else:\n        return bytes\n</code></pre>"},{"location":"common/#geojp.common.image_geotransform","title":"<code>image_geotransform(image, **kwargs)</code>","text":"<p>Get the geotransform of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of geotransform values.</p> Source code in <code>geojp/common.py</code> <pre><code>def image_geotransform(image, **kwargs):\n    \"\"\"Get the geotransform of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        list: A list of geotransform values.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"GeoTransform\"]\n</code></pre>"},{"location":"common/#geojp.common.image_metadata","title":"<code>image_metadata(image, **kwargs)</code>","text":"<p>Get the metadata of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of image metadata.</p> Source code in <code>geojp/common.py</code> <pre><code>def image_metadata(image, **kwargs):\n    \"\"\"Get the metadata of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        dict: A dictionary of image metadata.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()\n</code></pre>"},{"location":"common/#geojp.common.image_projection","title":"<code>image_projection(image, **kwargs)</code>","text":"<p>Get the projection of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The projection of the image.</p> Source code in <code>geojp/common.py</code> <pre><code>def image_projection(image, **kwargs):\n    \"\"\"Get the projection of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        str: The projection of the image.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"Projection\"]\n</code></pre>"},{"location":"common/#geojp.common.image_resolution","title":"<code>image_resolution(image, **kwargs)</code>","text":"<p>Get the resolution of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The resolution of the image.</p> Source code in <code>geojp/common.py</code> <pre><code>def image_resolution(image, **kwargs):\n    \"\"\"Get the resolution of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        float: The resolution of the image.\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n    return client.metadata()[\"GeoTransform\"][1]\n</code></pre>"},{"location":"common/#geojp.common.image_set_crs","title":"<code>image_set_crs(image, epsg)</code>","text":"<p>Define the CRS of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath</p> required <code>epsg</code> <code>int</code> <p>The EPSG code of the CRS to set.</p> required Source code in <code>geojp/common.py</code> <pre><code>def image_set_crs(image, epsg):\n    \"\"\"Define the CRS of an image.\n\n    Args:\n        image (str): The input image filepath\n        epsg (int): The EPSG code of the CRS to set.\n    \"\"\"\n\n    from rasterio.crs import CRS\n    import rasterio\n\n    with rasterio.open(image, \"r+\") as rds:\n        rds.crs = CRS.from_epsg(epsg)\n</code></pre>"},{"location":"common/#geojp.common.image_size","title":"<code>image_size(image, **kwargs)</code>","text":"<p>Get the size (width, height) of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath or URL.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (width, height).</p> Source code in <code>geojp/common.py</code> <pre><code>def image_size(image, **kwargs):\n    \"\"\"Get the size (width, height) of an image.\n\n    Args:\n        image (str): The input image filepath or URL.\n\n    Returns:\n        tuple: A tuple of (width, height).\n    \"\"\"\n    image_check(image)\n\n    if isinstance(image, str):\n        _, client = get_local_tile_layer(image, return_client=True, **kwargs)\n    else:\n        client = image\n\n    metadata = client.metadata()\n    return metadata[\"sourceSizeX\"], metadata[\"sourceSizeY\"]\n</code></pre>"},{"location":"common/#geojp.common.image_to_cog","title":"<code>image_to_cog(source, dst_path=None, profile='deflate', **kwargs)</code>","text":"<p>Converts an image to a COG file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>A dataset path, URL or rasterio.io.DatasetReader object.</p> required <code>dst_path</code> <code>str</code> <p>An output dataset path or or PathLike object. Defaults to None.</p> <code>None</code> <code>profile</code> <code>str</code> <p>COG profile. More at https://cogeotiff.github.io/rio-cogeo/profile. Defaults to \"deflate\".</p> <code>'deflate'</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If rio-cogeo is not installed.</p> <code>FileNotFoundError</code> <p>If the source file could not be found.</p> Source code in <code>geojp/common.py</code> <pre><code>def image_to_cog(source, dst_path=None, profile=\"deflate\", **kwargs):\n    \"\"\"Converts an image to a COG file.\n\n    Args:\n        source (str): A dataset path, URL or rasterio.io.DatasetReader object.\n        dst_path (str, optional): An output dataset path or or PathLike object. Defaults to None.\n        profile (str, optional): COG profile. More at https://cogeotiff.github.io/rio-cogeo/profile. Defaults to \"deflate\".\n\n    Raises:\n        ImportError: If rio-cogeo is not installed.\n        FileNotFoundError: If the source file could not be found.\n    \"\"\"\n    try:\n        from rio_cogeo.cogeo import cog_translate\n        from rio_cogeo.profiles import cog_profiles\n\n    except ImportError:\n        raise ImportError(\n            \"The rio-cogeo package is not installed. Please install it with `pip install rio-cogeo` or `conda install rio-cogeo -c conda-forge`.\"\n        )\n\n    if not source.startswith(\"http\"):\n        source = check_file_path(source)\n\n        if not os.path.exists(source):\n            raise FileNotFoundError(\"The provided input file could not be found.\")\n\n    if dst_path is None:\n        if not source.startswith(\"http\"):\n            dst_path = os.path.splitext(source)[0] + \"_cog.tif\"\n        else:\n            dst_path = temp_file_path(extension=\".tif\")\n\n    dst_path = check_file_path(dst_path)\n\n    dst_profile = cog_profiles.get(profile)\n    cog_translate(source, dst_path, dst_profile, **kwargs)\n</code></pre>"},{"location":"common/#geojp.common.image_to_numpy","title":"<code>image_to_numpy(image)</code>","text":"<p>Converts an image to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>A dataset path, URL or rasterio.io.DatasetReader object.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the provided file could not be found.</p> <p>Returns:</p> Type Description <code>np.array</code> <p>A numpy array.</p> Source code in <code>geojp/common.py</code> <pre><code>def image_to_numpy(image):\n    \"\"\"Converts an image to a numpy array.\n\n    Args:\n        image (str): A dataset path, URL or rasterio.io.DatasetReader object.\n\n    Raises:\n        FileNotFoundError: If the provided file could not be found.\n\n    Returns:\n        np.array: A numpy array.\n    \"\"\"\n    import rasterio\n\n    from osgeo import gdal\n\n    # ... and suppress errors\n    gdal.PushErrorHandler(\"CPLQuietErrorHandler\")\n\n    try:\n        with rasterio.open(image, \"r\") as ds:\n            arr = ds.read()  # read all raster values\n        return arr\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.images_to_tiles","title":"<code>images_to_tiles(images, names=None, **kwargs)</code>","text":"<p>Convert a list of images to a dictionary of ipyleaflet.TileLayer objects.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str | list</code> <p>The path to a directory of images or a list of image paths.</p> required <code>names</code> <code>list</code> <p>A list of names for the layers. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to get_local_tile_layer().</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of ipyleaflet.TileLayer objects.</p> Source code in <code>geojp/common.py</code> <pre><code>def images_to_tiles(\n    images: Union[str, List[str]], names: List[str] = None, **kwargs\n) -&gt; Dict[str, ipyleaflet.TileLayer]:\n    \"\"\"Convert a list of images to a dictionary of ipyleaflet.TileLayer objects.\n\n    Args:\n        images (str | list): The path to a directory of images or a list of image paths.\n        names (list, optional): A list of names for the layers. Defaults to None.\n        **kwargs: Additional arguments to pass to get_local_tile_layer().\n\n    Returns:\n        dict: A dictionary of ipyleaflet.TileLayer objects.\n    \"\"\"\n\n    tiles = {}\n\n    if isinstance(images, str):\n        images = os.path.abspath(images)\n        images = find_files(images, ext=\".tif\", recursive=False)\n\n    if not isinstance(images, list):\n        raise ValueError(\"images must be a list of image paths or a directory\")\n\n    if names is None:\n        names = [os.path.splitext(os.path.basename(image))[0] for image in images]\n\n    if len(names) != len(images):\n        raise ValueError(\"names must have the same length as images\")\n\n    for index, image in enumerate(images):\n        name = names[index]\n        try:\n            if image.startswith(\"http\") and image.endswith(\".tif\"):\n                url = cog_tile(image, **kwargs)\n                tile = ipyleaflet.TileLayer(url=url, name=name, **kwargs)\n            elif image.startswith(\"http\"):\n                url = stac_tile(image, **kwargs)\n                tile = ipyleaflet.TileLayer(url=url, name=name, **kwargs)\n            else:\n                tile = get_local_tile_layer(image, layer_name=name, **kwargs)\n            tiles[name] = tile\n        except Exception as e:\n            print(image, e)\n\n    return tiles\n</code></pre>"},{"location":"common/#geojp.common.install_package","title":"<code>install_package(package)</code>","text":"<p>Install a Python package.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str | list</code> <p>The package name or a GitHub URL or a list of package names or GitHub URLs.</p> required Source code in <code>geojp/common.py</code> <pre><code>def install_package(package):\n    \"\"\"Install a Python package.\n\n    Args:\n        package (str | list): The package name or a GitHub URL or a list of package names or GitHub URLs.\n    \"\"\"\n    import subprocess\n\n    if isinstance(package, str):\n        packages = [package]\n\n    for package in packages:\n        if package.startswith(\"https\"):\n            package = f\"git+{package}\"\n\n        # Execute pip install command and show output in real-time\n        command = f\"pip install {package}\"\n        process = subprocess.Popen(command.split(), stdout=subprocess.PIPE)\n\n        # Print output in real-time\n        while True:\n            output = process.stdout.readline()\n            if output == b\"\" and process.poll() is not None:\n                break\n            if output:\n                print(output.decode(\"utf-8\").strip())\n\n        # Wait for process to complete\n        process.wait()\n</code></pre>"},{"location":"common/#geojp.common.is_arcpy","title":"<code>is_arcpy()</code>","text":"<p>Check if arcpy is available.</p> <p>Returns:</p> Type Description <code>book</code> <p>True if arcpy is available, False otherwise.</p> Source code in <code>geojp/common.py</code> <pre><code>def is_arcpy():\n    \"\"\"Check if arcpy is available.\n\n    Returns:\n        book: True if arcpy is available, False otherwise.\n    \"\"\"\n    import sys\n\n    if \"arcpy\" in sys.modules:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#geojp.common.is_array","title":"<code>is_array(x)</code>","text":"<p>Test whether x is either a numpy.ndarray or xarray.DataArray</p> Source code in <code>geojp/common.py</code> <pre><code>def is_array(x):\n    \"\"\"Test whether x is either a numpy.ndarray or xarray.DataArray\"\"\"\n    import sys\n\n    if isinstance(x, sys.modules[\"numpy\"].ndarray):\n        return True\n    if \"xarray\" in sys.modules:\n        if isinstance(x, sys.modules[\"xarray\"].DataArray):\n            return True\n    return False\n</code></pre>"},{"location":"common/#geojp.common.is_jupyterlite","title":"<code>is_jupyterlite()</code>","text":"<p>Check if the current notebook is running on JupyterLite.</p> <p>Returns:</p> Type Description <code>book</code> <p>True if the notebook is running on JupyterLite.</p> Source code in <code>geojp/common.py</code> <pre><code>def is_jupyterlite():\n    \"\"\"Check if the current notebook is running on JupyterLite.\n\n    Returns:\n        book: True if the notebook is running on JupyterLite.\n    \"\"\"\n    import sys\n\n    if \"pyodide\" in sys.modules:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#geojp.common.is_on_aws","title":"<code>is_on_aws()</code>","text":"<p>Check if the current notebook is running on AWS.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the notebook is running on AWS.</p> Source code in <code>geojp/common.py</code> <pre><code>def is_on_aws():\n    \"\"\"Check if the current notebook is running on AWS.\n\n    Returns:\n        bool: True if the notebook is running on AWS.\n    \"\"\"\n\n    import psutil\n\n    output = psutil.Process().parent().cmdline()\n\n    on_aws = False\n    for item in output:\n        if item.endswith(\".aws\") or \"ec2-user\" in item:\n            on_aws = True\n    return on_aws\n</code></pre>"},{"location":"common/#geojp.common.is_studio_lab","title":"<code>is_studio_lab()</code>","text":"<p>Check if the current notebook is running on Studio Lab.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the notebook is running on Studio Lab.</p> Source code in <code>geojp/common.py</code> <pre><code>def is_studio_lab():\n    \"\"\"Check if the current notebook is running on Studio Lab.\n\n    Returns:\n        bool: True if the notebook is running on Studio Lab.\n    \"\"\"\n\n    import psutil\n\n    output = psutil.Process().parent().cmdline()\n\n    on_studio_lab = False\n    for item in output:\n        if \"studiolab/bin\" in item:\n            on_studio_lab = True\n    return on_studio_lab\n</code></pre>"},{"location":"common/#geojp.common.is_tool","title":"<code>is_tool(name)</code>","text":"<p>Check whether <code>name</code> is on PATH and marked as executable.</p> Source code in <code>geojp/common.py</code> <pre><code>def is_tool(name):\n    \"\"\"Check whether `name` is on PATH and marked as executable.\"\"\"\n\n    return shutil.which(name) is not None\n</code></pre>"},{"location":"common/#geojp.common.kml_to_geojson","title":"<code>kml_to_geojson(in_kml, out_geojson=None)</code>","text":"<p>Converts a KML to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The file path to the input KML.</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the output GeoJSON. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The input KML could not be found.</p> <code>TypeError</code> <p>The output must be a GeoJSON.</p> Source code in <code>geojp/common.py</code> <pre><code>def kml_to_geojson(in_kml, out_geojson=None):\n    \"\"\"Converts a KML to GeoJSON.\n\n    Args:\n        in_kml (str): The file path to the input KML.\n        out_geojson (str): The file path to the output GeoJSON. Defaults to None.\n\n    Raises:\n        FileNotFoundError: The input KML could not be found.\n        TypeError: The output must be a GeoJSON.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_kml = os.path.abspath(in_kml)\n    if not os.path.exists(in_kml):\n        raise FileNotFoundError(\"The input KML could not be found.\")\n\n    if out_geojson is not None:\n        out_geojson = os.path.abspath(out_geojson)\n        ext = os.path.splitext(out_geojson)[1].lower()\n        if ext not in [\".json\", \".geojson\"]:\n            raise TypeError(\"The output file must be a GeoJSON.\")\n\n        out_dir = os.path.dirname(out_geojson)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n    import fiona\n\n    # import fiona\n    # print(fiona.supported_drivers)\n    fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n    gdf = gpd.read_file(in_kml, driver=\"KML\")\n\n    if out_geojson is not None:\n        gdf.to_file(out_geojson, driver=\"GeoJSON\")\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"common/#geojp.common.kml_to_shp","title":"<code>kml_to_shp(in_kml, out_shp)</code>","text":"<p>Converts a KML to shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>in_kml</code> <code>str</code> <p>The file path to the input KML.</p> required <code>out_shp</code> <code>str</code> <p>The file path to the output shapefile.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The input KML could not be found.</p> <code>TypeError</code> <p>The output must be a shapefile.</p> Source code in <code>geojp/common.py</code> <pre><code>def kml_to_shp(in_kml, out_shp):\n    \"\"\"Converts a KML to shapefile.\n\n    Args:\n        in_kml (str): The file path to the input KML.\n        out_shp (str): The file path to the output shapefile.\n\n    Raises:\n        FileNotFoundError: The input KML could not be found.\n        TypeError: The output must be a shapefile.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_kml = os.path.abspath(in_kml)\n    if not os.path.exists(in_kml):\n        raise FileNotFoundError(\"The input KML could not be found.\")\n\n    out_shp = os.path.abspath(out_shp)\n    if not out_shp.endswith(\".shp\"):\n        raise TypeError(\"The output must be a shapefile.\")\n\n    out_dir = os.path.dirname(out_shp)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n    import fiona\n\n    # print(fiona.supported_drivers)\n    fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n    df = gpd.read_file(in_kml, driver=\"KML\")\n    df.to_file(out_shp)\n</code></pre>"},{"location":"common/#geojp.common.list_palettes","title":"<code>list_palettes(add_extra=False, lowercase=False)</code>","text":"<p>List all available colormaps. See a complete lost of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.</p> <p>Returns:</p> Type Description <code>list</code> <p>The list of colormap names.</p> Source code in <code>geojp/common.py</code> <pre><code>def list_palettes(add_extra=False, lowercase=False):\n    \"\"\"List all available colormaps. See a complete lost of colormaps at https://matplotlib.org/stable/tutorials/colors/colormaps.html.\n\n    Returns:\n        list: The list of colormap names.\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    result = plt.colormaps()\n    if add_extra:\n        result += [\"dem\", \"ndvi\", \"ndwi\"]\n    if lowercase:\n        result = [i.lower() for i in result]\n    result.sort()\n    return result\n</code></pre>"},{"location":"common/#geojp.common.lnglat_to_meters","title":"<code>lnglat_to_meters(longitude, latitude)</code>","text":"<p>coordinate conversion between lat/lon in decimal degrees to web mercator</p> <p>Parameters:</p> Name Type Description Default <code>longitude</code> <code>float</code> <p>The longitude.</p> required <code>latitude</code> <code>float</code> <p>The latitude.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (x, y) in meters.</p> Source code in <code>geojp/common.py</code> <pre><code>def lnglat_to_meters(longitude, latitude):\n    \"\"\"coordinate conversion between lat/lon in decimal degrees to web mercator\n\n    Args:\n        longitude (float): The longitude.\n        latitude (float): The latitude.\n\n    Returns:\n        tuple: A tuple of (x, y) in meters.\n    \"\"\"\n    import numpy as np\n\n    origin_shift = np.pi * 6378137\n    easting = longitude * origin_shift / 180.0\n    northing = np.log(np.tan((90 + latitude) * np.pi / 360.0)) * origin_shift / np.pi\n\n    if np.isnan(easting):\n        if longitude &gt; 0:\n            easting = 20026376\n        else:\n            easting = -20026376\n\n    if np.isnan(northing):\n        if latitude &gt; 0:\n            northing = 20048966\n        else:\n            northing = -20048966\n\n    return (easting, northing)\n</code></pre>"},{"location":"common/#geojp.common.local_tile_bands","title":"<code>local_tile_bands(source)</code>","text":"<p>Get band names from COG.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | TileClient</code> <p>A local COG file path or TileClient</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of band names.</p> Source code in <code>geojp/common.py</code> <pre><code>def local_tile_bands(source):\n    \"\"\"Get band names from COG.\n\n    Args:\n        source (str | TileClient): A local COG file path or TileClient\n\n    Returns:\n        list: A list of band names.\n    \"\"\"\n    check_package(\"localtileserver\", \"https://github.com/banesullivan/localtileserver\")\n    from localtileserver import TileClient\n\n    if isinstance(source, str):\n        tile_client = TileClient(source)\n    elif isinstance(source, TileClient):\n        tile_client = source\n    else:\n        raise ValueError(\"source must be a string or TileClient object.\")\n\n    return tile_client.band_names\n</code></pre>"},{"location":"common/#geojp.common.local_tile_pixel_value","title":"<code>local_tile_pixel_value(lon, lat, tile_client, verbose=True, **kwargs)</code>","text":"<p>Get pixel value from COG.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude of the pixel.</p> required <code>lat</code> <code>float</code> <p>Latitude of the pixel.</p> required <code>url</code> <code>str</code> <p>HTTP URL to a COG, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'</p> required <code>bidx</code> <code>str</code> <p>Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.</p> required <code>verbose</code> <code>bool</code> <p>Print status messages. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>PointData</code> <p>rio-tiler point data.</p> Source code in <code>geojp/common.py</code> <pre><code>def local_tile_pixel_value(\n    lon,\n    lat,\n    tile_client,\n    verbose=True,\n    **kwargs,\n):\n    \"\"\"Get pixel value from COG.\n\n    Args:\n        lon (float): Longitude of the pixel.\n        lat (float): Latitude of the pixel.\n        url (str): HTTP URL to a COG, e.g., 'https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif'\n        bidx (str, optional): Dataset band indexes (e.g bidx=1, bidx=1&amp;bidx=2&amp;bidx=3). Defaults to None.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\", \"planetary-computer\", \"pc\". Defaults to None.\n        verbose (bool, optional): Print status messages. Defaults to True.\n\n    Returns:\n        PointData: rio-tiler point data.\n    \"\"\"\n    return tile_client.point(lon, lat, coord_crs=\"EPSG:4326\", **kwargs)\n</code></pre>"},{"location":"common/#geojp.common.local_tile_vmin_vmax","title":"<code>local_tile_vmin_vmax(source, bands=None, **kwargs)</code>","text":"<p>Get vmin and vmax from COG.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | TileClient</code> <p>A local COG file path or TileClient object.</p> required <code>bands</code> <code>str | list</code> <p>A list of band names. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If source is not a TileClient object or a local COG file path.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of vmin and vmax.</p> Source code in <code>geojp/common.py</code> <pre><code>def local_tile_vmin_vmax(\n    source,\n    bands=None,\n    **kwargs,\n):\n    \"\"\"Get vmin and vmax from COG.\n\n    Args:\n        source (str | TileClient): A local COG file path or TileClient object.\n        bands (str | list, optional): A list of band names. Defaults to None.\n\n    Raises:\n        ValueError: If source is not a TileClient object or a local COG file path.\n\n    Returns:\n        tuple: A tuple of vmin and vmax.\n    \"\"\"\n    check_package(\"localtileserver\", \"https://github.com/banesullivan/localtileserver\")\n    from localtileserver import TileClient\n\n    if isinstance(source, str):\n        tile_client = TileClient(source)\n    elif isinstance(source, TileClient):\n        tile_client = source\n    else:\n        raise ValueError(\"source must be a string or TileClient object.\")\n\n    bandnames = tile_client.band_names\n    stats = tile_client.reader.statistics()\n\n    if isinstance(bands, str):\n        bands = [bands]\n    elif isinstance(bands, list):\n        pass\n    elif bands is None:\n        bands = bandnames\n\n    if all(b in bandnames for b in bands):\n        vmin = min([stats[b][\"min\"] for b in bands])\n        vmax = max([stats[b][\"max\"] for b in bands])\n    else:\n        vmin = min([stats[b][\"min\"] for b in bandnames])\n        vmax = max([stats[b][\"max\"] for b in bandnames])\n    return vmin, vmax\n</code></pre>"},{"location":"common/#geojp.common.make_gif","title":"<code>make_gif(images, out_gif, ext='jpg', fps=10, loop=0, mp4=False, clean_up=False)</code>","text":"<p>Creates a gif from a list of images.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list | str</code> <p>The list of images or input directory to create the gif from.</p> required <code>out_gif</code> <code>str</code> <p>File path to the output gif.</p> required <code>ext</code> <code>str</code> <p>The extension of the images. Defaults to 'jpg'.</p> <code>'jpg'</code> <code>fps</code> <code>int</code> <p>The frames per second of the gif. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>int</code> <p>The number of times to loop the gif. Defaults to 0.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the gif to mp4. Defaults to False.</p> <code>False</code> Source code in <code>geojp/common.py</code> <pre><code>def make_gif(images, out_gif, ext=\"jpg\", fps=10, loop=0, mp4=False, clean_up=False):\n    \"\"\"Creates a gif from a list of images.\n\n    Args:\n        images (list | str): The list of images or input directory to create the gif from.\n        out_gif (str): File path to the output gif.\n        ext (str, optional): The extension of the images. Defaults to 'jpg'.\n        fps (int, optional): The frames per second of the gif. Defaults to 10.\n        loop (int, optional): The number of times to loop the gif. Defaults to 0.\n        mp4 (bool, optional): Whether to convert the gif to mp4. Defaults to False.\n\n    \"\"\"\n    import glob\n    from PIL import Image\n\n    ext = ext.replace(\".\", \"\")\n\n    if isinstance(images, str) and os.path.isdir(images):\n        images = list(glob.glob(os.path.join(images, f\"*.{ext}\")))\n        if len(images) == 0:\n            raise ValueError(\"No images found in the input directory.\")\n    elif not isinstance(images, list):\n        raise ValueError(\"images must be a list or a path to the image directory.\")\n\n    images.sort()\n\n    frames = [Image.open(image) for image in images]\n    frame_one = frames[0]\n    frame_one.save(\n        out_gif,\n        format=\"GIF\",\n        append_images=frames,\n        save_all=True,\n        duration=int(1000 / fps),\n        loop=loop,\n    )\n\n    if mp4:\n        if not is_tool(\"ffmpeg\"):\n            print(\"ffmpeg is not installed on your computer.\")\n            return\n\n        if os.path.exists(out_gif):\n            out_mp4 = out_gif.replace(\".gif\", \".mp4\")\n            cmd = f\"ffmpeg -loglevel error -i {out_gif} -vcodec libx264 -crf 25 -pix_fmt yuv420p {out_mp4}\"\n            os.system(cmd)\n            if not os.path.exists(out_mp4):\n                raise Exception(f\"Failed to create mp4 file.\")\n    if clean_up:\n        for image in images:\n            os.remove(image)\n</code></pre>"},{"location":"common/#geojp.common.map_tiles_to_geotiff","title":"<code>map_tiles_to_geotiff(output, bbox, zoom=None, resolution=None, source='OpenStreetMap', crs='EPSG:3857', to_cog=False, quiet=False, **kwargs)</code>","text":"<p>Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.     Credits to the GitHub user @gumblex.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The output GeoTIFF file.</p> required <code>bbox</code> <code>list</code> <p>The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]</p> required <code>zoom</code> <code>int</code> <p>The map zoom level. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>float</code> <p>The resolution in meters. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".</p> <code>'OpenStreetMap'</code> <code>crs</code> <code>str</code> <p>The coordinate reference system. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>to_cog</code> <code>bool</code> <p>Convert to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def map_tiles_to_geotiff(\n    output,\n    bbox,\n    zoom=None,\n    resolution=None,\n    source=\"OpenStreetMap\",\n    crs=\"EPSG:3857\",\n    to_cog=False,\n    quiet=False,\n    **kwargs,\n):\n    \"\"\"Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.\n        Credits to the GitHub user @gumblex.\n\n    Args:\n        output (str): The output GeoTIFF file.\n        bbox (list): The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]\n        zoom (int, optional): The map zoom level. Defaults to None.\n        resolution (float, optional): The resolution in meters. Defaults to None.\n        source (str, optional): The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\",\n            \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".\n        crs (str, optional): The coordinate reference system. Defaults to \"EPSG:3857\".\n        to_cog (bool, optional): Convert to Cloud Optimized GeoTIFF. Defaults to False.\n        quiet (bool, optional): Suppress output. Defaults to False.\n        **kwargs: Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().\n\n    \"\"\"\n\n    import io\n    import math\n    import itertools\n    import concurrent.futures\n\n    import numpy\n    from PIL import Image\n\n    try:\n        from osgeo import gdal, osr\n    except ImportError:\n        raise ImportError(\"GDAL is not installed. Install it with pip install GDAL\")\n\n    try:\n        import httpx\n\n        SESSION = httpx.Client()\n    except ImportError:\n        import requests\n\n        SESSION = requests.Session()\n\n    SESSION.headers.update(\n        {\n            \"Accept\": \"*/*\",\n            \"Accept-Encoding\": \"gzip, deflate\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0\",\n        }\n    )\n\n    xyz_tiles = {\n        \"OPENSTREETMAP\": {\n            \"url\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"attribution\": \"OpenStreetMap\",\n            \"name\": \"OpenStreetMap\",\n        },\n        \"ROADMAP\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Maps\",\n        },\n        \"SATELLITE\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n        \"TERRAIN\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Terrain\",\n        },\n        \"HYBRID\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n    }\n\n    if isinstance(source, str) and source.upper() in xyz_tiles:\n        source = xyz_tiles[source.upper()][\"url\"]\n    elif isinstance(source, str) and source.startswith(\"http\"):\n        pass\n    elif isinstance(source, str):\n        tiles = basemap_xyz_tiles()\n        if source in tiles:\n            source = tiles[source].url\n    else:\n        raise ValueError(\n            'source must be one of \"OpenStreetMap\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or a URL'\n        )\n\n    def resolution_to_zoom_level(resolution):\n        \"\"\"\n        Convert map resolution in meters to zoom level for Web Mercator (EPSG:3857) tiles.\n        \"\"\"\n        # Web Mercator tile size in meters at zoom level 0\n        initial_resolution = 156543.03392804097\n\n        # Calculate the zoom level\n        zoom_level = math.log2(initial_resolution / resolution)\n\n        return int(zoom_level)\n\n    if isinstance(bbox, list) and len(bbox) == 4:\n        west, south, east, north = bbox\n    else:\n        raise ValueError(\n            \"bbox must be a list of 4 coordinates in the format of [xmin, ymin, xmax, ymax]\"\n        )\n\n    if zoom is None and resolution is None:\n        raise ValueError(\"Either zoom or resolution must be provided\")\n    elif zoom is not None and resolution is not None:\n        raise ValueError(\"Only one of zoom or resolution can be provided\")\n\n    if resolution is not None:\n        zoom = resolution_to_zoom_level(resolution)\n\n    EARTH_EQUATORIAL_RADIUS = 6378137.0\n\n    Image.MAX_IMAGE_PIXELS = None\n\n    gdal.UseExceptions()\n    web_mercator = osr.SpatialReference()\n    web_mercator.ImportFromEPSG(3857)\n\n    WKT_3857 = web_mercator.ExportToWkt()\n\n    def from4326_to3857(lat, lon):\n        xtile = math.radians(lon) * EARTH_EQUATORIAL_RADIUS\n        ytile = (\n            math.log(math.tan(math.radians(45 + lat / 2.0))) * EARTH_EQUATORIAL_RADIUS\n        )\n        return (xtile, ytile)\n\n    def deg2num(lat, lon, zoom):\n        lat_r = math.radians(lat)\n        n = 2**zoom\n        xtile = (lon + 180) / 360 * n\n        ytile = (1 - math.log(math.tan(lat_r) + 1 / math.cos(lat_r)) / math.pi) / 2 * n\n        return (xtile, ytile)\n\n    def is_empty(im):\n        extrema = im.getextrema()\n        if len(extrema) &gt;= 3:\n            if len(extrema) &gt; 3 and extrema[-1] == (0, 0):\n                return True\n            for ext in extrema[:3]:\n                if ext != (0, 0):\n                    return False\n            return True\n        else:\n            return extrema[0] == (0, 0)\n\n    def paste_tile(bigim, base_size, tile, corner_xy, bbox):\n        if tile is None:\n            return bigim\n        im = Image.open(io.BytesIO(tile))\n        mode = \"RGB\" if im.mode == \"RGB\" else \"RGBA\"\n        size = im.size\n        if bigim is None:\n            base_size[0] = size[0]\n            base_size[1] = size[1]\n            newim = Image.new(\n                mode, (size[0] * (bbox[2] - bbox[0]), size[1] * (bbox[3] - bbox[1]))\n            )\n        else:\n            newim = bigim\n\n        dx = abs(corner_xy[0] - bbox[0])\n        dy = abs(corner_xy[1] - bbox[1])\n        xy0 = (size[0] * dx, size[1] * dy)\n        if mode == \"RGB\":\n            newim.paste(im, xy0)\n        else:\n            if im.mode != mode:\n                im = im.convert(mode)\n            if not is_empty(im):\n                newim.paste(im, xy0)\n        im.close()\n        return newim\n\n    def finish_picture(bigim, base_size, bbox, x0, y0, x1, y1):\n        xfrac = x0 - bbox[0]\n        yfrac = y0 - bbox[1]\n        x2 = round(base_size[0] * xfrac)\n        y2 = round(base_size[1] * yfrac)\n        imgw = round(base_size[0] * (x1 - x0))\n        imgh = round(base_size[1] * (y1 - y0))\n        retim = bigim.crop((x2, y2, x2 + imgw, y2 + imgh))\n        if retim.mode == \"RGBA\" and retim.getextrema()[3] == (255, 255):\n            retim = retim.convert(\"RGB\")\n        bigim.close()\n        return retim\n\n    def get_tile(url):\n        retry = 3\n        while 1:\n            try:\n                r = SESSION.get(url, timeout=60)\n                break\n            except Exception:\n                retry -= 1\n                if not retry:\n                    raise\n        if r.status_code == 404:\n            return None\n        elif not r.content:\n            return None\n        r.raise_for_status()\n        return r.content\n\n    def draw_tile(\n        source, lat0, lon0, lat1, lon1, zoom, filename, quiet=False, **kwargs\n    ):\n        x0, y0 = deg2num(lat0, lon0, zoom)\n        x1, y1 = deg2num(lat1, lon1, zoom)\n        x0, x1 = sorted([x0, x1])\n        y0, y1 = sorted([y0, y1])\n        corners = tuple(\n            itertools.product(\n                range(math.floor(x0), math.ceil(x1)),\n                range(math.floor(y0), math.ceil(y1)),\n            )\n        )\n        totalnum = len(corners)\n        futures = []\n        with concurrent.futures.ThreadPoolExecutor(5) as executor:\n            for x, y in corners:\n                futures.append(\n                    executor.submit(get_tile, source.format(z=zoom, x=x, y=y))\n                )\n            bbox = (math.floor(x0), math.floor(y0), math.ceil(x1), math.ceil(y1))\n            bigim = None\n            base_size = [256, 256]\n            for k, (fut, corner_xy) in enumerate(zip(futures, corners), 1):\n                bigim = paste_tile(bigim, base_size, fut.result(), corner_xy, bbox)\n                if not quiet:\n                    print(\"Downloaded image %d/%d\" % (k, totalnum))\n\n        if not quiet:\n            print(\"Saving GeoTIFF. Please wait...\")\n        img = finish_picture(bigim, base_size, bbox, x0, y0, x1, y1)\n        imgbands = len(img.getbands())\n        driver = gdal.GetDriverByName(\"GTiff\")\n\n        if \"options\" not in kwargs:\n            kwargs[\"options\"] = [\n                \"COMPRESS=DEFLATE\",\n                \"PREDICTOR=2\",\n                \"ZLEVEL=9\",\n                \"TILED=YES\",\n            ]\n\n        kwargs.pop(\"overwrite\", None)\n        gtiff = driver.Create(\n            filename,\n            img.size[0],\n            img.size[1],\n            imgbands,\n            gdal.GDT_Byte,\n            **kwargs,\n        )\n        xp0, yp0 = from4326_to3857(lat0, lon0)\n        xp1, yp1 = from4326_to3857(lat1, lon1)\n        pwidth = abs(xp1 - xp0) / img.size[0]\n        pheight = abs(yp1 - yp0) / img.size[1]\n        gtiff.SetGeoTransform((min(xp0, xp1), pwidth, 0, max(yp0, yp1), 0, -pheight))\n        gtiff.SetProjection(WKT_3857)\n        for band in range(imgbands):\n            array = numpy.array(img.getdata(band), dtype=\"u8\")\n            array = array.reshape((img.size[1], img.size[0]))\n            band = gtiff.GetRasterBand(band + 1)\n            band.WriteArray(array)\n        gtiff.FlushCache()\n\n        if not quiet:\n            print(f\"Image saved to {filename}\")\n        return img\n\n    try:\n        draw_tile(source, south, west, north, east, zoom, output, quiet, **kwargs)\n        if crs.upper() != \"EPSG:3857\":\n            reproject(output, output, crs, to_cog=to_cog)\n        elif to_cog:\n            image_to_cog(output, output)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.mbtiles_to_pmtiles","title":"<code>mbtiles_to_pmtiles(input_file, output_file, max_zoom=99)</code>","text":"<p>Converts mbtiles to pmtiles using the pmtiles package.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the input .mbtiles file.</p> required <code>output_file</code> <code>str</code> <p>Path to the output .pmtiles file.</p> required <code>max_zoom</code> <code>int</code> <p>Maximum zoom level for the conversion. Defaults to 99.</p> <code>99</code> <p>Returns:</p> Type Description <code>None</code> <p>The function returns None either upon successful completion or when the pmtiles package is not installed.</p> Source code in <code>geojp/common.py</code> <pre><code>def mbtiles_to_pmtiles(\n    input_file: str, output_file: str, max_zoom: int = 99\n) -&gt; Optional[None]:\n    \"\"\"\n    Converts mbtiles to pmtiles using the pmtiles package.\n\n    Args:\n        input_file (str): Path to the input .mbtiles file.\n        output_file (str): Path to the output .pmtiles file.\n        max_zoom (int): Maximum zoom level for the conversion. Defaults to 99.\n\n    Returns:\n        None: The function returns None either upon successful completion or when the pmtiles package is not installed.\n\n    Raises:\n        Any exception raised by pmtiles.convert.mbtiles_to_pmtiles will be propagated up.\n    \"\"\"\n\n    try:\n        import pmtiles.convert as convert\n    except ImportError:\n        print(\n            \"pmtiles is not installed. Please install it using `pip install pmtiles`.\"\n        )\n        return\n\n    convert.mbtiles_to_pmtiles(input_file, output_file, maxzoom=max_zoom)\n</code></pre>"},{"location":"common/#geojp.common.merge_gifs","title":"<code>merge_gifs(in_gifs, out_gif)</code>","text":"<p>Merge multiple gifs into one.</p> <p>Parameters:</p> Name Type Description Default <code>in_gifs</code> <code>str | list</code> <p>The input gifs as a list or a directory path.</p> required <code>out_gif</code> <code>str</code> <p>The output gif.</p> required <p>Exceptions:</p> Type Description <code>Exception</code> <p>Raise exception when gifsicle is not installed.</p> Source code in <code>geojp/common.py</code> <pre><code>def merge_gifs(in_gifs, out_gif):\n    \"\"\"Merge multiple gifs into one.\n\n    Args:\n        in_gifs (str | list): The input gifs as a list or a directory path.\n        out_gif (str): The output gif.\n\n    Raises:\n        Exception:  Raise exception when gifsicle is not installed.\n    \"\"\"\n    import glob\n\n    try:\n        if isinstance(in_gifs, str) and os.path.isdir(in_gifs):\n            in_gifs = glob.glob(os.path.join(in_gifs, \"*.gif\"))\n        elif not isinstance(in_gifs, list):\n            raise Exception(\"in_gifs must be a list.\")\n\n        in_gifs = \" \".join(in_gifs)\n\n        cmd = f\"gifsicle {in_gifs} &gt; {out_gif}\"\n        os.system(cmd)\n\n    except Exception as e:\n        print(\n            \"gifsicle is not installed. Run 'sudo apt-get install -y gifsicle' to install it.\"\n        )\n        print(e)\n</code></pre>"},{"location":"common/#geojp.common.merge_rasters","title":"<code>merge_rasters(input_dir, output, input_pattern='*.tif', output_format='GTiff', output_nodata=None, output_options=['COMPRESS=DEFLATE'])</code>","text":"<p>Merge a directory of rasters into a single raster.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>The path to the input directory.</p> required <code>output</code> <code>str</code> <p>The path to the output raster.</p> required <code>input_pattern</code> <code>str</code> <p>The pattern to match the input files. Defaults to \"*.tif\".</p> <code>'*.tif'</code> <code>output_format</code> <code>str</code> <p>The output format. Defaults to \"GTiff\".</p> <code>'GTiff'</code> <code>output_nodata</code> <code>float</code> <p>The output nodata value. Defaults to None.</p> <code>None</code> <code>output_options</code> <code>list</code> <p>A list of output options. Defaults to [\"COMPRESS=DEFLATE\"].</p> <code>['COMPRESS=DEFLATE']</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if GDAL is not installed.</p> Source code in <code>geojp/common.py</code> <pre><code>def merge_rasters(\n    input_dir,\n    output,\n    input_pattern=\"*.tif\",\n    output_format=\"GTiff\",\n    output_nodata=None,\n    output_options=[\"COMPRESS=DEFLATE\"],\n):\n    \"\"\"Merge a directory of rasters into a single raster.\n\n    Args:\n        input_dir (str): The path to the input directory.\n        output (str): The path to the output raster.\n        input_pattern (str, optional): The pattern to match the input files. Defaults to \"*.tif\".\n        output_format (str, optional): The output format. Defaults to \"GTiff\".\n        output_nodata (float, optional): The output nodata value. Defaults to None.\n        output_options (list, optional): A list of output options. Defaults to [\"COMPRESS=DEFLATE\"].\n\n    Raises:\n        ImportError: Raised if GDAL is not installed.\n    \"\"\"\n\n    import glob\n\n    try:\n        from osgeo import gdal\n    except ImportError:\n        raise ImportError(\n            \"GDAL is required to use this function. Install it with `conda install gdal -c conda-forge`\"\n        )\n    # Get a list of all the input files\n    input_files = glob.glob(os.path.join(input_dir, input_pattern))\n\n    # Merge the input files into a single output file\n    gdal.Warp(\n        output,\n        input_files,\n        format=output_format,\n        dstNodata=output_nodata,\n        options=output_options,\n    )\n</code></pre>"},{"location":"common/#geojp.common.merge_vector","title":"<code>merge_vector(files, output, crs=None, ext='geojson', recursive=False, quiet=False, return_gdf=False, **kwargs)</code>","text":"<p>Merge vector files into a single GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Union[str, List[str]]</code> <p>A string or a list of file paths to be merged.</p> required <code>output</code> <code>str</code> <p>The file path to save the merged GeoDataFrame.</p> required <code>crs</code> <code>str</code> <p>Optional. The coordinate reference system (CRS) of the output GeoDataFrame.</p> <code>None</code> <code>ext</code> <code>str</code> <p>Optional. The file extension of the input files. Default is 'geojson'.</p> <code>'geojson'</code> <code>recursive</code> <code>bool</code> <p>Optional. If True, search for files recursively in subdirectories. Default is False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Optional. If True, suppresses progress messages. Default is False.</p> <code>False</code> <code>return_gdf</code> <code>bool</code> <p>Optional. If True, returns the merged GeoDataFrame. Default is False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>gpd.read_file</code> function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>If <code>return_gdf</code> is True, returns the merged GeoDataFrame. Otherwise, returns None.</p> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If <code>files</code> is not a list of file paths.</p> Source code in <code>geojp/common.py</code> <pre><code>def merge_vector(\n    files: Union[str, List[str]],\n    output: str,\n    crs: str = None,\n    ext: str = \"geojson\",\n    recursive: bool = False,\n    quiet: bool = False,\n    return_gdf: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Merge vector files into a single GeoDataFrame.\n\n    Args:\n        files: A string or a list of file paths to be merged.\n        output: The file path to save the merged GeoDataFrame.\n        crs: Optional. The coordinate reference system (CRS) of the output GeoDataFrame.\n        ext: Optional. The file extension of the input files. Default is 'geojson'.\n        recursive: Optional. If True, search for files recursively in subdirectories. Default is False.\n        quiet: Optional. If True, suppresses progress messages. Default is False.\n        return_gdf: Optional. If True, returns the merged GeoDataFrame. Default is False.\n        **kwargs: Additional keyword arguments to be passed to the `gpd.read_file` function.\n\n    Returns:\n        If `return_gdf` is True, returns the merged GeoDataFrame. Otherwise, returns None.\n\n    Raises:\n        TypeError: If `files` is not a list of file paths.\n\n    \"\"\"\n\n    import pandas as pd\n    import geopandas as gpd\n\n    if isinstance(files, str):\n        files = find_files(files, ext=ext, recursive=recursive)\n\n    if not isinstance(files, list):\n        raise TypeError(\"files must be a list of file paths\")\n\n    gdfs = []\n    for index, filename in enumerate(files):\n        if not quiet:\n            print(f\"Reading {index+1} of {len(files)}: {filename}\")\n        gdf = gpd.read_file(filename, **kwargs)\n        if crs is None:\n            crs = gdf.crs\n        gdfs.append(gdf)\n\n    if not quiet:\n        print(\"Merging GeoDataFrames ...\")\n    gdf = gpd.GeoDataFrame(pd.concat(gdfs, ignore_index=True), crs=crs)\n\n    if not quiet:\n        print(f\"Saving merged file to {output} ...\")\n    gdf.to_file(output)\n    print(f\"Saved merged file to {output}\")\n\n    if return_gdf:\n        return gdf\n</code></pre>"},{"location":"common/#geojp.common.meters_to_lnglat","title":"<code>meters_to_lnglat(x, y)</code>","text":"<p>coordinate conversion between web mercator to lat/lon in decimal degrees</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x coordinate.</p> required <code>y</code> <code>float</code> <p>The y coordinate.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (longitude, latitude) in decimal degrees.</p> Source code in <code>geojp/common.py</code> <pre><code>def meters_to_lnglat(x, y):\n    \"\"\"coordinate conversion between web mercator to lat/lon in decimal degrees\n\n    Args:\n        x (float): The x coordinate.\n        y (float): The y coordinate.\n\n    Returns:\n        tuple: A tuple of (longitude, latitude) in decimal degrees.\n    \"\"\"\n    import numpy as np\n\n    origin_shift = np.pi * 6378137\n    longitude = (x / origin_shift) * 180.0\n    latitude = (y / origin_shift) * 180.0\n    latitude = (\n        180 / np.pi * (2 * np.arctan(np.exp(latitude * np.pi / 180.0)) - np.pi / 2.0)\n    )\n    return (longitude, latitude)\n</code></pre>"},{"location":"common/#geojp.common.mosaic","title":"<code>mosaic(images, output, ext='tif', recursive=True, merge_args={}, to_cog=True, verbose=True, **kwargs)</code>","text":"<p>Mosaics a list of images into a single image. Inspired by https://bit.ly/3A6roDK.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>str | list</code> <p>An input directory containing images or a list of images.</p> required <code>output</code> <code>str</code> <p>The output image filepath.</p> required <code>ext</code> <code>str</code> <p>The file extension of the images. Defaults to 'tif'.</p> <code>'tif'</code> <code>recursive</code> <code>bool</code> <p>Whether to recursively search for images in the input directory. Defaults to True.</p> <code>True</code> <code>merge_args</code> <code>dict</code> <p>A dictionary of arguments to pass to the rasterio.merge function. Defaults to {}.</p> <code>{}</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether to print progress. Defaults to True.</p> <code>True</code> Source code in <code>geojp/common.py</code> <pre><code>def mosaic(\n    images,\n    output,\n    ext=\"tif\",\n    recursive=True,\n    merge_args={},\n    to_cog=True,\n    verbose=True,\n    **kwargs,\n):\n    \"\"\"Mosaics a list of images into a single image. Inspired by https://bit.ly/3A6roDK.\n\n    Args:\n        images (str | list): An input directory containing images or a list of images.\n        output (str): The output image filepath.\n        ext (str, optional): The file extension of the images. Defaults to 'tif'.\n        recursive (bool, optional): Whether to recursively search for images in the input directory. Defaults to True.\n        merge_args (dict, optional): A dictionary of arguments to pass to the rasterio.merge function. Defaults to {}.\n        to_cog (bool, optional): Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.\n        verbose (bool, optional): Whether to print progress. Defaults to True.\n\n    \"\"\"\n    from rasterio.merge import merge\n    import rasterio as rio\n    from pathlib import Path\n\n    output = os.path.abspath(output)\n\n    if isinstance(images, str):\n        raster_files = find_files(images, ext=ext, recursive=recursive)\n    elif isinstance(images, list):\n        raster_files = images\n    else:\n        raise ValueError(\"images must be a list of raster files.\")\n\n    raster_to_mosiac = []\n\n    if not os.path.exists(os.path.dirname(output)):\n        os.makedirs(os.path.dirname(output))\n\n    for index, p in enumerate(raster_files):\n        if verbose:\n            print(f\"Reading {index+1}/{len(raster_files)}: {os.path.basename(p)}\")\n        raster = rio.open(p, **kwargs)\n        raster_to_mosiac.append(raster)\n\n    if verbose:\n        print(\"Merging rasters...\")\n    arr, transform = merge(raster_to_mosiac, **merge_args)\n\n    output_meta = raster.meta.copy()\n    output_meta.update(\n        {\n            \"driver\": \"GTiff\",\n            \"height\": arr.shape[1],\n            \"width\": arr.shape[2],\n            \"transform\": transform,\n        }\n    )\n\n    with rio.open(output, \"w\", **output_meta) as m:\n        m.write(arr)\n\n    if to_cog:\n        if verbose:\n            print(\"Converting to COG...\")\n        image_to_cog(output, output)\n\n    if verbose:\n        print(f\"Saved mosaic to {output}\")\n</code></pre>"},{"location":"common/#geojp.common.mosaic_bounds","title":"<code>mosaic_bounds(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the bounding box of a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of values representing [left, bottom, right, top]</p> Source code in <code>geojp/common.py</code> <pre><code>def mosaic_bounds(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the bounding box of a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        list: A list of values representing [left, bottom, right, top]\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/bounds\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r[\"bounds\"]\n</code></pre>"},{"location":"common/#geojp.common.mosaic_info","title":"<code>mosaic_info(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the info of a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing bounds, center, minzoom, maxzoom, and name as keys.</p> Source code in <code>geojp/common.py</code> <pre><code>def mosaic_info(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the info of a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        dict: A dictionary containing bounds, center, minzoom, maxzoom, and name as keys.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/info\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r\n</code></pre>"},{"location":"common/#geojp.common.mosaic_info_geojson","title":"<code>mosaic_info_geojson(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the info of a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representing a dict of GeoJSON.</p> Source code in <code>geojp/common.py</code> <pre><code>def mosaic_info_geojson(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the info of a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        dict: A dictionary representing a dict of GeoJSON.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/info.geojson\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r\n</code></pre>"},{"location":"common/#geojp.common.mosaic_tile","title":"<code>mosaic_tile(url, titiler_endpoint=None, **kwargs)</code>","text":"<p>Get the tile URL from a MosaicJSON.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>HTTP URL to a MosaicJSON.</p> required <code>titiler_endpoint</code> <code>str</code> <p>Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The tile URL.</p> Source code in <code>geojp/common.py</code> <pre><code>def mosaic_tile(url, titiler_endpoint=None, **kwargs):\n    \"\"\"Get the tile URL from a MosaicJSON.\n\n    Args:\n        url (str): HTTP URL to a MosaicJSON.\n        titiler_endpoint (str, optional): Titiler endpoint, e.g., \"https://titiler.xyz\". Defaults to None.\n\n    Returns:\n        str: The tile URL.\n    \"\"\"\n\n    titiler_endpoint = check_titiler_endpoint(titiler_endpoint)\n\n    if isinstance(url, str) and url.startswith(\"http\"):\n        kwargs[\"url\"] = url\n    else:\n        raise ValueError(\"url must be a string and start with http.\")\n\n    if isinstance(titiler_endpoint, str):\n        r = requests.get(\n            f\"{titiler_endpoint}/mosaicjson/tilejson.json\",\n            params=kwargs,\n        ).json()\n    else:\n        raise ValueError(\"titiler_endpoint must be a string.\")\n\n    return r[\"tiles\"][0]\n</code></pre>"},{"location":"common/#geojp.common.nasa_data_download","title":"<code>nasa_data_download(granules, out_dir=None, provider=None, threads=8)</code>","text":"<p>Downloads NASA Earthdata granules.</p> <p>Parameters:</p> Name Type Description Default <code>granules</code> <code>List[dict]</code> <p>The granules to download.</p> required <code>out_dir</code> <code>str</code> <p>The output directory where the granules will be downloaded. Defaults to None (current directory).</p> <code>None</code> <code>provider</code> <code>str</code> <p>The provider of the granules.</p> <code>None</code> <code>threads</code> <code>int</code> <p>The number of threads to use for downloading. Defaults to 8.</p> <code>8</code> Source code in <code>geojp/common.py</code> <pre><code>def nasa_data_download(\n    granules: List[dict],\n    out_dir: Optional[str] = None,\n    provider: Optional[str] = None,\n    threads: int = 8,\n) -&gt; None:\n    \"\"\"Downloads NASA Earthdata granules.\n\n    Args:\n        granules (List[dict]): The granules to download.\n        out_dir (str, optional): The output directory where the granules will be downloaded. Defaults to None (current directory).\n        provider (str, optional): The provider of the granules.\n        threads (int, optional): The number of threads to use for downloading. Defaults to 8.\n    \"\"\"\n    import earthaccess\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    earthaccess.download(\n        granules, local_path=out_dir, provider=provider, threads=threads\n    )\n</code></pre>"},{"location":"common/#geojp.common.nasa_data_granules_to_gdf","title":"<code>nasa_data_granules_to_gdf(granules, crs='EPSG:4326', output=None, **kwargs)</code>","text":"<p>Converts granules data to a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>granules</code> <code>List[dict]</code> <p>A list of granules.</p> required <code>crs</code> <code>str</code> <p>The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>output</code> <code>str</code> <p>The output file path to save the GeoDataFrame as a file. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the gpd.GeoDataFrame.to_file() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The resulting GeoDataFrame.</p> Source code in <code>geojp/common.py</code> <pre><code>def nasa_data_granules_to_gdf(\n    granules: List[dict], crs: str = \"EPSG:4326\", output: str = None, **kwargs\n):\n    \"\"\"Converts granules data to a GeoDataFrame.\n\n    Args:\n        granules (List[dict]): A list of granules.\n        crs (str, optional): The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".\n        output (str, optional): The output file path to save the GeoDataFrame as a file. Defaults to None.\n        **kwargs: Additional keyword arguments for the gpd.GeoDataFrame.to_file() function.\n\n    Returns:\n        gpd.GeoDataFrame: The resulting GeoDataFrame.\n    \"\"\"\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import box, Polygon\n\n    df = pd.json_normalize([dict(i.items()) for i in granules])\n    df.columns = [col.split(\".\")[-1] for col in df.columns]\n    df = df.drop(\"Version\", axis=1)\n\n    def get_bbox(rectangles):\n        xmin = min(rectangle[\"WestBoundingCoordinate\"] for rectangle in rectangles)\n        ymin = min(rectangle[\"SouthBoundingCoordinate\"] for rectangle in rectangles)\n        xmax = max(rectangle[\"EastBoundingCoordinate\"] for rectangle in rectangles)\n        ymax = max(rectangle[\"NorthBoundingCoordinate\"] for rectangle in rectangles)\n\n        bbox = (xmin, ymin, xmax, ymax)\n        return bbox\n\n    def get_polygon(coordinates):\n        # Extract the points from the dictionary\n        points = [\n            (point[\"Longitude\"], point[\"Latitude\"])\n            for point in coordinates[0][\"Boundary\"][\"Points\"]\n        ]\n\n        # Create a Polygon\n        polygon = Polygon(points)\n        return polygon\n\n    if \"BoundingRectangles\" in df.columns:\n        df[\"bbox\"] = df[\"BoundingRectangles\"].apply(get_bbox)\n        df[\"geometry\"] = df[\"bbox\"].apply(lambda x: box(*x))\n    elif \"GPolygons\" in df.columns:\n        df[\"geometry\"] = df[\"GPolygons\"].apply(get_polygon)\n\n    gdf = gpd.GeoDataFrame(df, geometry=\"geometry\")\n\n    gdf.crs = crs\n\n    if output is not None:\n        for column in gdf.columns:\n            if gdf[column].apply(lambda x: isinstance(x, list)).any():\n                gdf[column] = gdf[column].apply(lambda x: str(x))\n\n        gdf.to_file(output, **kwargs)\n\n    return gdf\n</code></pre>"},{"location":"common/#geojp.common.nasa_data_login","title":"<code>nasa_data_login(strategy='all', persist=False, **kwargs)</code>","text":"<p>Logs in to NASA Earthdata.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>str</code> <p>The authentication method.    \"all\": (default) try all methods until one works     \"interactive\": enter username and password.     \"netrc\": retrieve username and password from ~/.netrc.     \"environment\": retrieve username and password from $EARTHDATA_USERNAME and $EARTHDATA_PASSWORD. persist (bool, optional): Whether to persist credentials in a .netrc file. Defaults to False.</p> <code>'all'</code> <code>**kwargs</code> <p>Additional keyword arguments for the earthaccess.login() function.</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def nasa_data_login(strategy: str = \"all\", persist: bool = False, **kwargs) -&gt; None:\n    \"\"\"Logs in to NASA Earthdata.\n\n    Args:\n        strategy (str, optional): The authentication method.\n               \"all\": (default) try all methods until one works\n                \"interactive\": enter username and password.\n                \"netrc\": retrieve username and password from ~/.netrc.\n                \"environment\": retrieve username and password from $EARTHDATA_USERNAME and $EARTHDATA_PASSWORD.\n           persist (bool, optional): Whether to persist credentials in a .netrc file. Defaults to False.\n        **kwargs: Additional keyword arguments for the earthaccess.login() function.\n    \"\"\"\n    try:\n        import earthaccess\n    except ImportError:\n        install_package(\"earthaccess\")\n        import earthaccess\n\n    try:\n        earthaccess.login(strategy=strategy, persist=persist, **kwargs)\n    except:\n        print(\n            \"Please login to Earthdata first. Register at https://urs.earthdata.nasa.gov\"\n        )\n</code></pre>"},{"location":"common/#geojp.common.nasa_data_search","title":"<code>nasa_data_search(count=-1, short_name=None, bbox=None, temporal=None, version=None, doi=None, daac=None, provider=None, output=None, crs='EPSG:4326', return_gdf=False, **kwargs)</code>","text":"<p>Searches for NASA Earthdata granules.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of granules to retrieve. Defaults to -1 (retrieve all).</p> <code>-1</code> <code>short_name</code> <code>str</code> <p>The short name of the dataset.</p> <code>None</code> <code>bbox</code> <code>List[float]</code> <p>The bounding box coordinates [xmin, ymin, xmax, ymax].</p> <code>None</code> <code>temporal</code> <code>str</code> <p>The temporal extent of the data.</p> <code>None</code> <code>version</code> <code>str</code> <p>The version of the dataset.</p> <code>None</code> <code>doi</code> <code>str</code> <p>The Digital Object Identifier (DOI) of the dataset.</p> <code>None</code> <code>daac</code> <code>str</code> <p>The Distributed Active Archive Center (DAAC) of the dataset.</p> <code>None</code> <code>provider</code> <code>str</code> <p>The provider of the dataset.</p> <code>None</code> <code>output</code> <code>str</code> <p>The output file path to save the GeoDataFrame as a file.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>return_gdf</code> <code>bool</code> <p>Whether to return the GeoDataFrame in addition to the granules. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments for the earthaccess.search_data() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[List[dict], tuple]</code> <p>The retrieved granules. If return_gdf is True, also returns the resulting GeoDataFrame.</p> Source code in <code>geojp/common.py</code> <pre><code>def nasa_data_search(\n    count: int = -1,\n    short_name: Optional[str] = None,\n    bbox: Optional[List[float]] = None,\n    temporal: Optional[str] = None,\n    version: Optional[str] = None,\n    doi: Optional[str] = None,\n    daac: Optional[str] = None,\n    provider: Optional[str] = None,\n    output: Optional[str] = None,\n    crs: str = \"EPSG:4326\",\n    return_gdf: bool = False,\n    **kwargs,\n) -&gt; Union[List[dict], tuple]:\n    \"\"\"Searches for NASA Earthdata granules.\n\n    Args:\n        count (int, optional): The number of granules to retrieve. Defaults to -1 (retrieve all).\n        short_name (str, optional): The short name of the dataset.\n        bbox (List[float], optional): The bounding box coordinates [xmin, ymin, xmax, ymax].\n        temporal (str, optional): The temporal extent of the data.\n        version (str, optional): The version of the dataset.\n        doi (str, optional): The Digital Object Identifier (DOI) of the dataset.\n        daac (str, optional): The Distributed Active Archive Center (DAAC) of the dataset.\n        provider (str, optional): The provider of the dataset.\n        output (str, optional): The output file path to save the GeoDataFrame as a file.\n        crs (str, optional): The coordinate reference system (CRS) of the GeoDataFrame. Defaults to \"EPSG:4326\".\n        return_gdf (bool, optional): Whether to return the GeoDataFrame in addition to the granules. Defaults to False.\n        **kwargs: Additional keyword arguments for the earthaccess.search_data() function.\n\n    Returns:\n        Union[List[dict], tuple]: The retrieved granules. If return_gdf is True, also returns the resulting GeoDataFrame.\n    \"\"\"\n    import earthaccess\n\n    if short_name is not None:\n        kwargs[\"short_name\"] = short_name\n    if bbox is not None:\n        kwargs[\"bounding_box\"] = bbox\n    if temporal is not None:\n        kwargs[\"temporal\"] = temporal\n    if version is not None:\n        kwargs[\"version\"] = version\n    if doi is not None:\n        kwargs[\"doi\"] = doi\n    if daac is not None:\n        kwargs[\"daac\"] = daac\n    if provider is not None:\n        kwargs[\"provider\"] = provider\n\n    granules = earthaccess.search_data(\n        count=count,\n        **kwargs,\n    )\n\n    if output is not None:\n        nasa_data_granules_to_gdf(granules, crs=crs, output=output)\n\n    if return_gdf:\n        gdf = nasa_data_granules_to_gdf(granules, crs=crs)\n        return granules, gdf\n    else:\n        return granules\n</code></pre>"},{"location":"common/#geojp.common.nasa_datasets","title":"<code>nasa_datasets(keyword=None, df=None, return_short_name=False)</code>","text":"<p>Searches for NASA datasets based on a keyword in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for. Defaults to None.</p> <code>None</code> <code>df</code> <code>pd.DataFrame</code> <p>The DataFrame to search in. If None, it will download the NASA dataset CSV from GitHub. Defaults to None.</p> <code>None</code> <code>return_short_name</code> <code>bool</code> <p>If True, only returns the list of short names of the matched datasets. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[pd.DataFrame, List[str]]</code> <p>Filtered DataFrame if return_short_name is False, otherwise a list of short names.</p> Source code in <code>geojp/common.py</code> <pre><code>def nasa_datasets(keyword=None, df=None, return_short_name=False):\n    \"\"\"\n    Searches for NASA datasets based on a keyword in a DataFrame.\n\n    Args:\n        keyword (str, optional): The keyword to search for. Defaults to None.\n        df (pd.DataFrame, optional): The DataFrame to search in. If None, it will download the NASA dataset CSV from GitHub. Defaults to None.\n        return_short_name (bool, optional): If True, only returns the list of short names of the matched datasets. Defaults to False.\n\n    Returns:\n        Union[pd.DataFrame, List[str]]: Filtered DataFrame if return_short_name is False, otherwise a list of short names.\n\n    \"\"\"\n    import pandas as pd\n\n    if df is None:\n        url = \"https://github.com/opengeos/NASA-Earth-Data/raw/main/nasa_earth_data.tsv\"\n        df = pd.read_csv(url, sep=\"\\t\")\n\n    if keyword is not None:\n        # Convert keyword and DataFrame values to lowercase\n        keyword_lower = keyword.lower()\n        df_lower = df.applymap(lambda x: x.lower() if isinstance(x, str) else x)\n\n        # Use boolean indexing to filter the DataFrame\n        filtered_df = df[\n            df_lower.astype(str).apply(lambda x: keyword_lower in \" \".join(x), axis=1)\n        ].reset_index(drop=True)\n\n        if return_short_name:\n            return filtered_df[\"ShortName\"].tolist()\n        else:\n            return filtered_df\n    else:\n        if return_short_name:\n            return df[\"ShortName\"].tolist()\n        else:\n            return df\n</code></pre>"},{"location":"common/#geojp.common.netcdf_tile_layer","title":"<code>netcdf_tile_layer(filename, variables=None, colormap=None, vmin=None, vmax=None, nodata=None, port='default', debug=False, attribution=None, tile_format='ipyleaflet', layer_name='NetCDF layer', return_client=False, shift_lon=True, lat='lat', lon='lon', **kwargs)</code>","text":"<p>Generate an ipyleaflet/folium TileLayer from a netCDF file.     If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),     try adding to following two lines to the beginning of the notebook if the raster does not render properly.</p> <pre><code>import os\nos.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netCDF file.</p> required <code>variables</code> <code>int</code> <p>The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>port</code> <code>str</code> <p>The port to use for the server. Defaults to \"default\".</p> <code>'default'</code> <code>colormap</code> <code>str</code> <p>The name of the colormap from <code>matplotlib</code> to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.</p> <code>None</code> <code>vmin</code> <code>float</code> <p>The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.</p> <code>None</code> <code>nodata</code> <code>float</code> <p>The value from the band to use to interpret as not valid data. Defaults to None.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>If True, the server will be started in debug mode. Defaults to False.</p> <code>False</code> <code>projection</code> <code>str</code> <p>The projection of the GeoTIFF. Defaults to \"EPSG:3857\".</p> required <code>attribution</code> <code>str</code> <p>Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.</p> <code>None</code> <code>tile_format</code> <code>str</code> <p>The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <code>layer_name</code> <code>str</code> <p>The layer name to use. Defaults to \"NetCDF layer\".</p> <code>'NetCDF layer'</code> <code>return_client</code> <code>bool</code> <p>If True, the tile client will be returned. Defaults to False.</p> <code>False</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> <p>Returns:</p> Type Description <code>ipyleaflet.TileLayer | folium.TileLayer</code> <p>An ipyleaflet.TileLayer or folium.TileLayer.</p> Source code in <code>geojp/common.py</code> <pre><code>def netcdf_tile_layer(\n    filename,\n    variables=None,\n    colormap=None,\n    vmin=None,\n    vmax=None,\n    nodata=None,\n    port=\"default\",\n    debug=False,\n    attribution=None,\n    tile_format=\"ipyleaflet\",\n    layer_name=\"NetCDF layer\",\n    return_client=False,\n    shift_lon=True,\n    lat=\"lat\",\n    lon=\"lon\",\n    **kwargs,\n):\n    \"\"\"Generate an ipyleaflet/folium TileLayer from a netCDF file.\n        If you are using this function in JupyterHub on a remote server (e.g., Binder, Microsoft Planetary Computer),\n        try adding to following two lines to the beginning of the notebook if the raster does not render properly.\n\n        import os\n        os.environ['LOCALTILESERVER_CLIENT_PREFIX'] = f'{os.environ['JUPYTERHUB_SERVICE_PREFIX'].lstrip('/')}/proxy/{{port}}'\n\n    Args:\n        filename (str): File path or HTTP URL to the netCDF file.\n        variables (int, optional): The variable/band names to extract data from the netCDF file. Defaults to None. If None, all variables will be extracted.\n        port (str, optional): The port to use for the server. Defaults to \"default\".\n        colormap (str, optional): The name of the colormap from `matplotlib` to use when plotting a single band. See https://matplotlib.org/stable/gallery/color/colormap_reference.html. Default is greyscale.\n        vmin (float, optional): The minimum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        vmax (float, optional): The maximum value to use when colormapping the colormap when plotting a single band. Defaults to None.\n        nodata (float, optional): The value from the band to use to interpret as not valid data. Defaults to None.\n        debug (bool, optional): If True, the server will be started in debug mode. Defaults to False.\n        projection (str, optional): The projection of the GeoTIFF. Defaults to \"EPSG:3857\".\n        attribution (str, optional): Attribution for the source raster. This defaults to a message about it being a local file.. Defaults to None.\n        tile_format (str, optional): The tile layer format. Can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n        layer_name (str, optional): The layer name to use. Defaults to \"NetCDF layer\".\n        return_client (bool, optional): If True, the tile client will be returned. Defaults to False.\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n\n    Returns:\n        ipyleaflet.TileLayer | folium.TileLayer: An ipyleaflet.TileLayer or folium.TileLayer.\n    \"\"\"\n\n    check_package(\n        \"localtileserver\", URL=\"https://github.com/banesullivan/localtileserver\"\n    )\n\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    output = filename.replace(\".nc\", \".tif\")\n\n    xds = xr.open_dataset(filename, **kwargs)\n\n    if shift_lon:\n        xds.coords[lon] = (xds.coords[lon] + 180) % 360 - 180\n        xds = xds.sortby(xds.lon)\n\n    allowed_vars = list(xds.data_vars.keys())\n    if isinstance(variables, str):\n        if variables not in allowed_vars:\n            raise ValueError(f\"{variables} is not a subset of {allowed_vars}.\")\n        variables = [variables]\n\n    if variables is not None and len(variables) &gt; 3:\n        raise ValueError(\"Only 3 variables can be plotted at a time.\")\n\n    if variables is not None and (not set(variables).issubset(allowed_vars)):\n        raise ValueError(f\"{variables} must be a subset of {allowed_vars}.\")\n\n    xds.rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.to_raster(output)\n    if variables is None:\n        if len(allowed_vars) &gt;= 3:\n            band_idx = [1, 2, 3]\n        else:\n            band_idx = [1]\n    else:\n        band_idx = [allowed_vars.index(var) + 1 for var in variables]\n\n    tile_layer = get_local_tile_layer(\n        output,\n        port=port,\n        debug=debug,\n        indexes=band_idx,\n        colormap=colormap,\n        vmin=vmin,\n        vmax=vmax,\n        nodata=nodata,\n        attribution=attribution,\n        tile_format=tile_format,\n        layer_name=layer_name,\n        return_client=return_client,\n    )\n    return tile_layer\n</code></pre>"},{"location":"common/#geojp.common.netcdf_to_tif","title":"<code>netcdf_to_tif(filename, output=None, variables=None, shift_lon=True, lat='lat', lon='lon', lev='lev', level_index=0, time=0, return_vars=False, **kwargs)</code>","text":"<p>Convert a netcdf file to a GeoTIFF file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the netcdf file.</p> required <code>output</code> <code>str</code> <p>Path to the output GeoTIFF file. Defaults to None. If None, the output file will be the same as the input file with the extension changed to .tif.</p> <code>None</code> <code>variables</code> <code>str | list</code> <p>Name of the variable or a list of variables to extract. Defaults to None. If None, all variables will be extracted.</p> <code>None</code> <code>shift_lon</code> <code>bool</code> <p>Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.</p> <code>True</code> <code>lat</code> <code>str</code> <p>Name of the latitude variable. Defaults to 'lat'.</p> <code>'lat'</code> <code>lon</code> <code>str</code> <p>Name of the longitude variable. Defaults to 'lon'.</p> <code>'lon'</code> <code>lev</code> <code>str</code> <p>Name of the level variable. Defaults to 'lev'.</p> <code>'lev'</code> <code>level_index</code> <code>int</code> <p>Index of the level dimension. Defaults to 0'.</p> <code>0</code> <code>time</code> <code>int</code> <p>Index of the time dimension. Defaults to 0'.</p> <code>0</code> <code>return_vars</code> <code>bool</code> <p>Flag to return all variables. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the xarray or rioxarray package is not installed.</p> <code>FileNotFoundError</code> <p>If the netcdf file is not found.</p> <code>ValueError</code> <p>If the variable is not found in the netcdf file.</p> Source code in <code>geojp/common.py</code> <pre><code>def netcdf_to_tif(\n    filename,\n    output=None,\n    variables=None,\n    shift_lon=True,\n    lat=\"lat\",\n    lon=\"lon\",\n    lev=\"lev\",\n    level_index=0,\n    time=0,\n    return_vars=False,\n    **kwargs,\n):\n    \"\"\"Convert a netcdf file to a GeoTIFF file.\n\n    Args:\n        filename (str): Path to the netcdf file.\n        output (str, optional): Path to the output GeoTIFF file. Defaults to None. If None, the output file will be the same as the input file with the extension changed to .tif.\n        variables (str | list, optional): Name of the variable or a list of variables to extract. Defaults to None. If None, all variables will be extracted.\n        shift_lon (bool, optional): Flag to shift longitude values from [0, 360] to the range [-180, 180]. Defaults to True.\n        lat (str, optional): Name of the latitude variable. Defaults to 'lat'.\n        lon (str, optional): Name of the longitude variable. Defaults to 'lon'.\n        lev (str, optional): Name of the level variable. Defaults to 'lev'.\n        level_index (int, optional): Index of the level dimension. Defaults to 0'.\n        time (int, optional): Index of the time dimension. Defaults to 0'.\n        return_vars (bool, optional): Flag to return all variables. Defaults to False.\n\n    Raises:\n        ImportError: If the xarray or rioxarray package is not installed.\n        FileNotFoundError: If the netcdf file is not found.\n        ValueError: If the variable is not found in the netcdf file.\n    \"\"\"\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    if output is None:\n        ext = os.path.splitext(filename)[1].lower()\n        if ext not in [\".nc\", \".nc4\"]:\n            raise TypeError(\n                \"The output file must be a netCDF with extension .nc or .nc4.\"\n            )\n        output = filename.replace(ext, \".tif\")\n    else:\n        output = check_file_path(output)\n\n    xds = xr.open_dataset(filename, **kwargs)\n\n    coords = list(xds.coords.keys())\n    if \"time\" in coords:\n        xds = xds.isel(time=time, drop=True)\n\n    if lev in coords:\n        xds = xds.isel(lev=level_index, drop=True)\n\n    if shift_lon:\n        xds.coords[lon] = (xds.coords[lon] + 180) % 360 - 180\n        xds = xds.sortby(xds[lon])\n\n    allowed_vars = list(xds.data_vars.keys())\n    if isinstance(variables, str):\n        if variables not in allowed_vars:\n            raise ValueError(f\"{variables} is not a valid variable.\")\n        variables = [variables]\n\n    if variables is not None and (not set(variables).issubset(allowed_vars)):\n        raise ValueError(f\"{variables} must be a subset of {allowed_vars}.\")\n\n    if variables is None:\n        xds.rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.to_raster(output)\n    else:\n        xds[variables].rio.set_spatial_dims(x_dim=lon, y_dim=lat).rio.to_raster(output)\n\n    if return_vars:\n        return output, allowed_vars\n    else:\n        return output\n</code></pre>"},{"location":"common/#geojp.common.numpy_to_cog","title":"<code>numpy_to_cog(np_array, out_cog, bounds=None, profile=None, dtype=None, dst_crs=None, coord_crs=None)</code>","text":"<p>Converts a numpy array to a COG file.</p> <p>Parameters:</p> Name Type Description Default <code>np_array</code> <code>np.array</code> <p>A numpy array representing an image or an HTTP URL to an image.</p> required <code>out_cog</code> <code>str</code> <p>The output COG file path.</p> required <code>bounds</code> <code>tuple</code> <p>The bounds of the image in the format of (minx, miny, maxx, maxy). Defaults to None.</p> <code>None</code> <code>profile</code> <code>str | dict</code> <p>File path to an existing COG file or a dictionary representing the profile. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>str</code> <p>The data type of the output COG file. Defaults to None.</p> <code>None</code> <code>dst_crs</code> <code>str</code> <p>The coordinate reference system of the output COG file. Defaults to \"epsg:4326\".</p> <code>None</code> <code>coord_crs</code> <code>str</code> <p>The coordinate reference system of bbox coordinates. Defaults to None.</p> <code>None</code> Source code in <code>geojp/common.py</code> <pre><code>def numpy_to_cog(\n    np_array,\n    out_cog,\n    bounds=None,\n    profile=None,\n    dtype=None,\n    dst_crs=None,\n    coord_crs=None,\n):\n    \"\"\"Converts a numpy array to a COG file.\n\n    Args:\n        np_array (np.array): A numpy array representing an image or an HTTP URL to an image.\n        out_cog (str): The output COG file path.\n        bounds (tuple, optional): The bounds of the image in the format of (minx, miny, maxx, maxy). Defaults to None.\n        profile (str | dict, optional): File path to an existing COG file or a dictionary representing the profile. Defaults to None.\n        dtype (str, optional): The data type of the output COG file. Defaults to None.\n        dst_crs (str, optional): The coordinate reference system of the output COG file. Defaults to \"epsg:4326\".\n        coord_crs (str, optional): The coordinate reference system of bbox coordinates. Defaults to None.\n\n    \"\"\"\n\n    import numpy as np\n    import rasterio\n    from rasterio.io import MemoryFile\n    from rasterio.transform import from_bounds\n\n    from rio_cogeo.cogeo import cog_translate\n    from rio_cogeo.profiles import cog_profiles\n\n    warnings.filterwarnings(\"ignore\")\n\n    if isinstance(np_array, str):\n        with rasterio.open(np_array, \"r\") as ds:\n            np_array = ds.read()\n\n    if not isinstance(np_array, np.ndarray):\n        raise TypeError(\"The input array must be a numpy array.\")\n\n    out_dir = os.path.dirname(out_cog)\n    check_dir(out_dir)\n\n    if profile is not None:\n        if isinstance(profile, str):\n            if (not profile.startswith(\"http\")) and (not os.path.exists(profile)):\n                raise FileNotFoundError(\"The provided file could not be found.\")\n            with rasterio.open(profile) as ds:\n                dst_crs = ds.crs\n                if bounds is None:\n                    bounds = ds.bounds\n\n        elif isinstance(profile, rasterio.profiles.Profile):\n            profile = dict(profile)\n        elif not isinstance(profile, dict):\n            raise TypeError(\"The provided profile must be a file path or a dictionary.\")\n\n    if bounds is None:\n        print(\n            \"warning: bounds is not set. Using the default bounds (-180.0, -85.0511, 180.0, 85.0511)\"\n        )\n        bounds = (-180.0, -85.0511287798066, 180.0, 85.0511287798066)\n\n    if not isinstance(bounds, tuple) and len(bounds) != 4:\n        raise TypeError(\"The provided bounds must be a tuple of length 4.\")\n\n    # Rasterio uses numpy array of shape of `(bands, height, width)`\n\n    if len(np_array.shape) == 3:\n        nbands = np_array.shape[0]\n        height = np_array.shape[1]\n        width = np_array.shape[2]\n    elif len(np_array.shape) == 2:\n        nbands = 1\n        height = np_array.shape[0]\n        width = np_array.shape[1]\n        np_array = np_array.reshape((1, height, width))\n    else:\n        raise ValueError(\"The input array must be a 2D or 3D numpy array.\")\n\n    if coord_crs is not None and dst_crs is not None:\n        bounds = transform_bbox_coords(bounds, coord_crs, dst_crs)\n\n    src_transform = from_bounds(*bounds, width=width, height=height)\n    if dtype is None:\n        dtype = str(np_array.dtype)\n\n    if dst_crs is None:\n        dst_crs = \"epsg:4326\"\n\n    if isinstance(profile, dict):\n        src_profile = profile\n        src_profile[\"count\"] = nbands\n    else:\n        src_profile = dict(\n            driver=\"GTiff\",\n            dtype=dtype,\n            count=nbands,\n            height=height,\n            width=width,\n            crs=dst_crs,\n            transform=src_transform,\n        )\n\n    with MemoryFile() as memfile:\n        with memfile.open(**src_profile) as mem:\n            # Populate the input file with numpy array\n            mem.write(np_array)\n\n            dst_profile = cog_profiles.get(\"deflate\")\n            cog_translate(\n                mem,\n                out_cog,\n                dst_profile,\n                in_memory=True,\n                quiet=True,\n            )\n</code></pre>"},{"location":"common/#geojp.common.numpy_to_image","title":"<code>numpy_to_image(np_array, filename, transpose=True, bands=None, size=None, resize_args=None, **kwargs)</code>","text":"<p>Converts a numpy array to an image in the specified format, such as JPG, PNG, TIFF, etc.</p> <p>Parameters:</p> Name Type Description Default <code>np_array</code> <code>np.ndarray</code> <p>A numpy array or a path to a raster file.</p> required <code>filename</code> <code>str</code> <p>The output filename.</p> required <code>transpose</code> <code>bool</code> <p>Whether to transpose the array from (bands, rows, cols) to (rows, cols, bands). Defaults to True.</p> <code>True</code> <code>bands</code> <code>int | list</code> <p>The band(s) to use, starting from 0. Defaults to None.</p> <code>None</code> Source code in <code>geojp/common.py</code> <pre><code>def numpy_to_image(\n    np_array,\n    filename: str,\n    transpose: bool = True,\n    bands: Union[int, list] = None,\n    size: Tuple = None,\n    resize_args: dict = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Converts a numpy array to an image in the specified format, such as JPG, PNG, TIFF, etc.\n\n    Args:\n        np_array (np.ndarray): A numpy array or a path to a raster file.\n        filename (str): The output filename.\n        transpose (bool, optional): Whether to transpose the array from (bands, rows, cols) to (rows, cols, bands). Defaults to True.\n        bands (int | list, optional): The band(s) to use, starting from 0. Defaults to None.\n\n    \"\"\"\n\n    import numpy as np\n    from PIL import Image\n\n    warnings.filterwarnings(\"ignore\")\n\n    if isinstance(np_array, str):\n        np_array = image_to_numpy(np_array)\n\n    if not isinstance(np_array, np.ndarray):\n        raise TypeError(\"The provided input must be a numpy array.\")\n\n    if np_array.dtype == np.float64 or np_array.dtype == np.float32:\n        # Convert the array to uint8\n        # np_array = (np_array * 255).astype(np.uint8)\n        np.interp(np_array, (np_array.min(), np_array.max()), (0, 255)).astype(np.uint8)\n    else:\n        # The array is already uint8\n        np_array = np_array\n\n    if np_array.ndim == 2:\n        img = Image.fromarray(np_array)\n    elif np_array.ndim == 3:\n        if transpose:\n            np_array = np_array.transpose(1, 2, 0)\n        if bands is None:\n            if np_array.shape[2] &lt; 3:\n                np_array = np_array[:, :, 0]\n            elif np_array.shape[2] &gt; 3:\n                np_array = np_array[:, :, :3]\n\n        elif isinstance(bands, list):\n            if len(bands) == 1:\n                np_array = np_array[:, :, bands[0]]\n            else:\n                np_array = np_array[:, :, bands]\n        elif isinstance(bands, int):\n            np_array = np_array[:, :, bands]\n        img = Image.fromarray(np_array)\n    else:\n        raise ValueError(\"The provided input must be a 2D or 3D numpy array.\")\n\n    if isinstance(size, tuple):\n        try:\n            from skimage.transform import resize\n        except ImportError:\n            raise ImportError(\n                \"The scikit-image package is not installed. Please install it with `pip install scikit-image` \\\n                  or `conda install scikit-image -c conda-forge`.\"\n            )\n        if resize_args is None:\n            resize_args = {}\n        if \"preserve_range\" not in resize_args:\n            resize_args[\"preserve_range\"] = True\n        np_array = resize(np_array, size, **resize_args).astype(\"uint8\")\n        img = Image.fromarray(np_array)\n\n    img.save(filename, **kwargs)\n</code></pre>"},{"location":"common/#geojp.common.open_image_from_url","title":"<code>open_image_from_url(url)</code>","text":"<p>Loads an image from the specified URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the image.</p> required <p>Returns:</p> Type Description <code>object</code> <p>Image object.</p> Source code in <code>geojp/common.py</code> <pre><code>def open_image_from_url(url: str):\n    \"\"\"Loads an image from the specified URL.\n\n    Args:\n        url (str): URL of the image.\n\n    Returns:\n        object: Image object.\n    \"\"\"\n    from PIL import Image\n\n    from io import BytesIO\n\n    # from urllib.parse import urlparse\n\n    try:\n        response = requests.get(url)\n        img = Image.open(BytesIO(response.content))\n        return img\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geojp.common.overlay_images","title":"<code>overlay_images(image1, image2, alpha=0.5, backend='TkAgg', height_ratios=[10, 1], show_args1={}, show_args2={})</code>","text":"<p>Overlays two images using a slider to control the opacity of the top image.</p> <p>Parameters:</p> Name Type Description Default <code>image1</code> <code>str | np.ndarray</code> <p>The first input image at the bottom represented as a NumPy array or the path to the image.</p> required <code>image2</code> <code>_type_</code> <p>The second input image on top represented as a NumPy array or the path to the image.</p> required <code>alpha</code> <code>float</code> <p>The alpha value of the top image. Defaults to 0.5.</p> <code>0.5</code> <code>backend</code> <code>str</code> <p>The backend of the matplotlib plot. Defaults to \"TkAgg\".</p> <code>'TkAgg'</code> <code>height_ratios</code> <code>list</code> <p>The height ratios of the two subplots. Defaults to [10, 1].</p> <code>[10, 1]</code> <code>show_args1</code> <code>dict</code> <p>The keyword arguments to pass to the imshow() function for the first image. Defaults to {}.</p> <code>{}</code> <code>show_args2</code> <code>dict</code> <p>The keyword arguments to pass to the imshow() function for the second image. Defaults to {}.</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def overlay_images(\n    image1,\n    image2,\n    alpha=0.5,\n    backend=\"TkAgg\",\n    height_ratios=[10, 1],\n    show_args1={},\n    show_args2={},\n):\n    \"\"\"Overlays two images using a slider to control the opacity of the top image.\n\n    Args:\n        image1 (str | np.ndarray): The first input image at the bottom represented as a NumPy array or the path to the image.\n        image2 (_type_): The second input image on top represented as a NumPy array or the path to the image.\n        alpha (float, optional): The alpha value of the top image. Defaults to 0.5.\n        backend (str, optional): The backend of the matplotlib plot. Defaults to \"TkAgg\".\n        height_ratios (list, optional): The height ratios of the two subplots. Defaults to [10, 1].\n        show_args1 (dict, optional): The keyword arguments to pass to the imshow() function for the first image. Defaults to {}.\n        show_args2 (dict, optional): The keyword arguments to pass to the imshow() function for the second image. Defaults to {}.\n\n    \"\"\"\n    import sys\n    import matplotlib\n    import matplotlib.pyplot as plt\n    import matplotlib.widgets as mpwidgets\n\n    if \"google.colab\" in sys.modules:\n        backend = \"inline\"\n        print(\n            \"The TkAgg backend is not supported in Google Colab. The overlay_images function will not work on Colab.\"\n        )\n        return\n\n    matplotlib.use(backend)\n\n    if isinstance(image1, str):\n        if image1.startswith(\"http\"):\n            image1 = download_file(image1)\n\n        if not os.path.exists(image1):\n            raise ValueError(f\"Input path {image1} does not exist.\")\n\n    if isinstance(image2, str):\n        if image2.startswith(\"http\"):\n            image2 = download_file(image2)\n\n        if not os.path.exists(image2):\n            raise ValueError(f\"Input path {image2} does not exist.\")\n\n    # Load the two images\n    x = plt.imread(image1)\n    y = plt.imread(image2)\n\n    # Create the plot\n    fig, (ax0, ax1) = plt.subplots(2, 1, gridspec_kw={\"height_ratios\": height_ratios})\n    img0 = ax0.imshow(x, **show_args1)\n    img1 = ax0.imshow(y, alpha=alpha, **show_args2)\n\n    # Define the update function\n    def update(value):\n        img1.set_alpha(value)\n        fig.canvas.draw_idle()\n\n    # Create the slider\n    slider0 = mpwidgets.Slider(ax=ax1, label=\"alpha\", valmin=0, valmax=1, valinit=alpha)\n    slider0.on_changed(update)\n\n    # Display the plot\n    plt.show()\n</code></pre>"},{"location":"common/#geojp.common.planet_biannual_tiles_tropical","title":"<code>planet_biannual_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  bi-annual imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_biannual_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  bi-annual imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_biannual_tropical(api_key, token_name)\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 15]\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#geojp.common.planet_biannual_tropical","title":"<code>planet_biannual_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_biannual_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet bi-annual imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    dates = [\n        \"2015-12_2016-05\",\n        \"2016-06_2016-11\",\n        \"2016-12_2017-05\",\n        \"2017-06_2017-11\",\n        \"2017-12_2018-05\",\n        \"2018-06_2018-11\",\n        \"2018-12_2019-05\",\n        \"2019-06_2019-11\",\n        \"2019-12_2020-05\",\n        \"2020-06_2020-08\",\n    ]\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/planet_medres_normalized_analytic_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for d in dates:\n        url = f\"{prefix}{d}{subfix}{api_key}\"\n        link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#geojp.common.planet_by_month","title":"<code>planet_by_month(year=2016, month=1, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Gets Planet global mosaic tile url by month. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The Planet API key is not provided.</p> <code>ValueError</code> <p>The year is invalid.</p> <code>ValueError</code> <p>The month is invalid.</p> <code>ValueError</code> <p>The month is invalid.</p> <p>Returns:</p> Type Description <code>str</code> <p>A Planet global mosaic tile url.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_by_month(\n    year=2016,\n    month=1,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n):\n    \"\"\"Gets Planet global mosaic tile url by month. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: The Planet API key is not provided.\n        ValueError: The year is invalid.\n        ValueError: The month is invalid.\n        ValueError: The month is invalid.\n\n    Returns:\n        str: A Planet global mosaic tile url.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    # quarter_now = (month_now - 1) // 3 + 1\n\n    if year &gt; year_now:\n        raise ValueError(f\"Year must be between 2016 and {year_now}.\")\n    elif year == year_now and month &gt;= month_now:\n        raise ValueError(f\"Month must be less than {month_now} for year {year_now}\")\n\n    if month &lt; 1 or month &gt; 12:\n        raise ValueError(\"Month must be between 1 and 12.\")\n\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_monthly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    m_str = str(year) + \"_\" + str(month).zfill(2)\n    url = f\"{prefix}{m_str}{subfix}{api_key}\"\n\n    return url\n</code></pre>"},{"location":"common/#geojp.common.planet_by_quarter","title":"<code>planet_by_quarter(year=2016, quarter=1, api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Gets Planet global mosaic tile url by quarter. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-4. Defaults to 1.</p> <code>1</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The Planet API key is not provided.</p> <code>ValueError</code> <p>The year is invalid.</p> <code>ValueError</code> <p>The quarter is invalid.</p> <code>ValueError</code> <p>The quarter is invalid.</p> <p>Returns:</p> Type Description <code>str</code> <p>A Planet global mosaic tile url.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_by_quarter(\n    year=2016,\n    quarter=1,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n):\n    \"\"\"Gets Planet global mosaic tile url by quarter. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: The Planet API key is not provided.\n        ValueError: The year is invalid.\n        ValueError: The quarter is invalid.\n        ValueError: The quarter is invalid.\n\n    Returns:\n        str: A Planet global mosaic tile url.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    quarter_now = (month_now - 1) // 3 + 1\n\n    if year &gt; year_now:\n        raise ValueError(f\"Year must be between 2016 and {year_now}.\")\n    elif year == year_now and quarter &gt;= quarter_now:\n        raise ValueError(f\"Quarter must be less than {quarter_now} for year {year_now}\")\n\n    if quarter &lt; 1 or quarter &gt; 4:\n        raise ValueError(\"Quarter must be between 1 and 4.\")\n\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_quarterly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    m_str = str(year) + \"q\" + str(quarter)\n    url = f\"{prefix}{m_str}{subfix}{api_key}\"\n\n    return url\n</code></pre>"},{"location":"common/#geojp.common.planet_catalog","title":"<code>planet_catalog(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_catalog(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    quarterly = planet_quarterly(api_key, token_name)\n    monthly = planet_monthly(api_key, token_name)\n    return quarterly + monthly\n</code></pre>"},{"location":"common/#geojp.common.planet_catalog_tropical","title":"<code>planet_catalog_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_catalog_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet bi-annual and monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    biannual = planet_biannual_tropical(api_key, token_name)\n    monthly = planet_monthly_tropical(api_key, token_name)\n    return biannual + monthly\n</code></pre>"},{"location":"common/#geojp.common.planet_monthly","title":"<code>planet_monthly(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet monthly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_monthly(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet monthly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_monthly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2016, year_now + 1):\n        for month in range(1, 13):\n            m_str = str(year) + \"_\" + str(month).zfill(2)\n\n            if year == year_now and month &gt;= month_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#geojp.common.planet_monthly_tiles","title":"<code>planet_monthly_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_monthly_tiles(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_monthly(api_key, token_name)\n\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 7]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#geojp.common.planet_monthly_tiles_tropical","title":"<code>planet_monthly_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_monthly_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    link = planet_monthly_tropical(api_key, token_name)\n    for url in link:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 7]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#geojp.common.planet_monthly_tropical","title":"<code>planet_monthly_tropical(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_monthly_tropical(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet monthly imagery URLs based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n\n    links = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/planet_medres_normalized_analytic_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2020, year_now + 1):\n        for month in range(1, 13):\n            m_str = str(year) + \"-\" + str(month).zfill(2)\n\n            if year == 2020 and month &lt; 9:\n                continue\n            if year == year_now and month &gt;= month_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            links.append(url)\n\n    return links\n</code></pre>"},{"location":"common/#geojp.common.planet_quarterly","title":"<code>planet_quarterly(api_key=None, token_name='PLANET_API_KEY')</code>","text":"<p>Generates Planet quarterly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the API key could not be found.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of tile URLs.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_quarterly(api_key=None, token_name=\"PLANET_API_KEY\"):\n    \"\"\"Generates Planet quarterly imagery URLs based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n\n    Raises:\n        ValueError: If the API key could not be found.\n\n    Returns:\n        list: A list of tile URLs.\n    \"\"\"\n    from datetime import date\n\n    if api_key is None:\n        api_key = os.environ.get(token_name)\n        if api_key is None:\n            raise ValueError(\"The Planet API Key must be provided.\")\n\n    today = date.today()\n    year_now = int(today.strftime(\"%Y\"))\n    month_now = int(today.strftime(\"%m\"))\n    quarter_now = (month_now - 1) // 3 + 1\n\n    link = []\n    prefix = \"https://tiles.planet.com/basemaps/v1/planet-tiles/global_quarterly_\"\n    subfix = \"_mosaic/gmap/{z}/{x}/{y}.png?api_key=\"\n\n    for year in range(2016, year_now + 1):\n        for quarter in range(1, 5):\n            m_str = str(year) + \"q\" + str(quarter)\n\n            if year == year_now and quarter &gt;= quarter_now:\n                break\n\n            url = f\"{prefix}{m_str}{subfix}{api_key}\"\n            link.append(url)\n\n    return link\n</code></pre>"},{"location":"common/#geojp.common.planet_quarterly_tiles","title":"<code>planet_quarterly_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_quarterly_tiles(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    tiles = {}\n    links = planet_quarterly(api_key, token_name)\n\n    for url in links:\n        index = url.find(\"20\")\n        name = \"Planet_\" + url[index : index + 6]\n\n        if tile_format == \"ipyleaflet\":\n            tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n        else:\n            tile = folium.TileLayer(\n                tiles=url,\n                attr=\"Planet\",\n                name=name,\n                overlay=True,\n                control=True,\n            )\n\n        tiles[name] = tile\n\n    return tiles\n</code></pre>"},{"location":"common/#geojp.common.planet_tile_by_month","title":"<code>planet_tile_by_month(year=2016, month=1, name=None, api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>month</code> <code>int</code> <p>The month of Planet global mosaic, must be 1-12. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_tile_by_month(\n    year=2016,\n    month=1,\n    name=None,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    tile_format=\"ipyleaflet\",\n):\n    \"\"\"Generates Planet monthly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        month (int, optional): The month of Planet global mosaic, must be 1-12. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    url = planet_by_month(year, month, api_key, token_name)\n\n    if name is None:\n        name = \"Planet_\" + str(year) + \"_\" + str(month).zfill(2)\n\n    if tile_format == \"ipyleaflet\":\n        tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n    else:\n        tile = folium.TileLayer(\n            tiles=url,\n            attr=\"Planet\",\n            name=name,\n            overlay=True,\n            control=True,\n        )\n\n    return tile\n</code></pre>"},{"location":"common/#geojp.common.planet_tile_by_quarter","title":"<code>planet_tile_by_quarter(year=2016, quarter=1, name=None, api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.</p> <code>2016</code> <code>quarter</code> <code>int</code> <p>The quarter of Planet global mosaic, must be 1-4. Defaults to 1.</p> <code>1</code> <code>name</code> <code>str</code> <p>The layer name to use. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_tile_by_quarter(\n    year=2016,\n    quarter=1,\n    name=None,\n    api_key=None,\n    token_name=\"PLANET_API_KEY\",\n    tile_format=\"ipyleaflet\",\n):\n    \"\"\"Generates Planet quarterly imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis\n\n    Args:\n        year (int, optional): The year of Planet global mosaic, must be &gt;=2016. Defaults to 2016.\n        quarter (int, optional): The quarter of Planet global mosaic, must be 1-4. Defaults to 1.\n        name (str, optional): The layer name to use. Defaults to None.\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    if tile_format not in [\"ipyleaflet\", \"folium\"]:\n        raise ValueError(\"The tile format must be either ipyleaflet or folium.\")\n\n    url = planet_by_quarter(year, quarter, api_key, token_name)\n\n    if name is None:\n        name = \"Planet_\" + str(year) + \"_q\" + str(quarter)\n\n    if tile_format == \"ipyleaflet\":\n        tile = ipyleaflet.TileLayer(url=url, attribution=\"Planet\", name=name)\n    else:\n        tile = folium.TileLayer(\n            tiles=url,\n            attr=\"Planet\",\n            name=name,\n            overlay=True,\n            control=True,\n        )\n\n    return tile\n</code></pre>"},{"location":"common/#geojp.common.planet_tiles","title":"<code>planet_tiles(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_tiles(api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"):\n    \"\"\"Generates Planet imagery TileLayer based on an API key. To get a Planet API key, see https://developers.planet.com/quickstart/apis/\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    catalog = {}\n    quarterly = planet_quarterly_tiles(api_key, token_name, tile_format)\n    monthly = planet_monthly_tiles(api_key, token_name, tile_format)\n\n    for key in quarterly:\n        catalog[key] = quarterly[key]\n\n    for key in monthly:\n        catalog[key] = monthly[key]\n\n    return catalog\n</code></pre>"},{"location":"common/#geojp.common.planet_tiles_tropical","title":"<code>planet_tiles_tropical(api_key=None, token_name='PLANET_API_KEY', tile_format='ipyleaflet')</code>","text":"<p>Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Planet API key. Defaults to None.</p> <code>None</code> <code>token_name</code> <code>str</code> <p>The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".</p> <code>'PLANET_API_KEY'</code> <code>tile_format</code> <code>str</code> <p>The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".</p> <code>'ipyleaflet'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the tile layer format is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of TileLayer.</p> Source code in <code>geojp/common.py</code> <pre><code>def planet_tiles_tropical(\n    api_key=None, token_name=\"PLANET_API_KEY\", tile_format=\"ipyleaflet\"\n):\n    \"\"\"Generates Planet  monthly imagery TileLayer based on an API key. See https://assets.planet.com/docs/NICFI_UserGuidesFAQ.pdf\n\n    Args:\n        api_key (str, optional): The Planet API key. Defaults to None.\n        token_name (str, optional): The environment variable name of the API key. Defaults to \"PLANET_API_KEY\".\n        tile_format (str, optional): The TileLayer format, can be either ipyleaflet or folium. Defaults to \"ipyleaflet\".\n\n    Raises:\n        ValueError: If the tile layer format is invalid.\n\n    Returns:\n        dict: A dictionary of TileLayer.\n    \"\"\"\n\n    catalog = {}\n    biannul = planet_biannual_tiles_tropical(api_key, token_name, tile_format)\n    monthly = planet_monthly_tiles_tropical(api_key, token_name, tile_format)\n\n    for key in biannul:\n        catalog[key] = biannul[key]\n\n    for key in monthly:\n        catalog[key] = monthly[key]\n\n    return catalog\n</code></pre>"},{"location":"common/#geojp.common.plot_raster","title":"<code>plot_raster(image, band=None, cmap='terrain', proj='EPSG:3857', figsize=None, open_kwargs={}, **kwargs)</code>","text":"<p>Plot a raster image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | xarray.DataArray </code> <p>The input raster image, can be a file path, HTTP URL, or xarray.DataArray.</p> required <code>band</code> <code>int</code> <p>The band index, starting from zero. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap to use. Defaults to \"terrain\".</p> <code>'terrain'</code> <code>proj</code> <code>str</code> <p>The EPSG projection code. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>figsize</code> <code>tuple</code> <p>The figure size as a tuple, such as (10, 8). Defaults to None.</p> <code>None</code> <code>open_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to xarray.DataArray.plot().</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def plot_raster(\n    image,\n    band=None,\n    cmap=\"terrain\",\n    proj=\"EPSG:3857\",\n    figsize=None,\n    open_kwargs={},\n    **kwargs,\n):\n    \"\"\"Plot a raster image.\n\n    Args:\n        image (str | xarray.DataArray ): The input raster image, can be a file path, HTTP URL, or xarray.DataArray.\n        band (int, optional): The band index, starting from zero. Defaults to None.\n        cmap (str, optional): The matplotlib colormap to use. Defaults to \"terrain\".\n        proj (str, optional): The EPSG projection code. Defaults to \"EPSG:3857\".\n        figsize (tuple, optional): The figure size as a tuple, such as (10, 8). Defaults to None.\n        open_kwargs (dict, optional): The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.\n        **kwargs: Additional keyword arguments to pass to xarray.DataArray.plot().\n\n    \"\"\"\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    try:\n        import pvxarray\n        import rioxarray\n        import xarray\n    except ImportError:\n        print(\n            \"pyxarray and rioxarray are required for plotting. Please install them using 'pip install rioxarray pyvista-xarray'.\"\n        )\n        return\n\n    if isinstance(image, str):\n        da = rioxarray.open_rasterio(image, **open_kwargs)\n    elif isinstance(image, xarray.DataArray):\n        da = image\n    else:\n        raise ValueError(\"image must be a string or xarray.Dataset.\")\n\n    if band is not None:\n        da = da[dict(band=band)]\n\n    da = da.rio.reproject(proj)\n    kwargs[\"cmap\"] = cmap\n    kwargs[\"figsize\"] = figsize\n    da.plot(**kwargs)\n</code></pre>"},{"location":"common/#geojp.common.plot_raster_3d","title":"<code>plot_raster_3d(image, band=None, cmap='terrain', factor=1.0, proj='EPSG:3857', background=None, x=None, y=None, z=None, order=None, component=None, open_kwargs={}, mesh_kwargs={}, **kwargs)</code>","text":"<p>Plot a raster image in 3D.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | xarray.DataArray</code> <p>The input raster image, can be a file path, HTTP URL, or xarray.DataArray.</p> required <code>band</code> <code>int</code> <p>The band index, starting from zero. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The matplotlib colormap to use. Defaults to \"terrain\".</p> <code>'terrain'</code> <code>factor</code> <code>float</code> <p>The scaling factor for the raster. Defaults to 1.0.</p> <code>1.0</code> <code>proj</code> <code>str</code> <p>The EPSG projection code. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>background</code> <code>str</code> <p>The background color. Defaults to None.</p> <code>None</code> <code>x</code> <code>str</code> <p>The x coordinate. Defaults to None.</p> <code>None</code> <code>y</code> <code>str</code> <p>The y coordinate. Defaults to None.</p> <code>None</code> <code>z</code> <code>str</code> <p>The z coordinate. Defaults to None.</p> <code>None</code> <code>order</code> <code>str</code> <p>The order of the coordinates. Defaults to None.</p> <code>None</code> <code>component</code> <code>str</code> <p>The component of the coordinates. Defaults to None.</p> <code>None</code> <code>open_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.</p> <code>{}</code> <code>mesh_kwargs</code> <code>dict</code> <p>The keyword arguments to pass to pyvista.mesh.warp_by_scalar(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to xarray.DataArray.plot().</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def plot_raster_3d(\n    image,\n    band=None,\n    cmap=\"terrain\",\n    factor=1.0,\n    proj=\"EPSG:3857\",\n    background=None,\n    x=None,\n    y=None,\n    z=None,\n    order=None,\n    component=None,\n    open_kwargs={},\n    mesh_kwargs={},\n    **kwargs,\n):\n    \"\"\"Plot a raster image in 3D.\n\n    Args:\n        image (str | xarray.DataArray): The input raster image, can be a file path, HTTP URL, or xarray.DataArray.\n        band (int, optional): The band index, starting from zero. Defaults to None.\n        cmap (str, optional): The matplotlib colormap to use. Defaults to \"terrain\".\n        factor (float, optional): The scaling factor for the raster. Defaults to 1.0.\n        proj (str, optional): The EPSG projection code. Defaults to \"EPSG:3857\".\n        background (str, optional): The background color. Defaults to None.\n        x (str, optional): The x coordinate. Defaults to None.\n        y (str, optional): The y coordinate. Defaults to None.\n        z (str, optional): The z coordinate. Defaults to None.\n        order (str, optional): The order of the coordinates. Defaults to None.\n        component (str, optional): The component of the coordinates. Defaults to None.\n        open_kwargs (dict, optional): The keyword arguments to pass to rioxarray.open_rasterio. Defaults to {}.\n        mesh_kwargs (dict, optional): The keyword arguments to pass to pyvista.mesh.warp_by_scalar(). Defaults to {}.\n        **kwargs: Additional keyword arguments to pass to xarray.DataArray.plot().\n    \"\"\"\n    import sys\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if \"google.colab\" in sys.modules:\n        print(\"This function is not supported in Google Colab.\")\n        return\n\n    try:\n        import pvxarray\n        import pyvista\n        import rioxarray\n        import xarray\n    except ImportError:\n        print(\n            \"pyxarray and rioxarray are required for plotting. Please install them using 'pip install rioxarray pyvista-xarray'.\"\n        )\n        return\n\n    if isinstance(background, str):\n        pyvista.global_theme.background = background\n\n    if isinstance(image, str):\n        da = rioxarray.open_rasterio(image, **open_kwargs)\n    elif isinstance(image, xarray.DataArray):\n        da = image\n    else:\n        raise ValueError(\"image must be a string or xarray.Dataset.\")\n\n    if band is not None:\n        da = da[dict(band=band)]\n\n    da = da.rio.reproject(proj)\n    mesh_kwargs[\"factor\"] = factor\n    kwargs[\"cmap\"] = cmap\n\n    coords = list(da.coords)\n\n    if x is None:\n        if \"x\" in coords:\n            x = \"x\"\n        elif \"lon\" in coords:\n            x = \"lon\"\n    if y is None:\n        if \"y\" in coords:\n            y = \"y\"\n        elif \"lat\" in coords:\n            y = \"lat\"\n    if z is None:\n        if \"z\" in coords:\n            z = \"z\"\n        elif \"elevation\" in coords:\n            z = \"elevation\"\n        elif \"band\" in coords:\n            z = \"band\"\n\n    # Grab the mesh object for use with PyVista\n    mesh = da.pyvista.mesh(x=x, y=y, z=z, order=order, component=component)\n\n    # Warp top and plot in 3D\n    mesh.warp_by_scalar(**mesh_kwargs).plot(**kwargs)\n</code></pre>"},{"location":"common/#geojp.common.pmtiles_header","title":"<code>pmtiles_header(input_file)</code>","text":"<p>Fetch the header information from a local or remote .pmtiles file.</p> <p>This function retrieves the header from a PMTiles file, either local or hosted remotely. It deserializes the header and calculates the center and bounds of the tiles from the given metadata in the header.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the .pmtiles file, or its URL if the file is hosted remotely.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the header information, including center and bounds.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the pmtiles library is not installed.</p> <code>ValueError</code> <p>If the input file is not a .pmtiles file or if it does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; header = pmtiles_header(\"https://example.com/path/to/tiles.pmtiles\")\n&gt;&gt;&gt; print(header[\"center\"])\n[52.5200, 13.4050]\n</code></pre> <p>Note</p> <p>If fetching a remote PMTiles file, this function only downloads the first 127 bytes of the file to retrieve the header.</p> Source code in <code>geojp/common.py</code> <pre><code>def pmtiles_header(input_file: str):\n    \"\"\"\n    Fetch the header information from a local or remote .pmtiles file.\n\n    This function retrieves the header from a PMTiles file, either local or hosted remotely.\n    It deserializes the header and calculates the center and bounds of the tiles from the\n    given metadata in the header.\n\n    Args:\n        input_file (str): Path to the .pmtiles file, or its URL if the file is hosted remotely.\n\n    Returns:\n        dict: A dictionary containing the header information, including center and bounds.\n\n    Raises:\n        ImportError: If the pmtiles library is not installed.\n        ValueError: If the input file is not a .pmtiles file or if it does not exist.\n\n    Example:\n        &gt;&gt;&gt; header = pmtiles_header(\"https://example.com/path/to/tiles.pmtiles\")\n        &gt;&gt;&gt; print(header[\"center\"])\n        [52.5200, 13.4050]\n\n    Note:\n        If fetching a remote PMTiles file, this function only downloads the first 127 bytes\n        of the file to retrieve the header.\n    \"\"\"\n\n    import requests\n    from urllib.parse import urlparse\n\n    try:\n        from pmtiles.reader import Reader, MmapSource\n        from pmtiles.tile import deserialize_header\n    except ImportError:\n        print(\n            \"pmtiles is not installed. Please install it using `pip install pmtiles`.\"\n        )\n        return\n    if not urlparse(input_file).path.endswith(\".pmtiles\"):\n        raise ValueError(\"Input file must be a .pmtiles file.\")\n\n    if input_file.startswith(\"http\"):\n        # Fetch only the first 127 bytes\n        headers = {\"Range\": \"bytes=0-127\"}\n        response = requests.get(input_file, headers=headers)\n        header = deserialize_header(response.content)\n\n    else:\n        if not os.path.exists(input_file):\n            raise ValueError(f\"Input file {input_file} does not exist.\")\n\n        with open(input_file, \"rb\") as f:\n            reader = Reader(MmapSource(f))\n            header = reader.header()\n\n    header[\"center\"] = [header[\"center_lat_e7\"] / 1e7, header[\"center_lon_e7\"] / 1e7]\n    header[\"bounds\"] = [\n        header[\"min_lon_e7\"] / 1e7,\n        header[\"min_lat_e7\"] / 1e7,\n        header[\"max_lon_e7\"] / 1e7,\n        header[\"max_lat_e7\"] / 1e7,\n    ]\n\n    return header\n</code></pre>"},{"location":"common/#geojp.common.pmtiles_metadata","title":"<code>pmtiles_metadata(input_file)</code>","text":"<p>Fetch the metadata from a local or remote .pmtiles file.</p> <p>This function retrieves metadata from a PMTiles file, whether it's local or hosted remotely. If it's remote, the function fetches the header to determine the range of bytes to download for obtaining the metadata. It then reads the metadata and extracts the layer names.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the .pmtiles file, or its URL if the file is hosted remotely.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the metadata information, including layer names.</p> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the pmtiles library is not installed.</p> <code>ValueError</code> <p>If the input file is not a .pmtiles file or if it does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; metadata = pmtiles_metadata(\"https://example.com/path/to/tiles.pmtiles\")\n&gt;&gt;&gt; print(metadata[\"layer_names\"])\n['buildings', 'roads']\n</code></pre> <p>Note</p> <p>If fetching a remote PMTiles file, this function may perform multiple requests to minimize the amount of data downloaded.</p> Source code in <code>geojp/common.py</code> <pre><code>def pmtiles_metadata(input_file: str) -&gt; Dict[str, Union[str, int, List[str]]]:\n    \"\"\"\n    Fetch the metadata from a local or remote .pmtiles file.\n\n    This function retrieves metadata from a PMTiles file, whether it's local or hosted remotely.\n    If it's remote, the function fetches the header to determine the range of bytes to download\n    for obtaining the metadata. It then reads the metadata and extracts the layer names.\n\n    Args:\n        input_file (str): Path to the .pmtiles file, or its URL if the file is hosted remotely.\n\n    Returns:\n        dict: A dictionary containing the metadata information, including layer names.\n\n    Raises:\n        ImportError: If the pmtiles library is not installed.\n        ValueError: If the input file is not a .pmtiles file or if it does not exist.\n\n    Example:\n        &gt;&gt;&gt; metadata = pmtiles_metadata(\"https://example.com/path/to/tiles.pmtiles\")\n        &gt;&gt;&gt; print(metadata[\"layer_names\"])\n        ['buildings', 'roads']\n\n    Note:\n        If fetching a remote PMTiles file, this function may perform multiple requests to minimize\n        the amount of data downloaded.\n    \"\"\"\n\n    import json\n    import requests\n    from urllib.parse import urlparse\n\n    try:\n        from pmtiles.reader import Reader, MmapSource, MemorySource\n    except ImportError:\n        print(\n            \"pmtiles is not installed. Please install it using `pip install pmtiles`.\"\n        )\n        return\n\n    # ignore uri parameters when checking file suffix\n    if not urlparse(input_file).path.endswith(\".pmtiles\"):\n        raise ValueError(\"Input file must be a .pmtiles file.\")\n\n    header = pmtiles_header(input_file)\n    metadata_offset = header[\"metadata_offset\"]\n    metadata_length = header[\"metadata_length\"]\n\n    if input_file.startswith(\"http\"):\n        headers = {\"Range\": f\"bytes=0-{metadata_offset + metadata_length}\"}\n        response = requests.get(input_file, headers=headers)\n        content = MemorySource(response.content)\n        metadata = Reader(content).metadata()\n    else:\n        with open(input_file, \"rb\") as f:\n            reader = Reader(MmapSource(f))\n            metadata = reader.metadata()\n            if \"json\" in metadata:\n                metadata[\"vector_layers\"] = json.loads(metadata[\"json\"])[\n                    \"vector_layers\"\n                ]\n\n    vector_layers = metadata[\"vector_layers\"]\n    layer_names = [layer[\"id\"] for layer in vector_layers]\n\n    if \"tilestats\" in metadata:\n        geometries = [layer[\"geometry\"] for layer in metadata[\"tilestats\"][\"layers\"]]\n        metadata[\"geometries\"] = geometries\n\n    metadata[\"layer_names\"] = layer_names\n    metadata[\"center\"] = header[\"center\"]\n    metadata[\"bounds\"] = header[\"bounds\"]\n    return metadata\n</code></pre>"},{"location":"common/#geojp.common.pmtiles_style","title":"<code>pmtiles_style(url, layers=None, cmap='Set3', n_class=None, opacity=0.5, circle_radius=5, line_width=1, attribution='PMTiles', **kwargs)</code>","text":"<p>Generates a Mapbox style JSON for rendering PMTiles data.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the PMTiles file.</p> required <code>layers</code> <code>str or list[str]</code> <p>The layers to include in the style. If None, all layers will be included. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>The color map to use for styling the layers. Defaults to \"Set3\".</p> <code>'Set3'</code> <code>n_class</code> <code>int</code> <p>The number of classes to use for styling. If None, the number of classes will be determined automatically based on the color map. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The fill opacity for polygon layers. Defaults to 0.5.</p> <code>0.5</code> <code>circle_radius</code> <code>int</code> <p>The circle radius for point layers. Defaults to 5.</p> <code>5</code> <code>line_width</code> <code>int</code> <p>The line width for line layers. Defaults to 1.</p> <code>1</code> <code>attribution</code> <code>str</code> <p>The attribution text for the data source. Defaults to \"PMTiles\".</p> <code>'PMTiles'</code> <p>Returns:</p> Type Description <code>dict</code> <p>The Mapbox style JSON.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the layers argument is not a string or a list.</p> <code>ValueError</code> <p>If a layer specified in the layers argument does not exist in the PMTiles file.</p> Source code in <code>geojp/common.py</code> <pre><code>def pmtiles_style(\n    url: str,\n    layers: Optional[Union[str, List[str]]] = None,\n    cmap: str = \"Set3\",\n    n_class: Optional[int] = None,\n    opacity: float = 0.5,\n    circle_radius: int = 5,\n    line_width: int = 1,\n    attribution: str = \"PMTiles\",\n    **kwargs,\n):\n    \"\"\"\n    Generates a Mapbox style JSON for rendering PMTiles data.\n\n    Args:\n        url (str): The URL of the PMTiles file.\n        layers (str or list[str], optional): The layers to include in the style. If None, all layers will be included.\n            Defaults to None.\n        cmap (str, optional): The color map to use for styling the layers. Defaults to \"Set3\".\n        n_class (int, optional): The number of classes to use for styling. If None, the number of classes will be\n            determined automatically based on the color map. Defaults to None.\n        opacity (float, optional): The fill opacity for polygon layers. Defaults to 0.5.\n        circle_radius (int, optional): The circle radius for point layers. Defaults to 5.\n        line_width (int, optional): The line width for line layers. Defaults to 1.\n        attribution (str, optional): The attribution text for the data source. Defaults to \"PMTiles\".\n\n    Returns:\n        dict: The Mapbox style JSON.\n\n    Raises:\n        ValueError: If the layers argument is not a string or a list.\n        ValueError: If a layer specified in the layers argument does not exist in the PMTiles file.\n    \"\"\"\n\n    if cmap == \"Set3\":\n        palette = [\n            \"#8dd3c7\",\n            \"#ffffb3\",\n            \"#bebada\",\n            \"#fb8072\",\n            \"#80b1d3\",\n            \"#fdb462\",\n            \"#b3de69\",\n            \"#fccde5\",\n            \"#d9d9d9\",\n            \"#bc80bd\",\n            \"#ccebc5\",\n            \"#ffed6f\",\n        ]\n    elif isinstance(cmap, list):\n        palette = cmap\n    else:\n        from .colormaps import get_palette\n\n        palette = [\"#\" + c for c in get_palette(cmap, n_class)]\n\n    n_class = len(palette)\n\n    metadata = pmtiles_metadata(url)\n    layer_names = metadata[\"layer_names\"]\n\n    style = {\n        \"version\": 8,\n        \"sources\": {\n            \"source\": {\n                \"type\": \"vector\",\n                \"url\": \"pmtiles://\" + url,\n                \"attribution\": attribution,\n            }\n        },\n        \"layers\": [],\n    }\n\n    if layers is None:\n        layers = layer_names\n    elif isinstance(layers, str):\n        layers = [layers]\n    elif isinstance(layers, list):\n        for layer in layers:\n            if layer not in layer_names:\n                raise ValueError(f\"Layer {layer} does not exist in the PMTiles file.\")\n    else:\n        raise ValueError(\"The layers argument must be a string or a list.\")\n\n    for i, layer_name in enumerate(layers):\n        layer_point = {\n            \"id\": f\"{layer_name}_point\",\n            \"source\": \"source\",\n            \"source-layer\": layer_name,\n            \"type\": \"circle\",\n            \"paint\": {\n                \"circle-color\": palette[i % n_class],\n                \"circle-radius\": circle_radius,\n            },\n            \"filter\": [\"==\", [\"geometry-type\"], \"Point\"],\n        }\n\n        layer_stroke = {\n            \"id\": f\"{layer_name}_stroke\",\n            \"source\": \"source\",\n            \"source-layer\": layer_name,\n            \"type\": \"line\",\n            \"paint\": {\n                \"line-color\": palette[i % n_class],\n                \"line-width\": line_width,\n            },\n            \"filter\": [\"==\", [\"geometry-type\"], \"LineString\"],\n        }\n\n        layer_fill = {\n            \"id\": f\"{layer_name}_fill\",\n            \"source\": \"source\",\n            \"source-layer\": layer_name,\n            \"type\": \"fill\",\n            \"paint\": {\n                \"fill-color\": palette[i % n_class],\n                \"fill-opacity\": opacity,\n            },\n            \"filter\": [\"==\", [\"geometry-type\"], \"Polygon\"],\n        }\n\n        style[\"layers\"].extend([layer_point, layer_stroke, layer_fill])\n\n    return style\n</code></pre>"},{"location":"common/#geojp.common.png_to_gif","title":"<code>png_to_gif(in_dir, out_gif, fps=10, loop=0)</code>","text":"<p>Convert a list of png images to gif.</p> <p>Parameters:</p> Name Type Description Default <code>in_dir</code> <code>str</code> <p>The input directory containing png images.</p> required <code>out_gif</code> <code>str</code> <p>The output file path to the gif.</p> required <code>fps</code> <code>int</code> <p>Frames per second. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>bool</code> <p>controls how many times the animation repeats. 1 means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.</p> <code>0</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>No png images could be found.</p> Source code in <code>geojp/common.py</code> <pre><code>def png_to_gif(in_dir, out_gif, fps=10, loop=0):\n    \"\"\"Convert a list of png images to gif.\n\n    Args:\n        in_dir (str): The input directory containing png images.\n        out_gif (str): The output file path to the gif.\n        fps (int, optional): Frames per second. Defaults to 10.\n        loop (bool, optional): controls how many times the animation repeats. 1 means that the animation will play once and then stop (displaying the last frame). A value of 0 means that the animation will repeat forever. Defaults to 0.\n\n    Raises:\n        FileNotFoundError: No png images could be found.\n    \"\"\"\n    import glob\n\n    from PIL import Image\n\n    if not out_gif.endswith(\".gif\"):\n        raise ValueError(\"The out_gif must be a gif file.\")\n\n    out_gif = os.path.abspath(out_gif)\n\n    out_dir = os.path.dirname(out_gif)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    # Create the frames\n    frames = []\n    imgs = list(glob.glob(os.path.join(in_dir, \"*.png\")))\n    imgs.sort()\n\n    if len(imgs) == 0:\n        raise FileNotFoundError(f\"No png could be found in {in_dir}.\")\n\n    for i in imgs:\n        new_frame = Image.open(i)\n        frames.append(new_frame)\n\n    # Save into a GIF file that loops forever\n    frames[0].save(\n        out_gif,\n        format=\"GIF\",\n        append_images=frames[1:],\n        save_all=True,\n        duration=1000 / fps,\n        loop=loop,\n    )\n</code></pre>"},{"location":"common/#geojp.common.points_from_xy","title":"<code>points_from_xy(data, x='longitude', y='latitude', z=None, crs=None, **kwargs)</code>","text":"<p>Create a GeoPandas GeoDataFrame from a csv or Pandas DataFrame containing x, y, z values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | pd.DataFrame</code> <p>A csv or Pandas DataFrame containing x, y, z values.</p> required <code>x</code> <code>str</code> <p>The column name for the x values. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>y</code> <code>str</code> <p>The column name for the y values. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>z</code> <code>str</code> <p>The column name for the z values. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str | int</code> <p>The coordinate reference system for the GeoDataFrame. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>geopandas.GeoDataFrame</code> <p>A GeoPandas GeoDataFrame containing x, y, z values.</p> Source code in <code>geojp/common.py</code> <pre><code>def points_from_xy(data, x=\"longitude\", y=\"latitude\", z=None, crs=None, **kwargs):\n    \"\"\"Create a GeoPandas GeoDataFrame from a csv or Pandas DataFrame containing x, y, z values.\n\n    Args:\n        data (str | pd.DataFrame): A csv or Pandas DataFrame containing x, y, z values.\n        x (str, optional): The column name for the x values. Defaults to \"longitude\".\n        y (str, optional): The column name for the y values. Defaults to \"latitude\".\n        z (str, optional): The column name for the z values. Defaults to None.\n        crs (str | int, optional): The coordinate reference system for the GeoDataFrame. Defaults to None.\n\n    Returns:\n        geopandas.GeoDataFrame: A GeoPandas GeoDataFrame containing x, y, z values.\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import pandas as pd\n\n    if crs is None:\n        crs = \"epsg:4326\"\n\n    if isinstance(data, pd.DataFrame):\n        df = data\n    elif isinstance(data, str):\n        if not data.startswith(\"http\") and (not os.path.exists(data)):\n            raise FileNotFoundError(\"The specified input csv does not exist.\")\n        else:\n            df = pd.read_csv(data, **kwargs)\n    else:\n        raise TypeError(\"The data must be a pandas DataFrame or a csv file path.\")\n\n    gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df[x], df[y], z=z, crs=crs))\n\n    return gdf\n</code></pre>"},{"location":"common/#geojp.common.random_string","title":"<code>random_string(string_length=3)</code>","text":"<p>Generates a random string of fixed length.</p> <p>Parameters:</p> Name Type Description Default <code>string_length</code> <code>int</code> <p>Fixed length. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>str</code> <p>A random string</p> Source code in <code>geojp/common.py</code> <pre><code>def random_string(string_length: Optional[int] = 3) -&gt; str:\n    \"\"\"Generates a random string of fixed length.\n\n    Args:\n        string_length (int, optional): Fixed length. Defaults to 3.\n\n    Returns:\n        str: A random string\n    \"\"\"\n    import random\n    import string\n\n    # random.seed(1001)\n    letters = string.ascii_lowercase\n    return \"\".join(random.choice(letters) for i in range(string_length))\n</code></pre>"},{"location":"common/#geojp.common.raster_to_vector","title":"<code>raster_to_vector(source, output, simplify_tolerance=None, dst_crs=None, open_args={}, **kwargs)</code>","text":"<p>Vectorize a raster dataset.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the tiff file.</p> required <code>output</code> <code>str</code> <p>The path to the vector file.</p> required <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>geojp/common.py</code> <pre><code>def raster_to_vector(\n    source, output, simplify_tolerance=None, dst_crs=None, open_args={}, **kwargs\n):\n    \"\"\"Vectorize a raster dataset.\n\n    Args:\n        source (str): The path to the tiff file.\n        output (str): The path to the vector file.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n    \"\"\"\n    import rasterio\n    import shapely\n    import geopandas as gpd\n    from rasterio import features\n\n    with rasterio.open(source, **open_args) as src:\n        band = src.read()\n\n        mask = band != 0\n        shapes = features.shapes(band, mask=mask, transform=src.transform)\n\n    fc = [\n        {\"geometry\": shapely.geometry.shape(shape), \"properties\": {\"value\": value}}\n        for shape, value in shapes\n    ]\n    if simplify_tolerance is not None:\n        for i in fc:\n            i[\"geometry\"] = i[\"geometry\"].simplify(tolerance=simplify_tolerance)\n\n    gdf = gpd.GeoDataFrame.from_features(fc)\n    if src.crs is not None:\n        gdf.set_crs(crs=src.crs, inplace=True)\n\n    if dst_crs is not None:\n        gdf = gdf.to_crs(dst_crs)\n\n    gdf.to_file(output, **kwargs)\n</code></pre>"},{"location":"common/#geojp.common.read_file_from_url","title":"<code>read_file_from_url(url, return_type='list', encoding='utf-8')</code>","text":"<p>Reads a file from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file.</p> required <code>return_type</code> <code>str</code> <p>The return type, can either be string or list. Defaults to \"list\".</p> <code>'list'</code> <code>encoding</code> <code>str</code> <p>The encoding of the file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>The return type must be either list or string.</p> <p>Returns:</p> Type Description <code>str | list</code> <p>The contents of the file.</p> Source code in <code>geojp/common.py</code> <pre><code>def read_file_from_url(url, return_type=\"list\", encoding=\"utf-8\"):\n    \"\"\"Reads a file from a URL.\n\n    Args:\n        url (str): The URL of the file.\n        return_type (str, optional): The return type, can either be string or list. Defaults to \"list\".\n        encoding (str, optional): The encoding of the file. Defaults to \"utf-8\".\n\n    Raises:\n        ValueError: The return type must be either list or string.\n\n    Returns:\n        str | list: The contents of the file.\n    \"\"\"\n    from urllib.request import urlopen\n\n    if return_type == \"list\":\n        return [line.decode(encoding).rstrip() for line in urlopen(url).readlines()]\n    elif return_type == \"string\":\n        return urlopen(url).read().decode(encoding)\n    else:\n        raise ValueError(\"The return type must be either list or string.\")\n</code></pre>"},{"location":"common/#geojp.common.read_lidar","title":"<code>read_lidar(filename, **kwargs)</code>","text":"<p>Read a LAS file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>A local file path or HTTP URL to a LAS file.</p> required <p>Returns:</p> Type Description <code>LasData</code> <p>The LasData object return by laspy.read.</p> Source code in <code>geojp/common.py</code> <pre><code>def read_lidar(filename, **kwargs):\n    \"\"\"Read a LAS file.\n\n    Args:\n        filename (str): A local file path or HTTP URL to a LAS file.\n\n    Returns:\n        LasData: The LasData object return by laspy.read.\n    \"\"\"\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if (\n        isinstance(filename, str)\n        and filename.startswith(\"http\")\n        and (filename.endswith(\".las\") or filename.endswith(\".laz\"))\n    ):\n        filename = github_raw_url(filename)\n        filename = download_file(filename)\n\n    return laspy.read(filename, **kwargs)\n</code></pre>"},{"location":"common/#geojp.common.read_netcdf","title":"<code>read_netcdf(filename, **kwargs)</code>","text":"<p>Read a netcdf file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File path or HTTP URL to the netcdf file.</p> required <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If the xarray or rioxarray package is not installed.</p> <code>FileNotFoundError</code> <p>If the netcdf file is not found.</p> <p>Returns:</p> Type Description <code>xarray.Dataset</code> <p>The netcdf file as an xarray dataset.</p> Source code in <code>geojp/common.py</code> <pre><code>def read_netcdf(filename, **kwargs):\n    \"\"\"Read a netcdf file.\n\n    Args:\n        filename (str): File path or HTTP URL to the netcdf file.\n\n    Raises:\n        ImportError: If the xarray or rioxarray package is not installed.\n        FileNotFoundError: If the netcdf file is not found.\n\n    Returns:\n        xarray.Dataset: The netcdf file as an xarray dataset.\n    \"\"\"\n    try:\n        import xarray as xr\n    except ImportError as e:\n        raise ImportError(e)\n\n    if filename.startswith(\"http\"):\n        filename = download_file(filename)\n\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    xds = xr.open_dataset(filename, **kwargs)\n    return xds\n</code></pre>"},{"location":"common/#geojp.common.read_parquet","title":"<code>read_parquet(source, geometry=None, columns=None, exclude=None, db=None, table_name=None, sql=None, limit=None, src_crs=None, dst_crs=None, return_type='gdf', **kwargs)</code>","text":"<p>Read Parquet data from a source and return a GeoDataFrame or DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the Parquet file or directory containing Parquet files.</p> required <code>geometry</code> <code>str</code> <p>The name of the geometry column. Defaults to None.</p> <code>None</code> <code>columns</code> <code>str or list</code> <p>The columns to select. Defaults to None (select all columns).</p> <code>None</code> <code>exclude</code> <code>str or list</code> <p>The columns to exclude from the selection. Defaults to None.</p> <code>None</code> <code>db</code> <code>str</code> <p>The DuckDB database path or alias. Defaults to None.</p> <code>None</code> <code>table_name</code> <code>str</code> <p>The name of the table in the DuckDB database. Defaults to None.</p> <code>None</code> <code>sql</code> <code>str</code> <p>The SQL query to execute. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of rows to return. Defaults to None (return all rows).</p> <code>None</code> <code>src_crs</code> <code>str</code> <p>The source CRS (Coordinate Reference System) of the geometries. Defaults to None.</p> <code>None</code> <code>dst_crs</code> <code>str</code> <p>The target CRS to reproject the geometries. Defaults to None.</p> <code>None</code> <code>return_type</code> <code>str</code> <p>The type of object to return: - 'gdf': GeoDataFrame (default) - 'df': DataFrame - 'numpy': NumPy array - 'arrow': Arrow Table - 'polars': Polars DataFrame</p> <code>'gdf'</code> <code>**kwargs</code> <p>Additional keyword arguments that are passed to the DuckDB connection.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[gpd.GeoDataFrame, pd.DataFrame, np.ndarray]</code> <p>The loaded data.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the columns or exclude arguments are not of the correct type.</p> Source code in <code>geojp/common.py</code> <pre><code>def read_parquet(\n    source: str,\n    geometry: Optional[str] = None,\n    columns: Optional[Union[str, list]] = None,\n    exclude: Optional[Union[str, list]] = None,\n    db: Optional[str] = None,\n    table_name: Optional[str] = None,\n    sql: Optional[str] = None,\n    limit: Optional[int] = None,\n    src_crs: Optional[str] = None,\n    dst_crs: Optional[str] = None,\n    return_type: str = \"gdf\",\n    **kwargs,\n):\n    \"\"\"\n    Read Parquet data from a source and return a GeoDataFrame or DataFrame.\n\n    Args:\n        source (str): The path to the Parquet file or directory containing Parquet files.\n        geometry (str, optional): The name of the geometry column. Defaults to None.\n        columns (str or list, optional): The columns to select. Defaults to None (select all columns).\n        exclude (str or list, optional): The columns to exclude from the selection. Defaults to None.\n        db (str, optional): The DuckDB database path or alias. Defaults to None.\n        table_name (str, optional): The name of the table in the DuckDB database. Defaults to None.\n        sql (str, optional): The SQL query to execute. Defaults to None.\n        limit (int, optional): The maximum number of rows to return. Defaults to None (return all rows).\n        src_crs (str, optional): The source CRS (Coordinate Reference System) of the geometries. Defaults to None.\n        dst_crs (str, optional): The target CRS to reproject the geometries. Defaults to None.\n        return_type (str, optional): The type of object to return:\n            - 'gdf': GeoDataFrame (default)\n            - 'df': DataFrame\n            - 'numpy': NumPy array\n            - 'arrow': Arrow Table\n            - 'polars': Polars DataFrame\n        **kwargs: Additional keyword arguments that are passed to the DuckDB connection.\n\n    Returns:\n        Union[gpd.GeoDataFrame, pd.DataFrame, np.ndarray]: The loaded data.\n\n    Raises:\n        ValueError: If the columns or exclude arguments are not of the correct type.\n\n    \"\"\"\n    import duckdb\n\n    if isinstance(db, str):\n        con = duckdb.connect(db)\n    else:\n        con = duckdb.connect()\n\n    con.install_extension(\"httpfs\")\n    con.load_extension(\"httpfs\")\n\n    con.install_extension(\"spatial\")\n    con.load_extension(\"spatial\")\n\n    if columns is None:\n        columns = \"*\"\n    elif isinstance(columns, list):\n        columns = \", \".join(columns)\n    elif not isinstance(columns, str):\n        raise ValueError(\"columns must be a list or a string.\")\n\n    if exclude is not None:\n        if isinstance(exclude, list):\n            exclude = \", \".join(exclude)\n        elif not isinstance(exclude, str):\n            raise ValueError(\"exclude_columns must be a list or a string.\")\n        columns = f\"{columns} EXCLUDE {exclude}\"\n\n    if return_type in [\"df\", \"numpy\", \"arrow\", \"polars\"]:\n        if sql is None:\n            sql = f\"SELECT {columns} FROM '{source}'\"\n        if limit is not None:\n            sql += f\" LIMIT {limit}\"\n\n        if return_type == \"df\":\n            result = con.sql(sql, **kwargs).df()\n        elif return_type == \"numpy\":\n            result = con.sql(sql, **kwargs).fetchnumpy()\n        elif return_type == \"arrow\":\n            result = con.sql(sql, **kwargs).arrow()\n        elif return_type == \"polars\":\n            result = con.sql(sql, **kwargs).pl()\n\n        if table_name is not None:\n            con.sql(f\"CREATE OR REPLACE TABLE {table_name} AS FROM result\", **kwargs)\n\n    elif return_type == \"gdf\":\n        if geometry is None:\n            geometry = \"geometry\"\n        if sql is None:\n            # if src_crs is not None and dst_crs is not None:\n            #     geom_sql = f\"ST_AsText(ST_Transform(ST_GeomFromWKB({geometry}), '{src_crs}', '{dst_crs}', true)) AS {geometry}\"\n            # else:\n            geom_sql = f\"ST_AsText(ST_GeomFromWKB({geometry})) AS {geometry}\"\n            sql = f\"SELECT {columns} EXCLUDE {geometry}, {geom_sql} FROM '{source}'\"\n        if limit is not None:\n            sql += f\" LIMIT {limit}\"\n\n        df = con.sql(sql, **kwargs).df()\n        if table_name is not None:\n            con.sql(f\"CREATE OR REPLACE TABLE {table_name} AS FROM df\", **kwargs)\n        result = df_to_gdf(df, geometry=geometry, src_crs=src_crs, dst_crs=dst_crs)\n\n    con.close()\n    return result\n</code></pre>"},{"location":"common/#geojp.common.read_postgis","title":"<code>read_postgis(sql, con, geom_col='geom', crs=None, **kwargs)</code>","text":"<p>Reads data from a PostGIS database and returns a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>SQL query to execute in selecting entries from database, or name of the table to read from the database.</p> required <code>con</code> <code>sqlalchemy.engine.Engine</code> <p>Active connection to the database to query.</p> required <code>geom_col</code> <code>str</code> <p>Column name to convert to shapely geometries. Defaults to \"geom\".</p> <code>'geom'</code> <code>crs</code> <code>str | dict</code> <p>CRS to use for the returned GeoDataFrame; if not set, tries to determine CRS from the SRID associated with the first geometry in the database, and assigns that to all geometries. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>[type]</code> <p>[description]</p> Source code in <code>geojp/common.py</code> <pre><code>def read_postgis(sql, con, geom_col=\"geom\", crs=None, **kwargs):\n    \"\"\"Reads data from a PostGIS database and returns a GeoDataFrame.\n\n    Args:\n        sql (str): SQL query to execute in selecting entries from database, or name of the table to read from the database.\n        con (sqlalchemy.engine.Engine): Active connection to the database to query.\n        geom_col (str, optional): Column name to convert to shapely geometries. Defaults to \"geom\".\n        crs (str | dict, optional): CRS to use for the returned GeoDataFrame; if not set, tries to determine CRS from the SRID associated with the first geometry in the database, and assigns that to all geometries. Defaults to None.\n\n    Returns:\n        [type]: [description]\n    \"\"\"\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    gdf = gpd.read_postgis(sql, con, geom_col, crs, **kwargs)\n    return gdf\n</code></pre>"},{"location":"common/#geojp.common.read_raster","title":"<code>read_raster(source, window=None, return_array=True, coord_crs=None, request_payer='bucket-owner', env_args={}, open_args={}, **kwargs)</code>","text":"<p>Read a raster from S3.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the raster on S3.</p> required <code>window</code> <code>tuple</code> <p>The window (col_off, row_off, width, height) to read. Defaults to None.</p> <code>None</code> <code>return_array</code> <code>bool</code> <p>Whether to return a numpy array. Defaults to True.</p> <code>True</code> <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to None.</p> <code>None</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>env_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.Env(). Defaults to {}.</p> <code>{}</code> <code>open_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.open(). Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The raster as a numpy array.</p> Source code in <code>geojp/common.py</code> <pre><code>def read_raster(\n    source,\n    window=None,\n    return_array=True,\n    coord_crs=None,\n    request_payer=\"bucket-owner\",\n    env_args={},\n    open_args={},\n    **kwargs,\n):\n    \"\"\"Read a raster from S3.\n\n    Args:\n        source (str): The path to the raster on S3.\n        window (tuple, optional): The window (col_off, row_off, width, height) to read. Defaults to None.\n        return_array (bool, optional): Whether to return a numpy array. Defaults to True.\n        coord_crs (str, optional): The coordinate CRS of the input coordinates. Defaults to None.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        env_args (dict, optional): Additional arguments to pass to rasterio.Env(). Defaults to {}.\n        open_args (dict, optional): Additional arguments to pass to rasterio.open(). Defaults to {}.\n\n    Returns:\n        np.ndarray: The raster as a numpy array.\n    \"\"\"\n    import rasterio\n    from rasterio.windows import Window\n\n    with rasterio.Env(AWS_REQUEST_PAYER=request_payer, **env_args):\n        src = rasterio.open(source, **open_args)\n        if not return_array:\n            return src\n        else:\n            if window is None:\n                window = Window(0, 0, src.width, src.height)\n            else:\n                if isinstance(window, list):\n                    coords = coords_to_xy(\n                        source,\n                        window,\n                        coord_crs,\n                        env_args=env_args,\n                        open_args=open_args,\n                    )\n                    window = xy_to_window(coords)\n                window = Window(*window)\n\n            array = src.read(window=window, **kwargs)\n            return array\n</code></pre>"},{"location":"common/#geojp.common.read_rasters","title":"<code>read_rasters(sources, window=None, coord_crs=None, request_payer='bucket-owner', env_args={}, open_args={}, **kwargs)</code>","text":"<p>Read a raster from S3.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>str</code> <p>The list of paths to the raster files.</p> required <code>window</code> <code>tuple</code> <p>The window (col_off, row_off, width, height) to read. Defaults to None.</p> <code>None</code> <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to None.</p> <code>None</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>env_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.Env(). Defaults to {}.</p> <code>{}</code> <code>open_args</code> <code>dict</code> <p>Additional arguments to pass to rasterio.open(). Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The raster as a numpy array.</p> Source code in <code>geojp/common.py</code> <pre><code>def read_rasters(\n    sources,\n    window=None,\n    coord_crs=None,\n    request_payer=\"bucket-owner\",\n    env_args={},\n    open_args={},\n    **kwargs,\n):\n    \"\"\"Read a raster from S3.\n\n    Args:\n        sources (str): The list of paths to the raster files.\n        window (tuple, optional): The window (col_off, row_off, width, height) to read. Defaults to None.\n        coord_crs (str, optional): The coordinate CRS of the input coordinates. Defaults to None.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        env_args (dict, optional): Additional arguments to pass to rasterio.Env(). Defaults to {}.\n        open_args (dict, optional): Additional arguments to pass to rasterio.open(). Defaults to {}.\n\n    Returns:\n        np.ndarray: The raster as a numpy array.\n    \"\"\"\n    import numpy as np\n\n    if not isinstance(sources, list):\n        sources = [sources]\n\n    array_list = []\n\n    for source in sources:\n        array = read_raster(\n            source,\n            window,\n            True,\n            coord_crs,\n            request_payer,\n            env_args,\n            open_args,\n            **kwargs,\n        )\n        array_list.append(array)\n\n    result = np.concatenate(array_list, axis=0)\n    return result\n</code></pre>"},{"location":"common/#geojp.common.reduce_gif_size","title":"<code>reduce_gif_size(in_gif, out_gif=None)</code>","text":"<p>Reduces a GIF image using ffmpeg.</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The input file path to the GIF image.</p> required <code>out_gif</code> <code>str</code> <p>The output file path to the GIF image. Defaults to None.</p> <code>None</code> Source code in <code>geojp/common.py</code> <pre><code>def reduce_gif_size(in_gif, out_gif=None):\n    \"\"\"Reduces a GIF image using ffmpeg.\n\n    Args:\n        in_gif (str): The input file path to the GIF image.\n        out_gif (str, optional): The output file path to the GIF image. Defaults to None.\n    \"\"\"\n\n    try:\n        import ffmpeg\n    except ImportError:\n        print(\"ffmpeg is not installed on your computer. Skip reducing gif size.\")\n        return\n\n    warnings.filterwarnings(\"ignore\")\n\n    if not is_tool(\"ffmpeg\"):\n        print(\"ffmpeg is not installed on your computer. Skip reducing gif size.\")\n        return\n\n    if not os.path.exists(in_gif):\n        print(\"The input gif file does not exist.\")\n        return\n\n    if out_gif is None:\n        out_gif = in_gif\n    elif not os.path.exists(os.path.dirname(out_gif)):\n        os.makedirs(os.path.dirname(out_gif))\n\n    if in_gif == out_gif:\n        tmp_gif = in_gif.replace(\".gif\", \"_tmp.gif\")\n        shutil.copyfile(in_gif, tmp_gif)\n        stream = ffmpeg.input(tmp_gif)\n        stream = ffmpeg.output(stream, in_gif, loglevel=\"quiet\").overwrite_output()\n        ffmpeg.run(stream)\n        os.remove(tmp_gif)\n\n    else:\n        stream = ffmpeg.input(in_gif)\n        stream = ffmpeg.output(stream, out_gif, loglevel=\"quiet\").overwrite_output()\n        ffmpeg.run(stream)\n</code></pre>"},{"location":"common/#geojp.common.regularize","title":"<code>regularize(source, output=None, crs='EPSG:4326', **kwargs)</code>","text":"<p>Regularize a polygon GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | gpd.GeoDataFrame</code> <p>The input file path or a GeoDataFrame.</p> required <code>output</code> <code>str</code> <p>The output file path. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The output GeoDataFrame.</p> Source code in <code>geojp/common.py</code> <pre><code>def regularize(source, output=None, crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Regularize a polygon GeoDataFrame.\n\n    Args:\n        source (str | gpd.GeoDataFrame): The input file path or a GeoDataFrame.\n        output (str, optional): The output file path. Defaults to None.\n\n\n    Returns:\n        gpd.GeoDataFrame: The output GeoDataFrame.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(source, str):\n        gdf = gpd.read_file(source)\n    elif isinstance(source, gpd.GeoDataFrame):\n        gdf = source\n    else:\n        raise ValueError(\"The input source must be a GeoDataFrame or a file path.\")\n\n    polygons = gdf.geometry.apply(lambda geom: geom.minimum_rotated_rectangle)\n    result = gpd.GeoDataFrame(geometry=polygons, data=gdf.drop(\"geometry\", axis=1))\n\n    if crs is not None:\n        result.to_crs(crs, inplace=True)\n    if output is not None:\n        result.to_file(output, **kwargs)\n    else:\n        return result\n</code></pre>"},{"location":"common/#geojp.common.reproject","title":"<code>reproject(image, output, dst_crs='EPSG:4326', resampling='nearest', to_cog=True, **kwargs)</code>","text":"<p>Reprojects an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath.</p> required <code>output</code> <code>str</code> <p>The output image filepath.</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>resampling</code> <code>Resampling</code> <p>The resampling method. Defaults to \"nearest\".</p> <code>'nearest'</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to rasterio.open.</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def reproject(\n    image, output, dst_crs=\"EPSG:4326\", resampling=\"nearest\", to_cog=True, **kwargs\n):\n    \"\"\"Reprojects an image.\n\n    Args:\n        image (str): The input image filepath.\n        output (str): The output image filepath.\n        dst_crs (str, optional): The destination CRS. Defaults to \"EPSG:4326\".\n        resampling (Resampling, optional): The resampling method. Defaults to \"nearest\".\n        to_cog (bool, optional): Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to rasterio.open.\n\n    \"\"\"\n    import rasterio as rio\n    from rasterio.warp import calculate_default_transform, reproject, Resampling\n\n    if isinstance(resampling, str):\n        resampling = getattr(Resampling, resampling)\n\n    image = os.path.abspath(image)\n    output = os.path.abspath(output)\n\n    if not os.path.exists(os.path.dirname(output)):\n        os.makedirs(os.path.dirname(output))\n\n    with rio.open(image, **kwargs) as src:\n        transform, width, height = calculate_default_transform(\n            src.crs, dst_crs, src.width, src.height, *src.bounds\n        )\n        kwargs = src.meta.copy()\n        kwargs.update(\n            {\n                \"crs\": dst_crs,\n                \"transform\": transform,\n                \"width\": width,\n                \"height\": height,\n            }\n        )\n\n        with rio.open(output, \"w\", **kwargs) as dst:\n            for i in range(1, src.count + 1):\n                reproject(\n                    source=rio.band(src, i),\n                    destination=rio.band(dst, i),\n                    src_transform=src.transform,\n                    src_crs=src.crs,\n                    dst_transform=transform,\n                    dst_crs=dst_crs,\n                    resampling=resampling,\n                    **kwargs,\n                )\n\n    if to_cog:\n        image_to_cog(output, output)\n</code></pre>"},{"location":"common/#geojp.common.rgb_to_hex","title":"<code>rgb_to_hex(rgb=(255, 255, 255))</code>","text":"<p>Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255.</p> <p>Parameters:</p> Name Type Description Default <code>rgb</code> <code>tuple</code> <p>RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255).</p> <code>(255, 255, 255)</code> <p>Returns:</p> Type Description <code>str</code> <p>hex color code</p> Source code in <code>geojp/common.py</code> <pre><code>def rgb_to_hex(rgb: Optional[Tuple[int, int, int]] = (255, 255, 255)) -&gt; str:\n    \"\"\"Converts RGB to hex color. In RGB color R stands for Red, G stands for Green, and B stands for Blue, and it ranges from the decimal value of 0 \u2013 255.\n\n    Args:\n        rgb (tuple, optional): RGB color code as a tuple of (red, green, blue). Defaults to (255, 255, 255).\n\n    Returns:\n        str: hex color code\n    \"\"\"\n    return \"%02x%02x%02x\" % rgb\n</code></pre>"},{"location":"common/#geojp.common.s3_download_file","title":"<code>s3_download_file(filename=None, bucket=None, key=None, outfile=None, **kwargs)</code>","text":"<p>Download a file from S3.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The full path to the file. Defaults to None.</p> <code>None</code> <code>bucket</code> <code>str</code> <p>The name of the bucket. Defaults to None.</p> <code>None</code> <code>key</code> <code>str</code> <p>The key of the file. Defaults to None.</p> <code>None</code> <code>outfile</code> <code>str</code> <p>The name of the output file. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If boto3 is not installed.</p> Source code in <code>geojp/common.py</code> <pre><code>def s3_download_file(filename=None, bucket=None, key=None, outfile=None, **kwargs):\n    \"\"\"Download a file from S3.\n\n    Args:\n        filename (str, optional): The full path to the file. Defaults to None.\n        bucket (str, optional): The name of the bucket. Defaults to None.\n        key (str, optional): The key of the file. Defaults to None.\n        outfile (str, optional): The name of the output file. Defaults to None.\n    Raises:\n        ImportError: If boto3 is not installed.\n    \"\"\"\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    client = boto3.client(\"s3\", **kwargs)\n\n    if filename is not None:\n        bucket = filename.split(\"/\")[2]\n        key = \"/\".join(filename.split(\"/\")[3:])\n\n    if outfile is None:\n        outfile = key.split(\"/\")[-1]\n\n    if not os.path.exists(outfile):\n        client.download_file(bucket, key, outfile)\n    else:\n        print(f\"File already exists: {outfile}\")\n</code></pre>"},{"location":"common/#geojp.common.s3_download_files","title":"<code>s3_download_files(filenames=None, bucket=None, keys=None, outdir=None, quiet=False, **kwargs)</code>","text":"<p>Download multiple files from S3.</p> <p>Parameters:</p> Name Type Description Default <code>filenames</code> <code>list</code> <p>A list of filenames. Defaults to None.</p> <code>None</code> <code>bucket</code> <code>str</code> <p>The name of the bucket. Defaults to None.</p> <code>None</code> <code>keys</code> <code>list</code> <p>A list of keys. Defaults to None.</p> <code>None</code> <code>outdir</code> <code>str</code> <p>The name of the output directory. Defaults to None.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If neither filenames or keys are provided.</p> Source code in <code>geojp/common.py</code> <pre><code>def s3_download_files(\n    filenames=None, bucket=None, keys=None, outdir=None, quiet=False, **kwargs\n):\n    \"\"\"Download multiple files from S3.\n\n    Args:\n        filenames (list, optional): A list of filenames. Defaults to None.\n        bucket (str, optional): The name of the bucket. Defaults to None.\n        keys (list, optional): A list of keys. Defaults to None.\n        outdir (str, optional): The name of the output directory. Defaults to None.\n        quiet (bool, optional): Suppress output. Defaults to False.\n\n    Raises:\n        ValueError: If neither filenames or keys are provided.\n    \"\"\"\n\n    if keys is None:\n        keys = []\n\n    if filenames is not None:\n        if isinstance(filenames, list):\n            for filename in filenames:\n                bucket = filename.split(\"/\")[2]\n                key = \"/\".join(filename.split(\"/\")[3:])\n                keys.append(key)\n    elif filenames is None and keys is None:\n        raise ValueError(\"Either filenames or keys must be provided\")\n\n    for index, key in enumerate(keys):\n        if outdir is not None:\n            if not os.path.exists(outdir):\n                os.makedirs(outdir)\n            outfile = os.path.join(outdir, key.split(\"/\")[-1])\n        else:\n            outfile = key.split(\"/\")[-1]\n\n        if not quiet:\n            print(f\"Downloading {index+1} of {len(keys)}: {outfile}\")\n        s3_download_file(bucket=bucket, key=key, outfile=outfile, **kwargs)\n</code></pre>"},{"location":"common/#geojp.common.s3_get_object","title":"<code>s3_get_object(bucket, key, output=None, chunk_size=1048576, request_payer='bucket-owner', quiet=False, client_args={}, **kwargs)</code>","text":"<p>Download a file from S3.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the bucket.</p> required <code>key</code> <code>key</code> <p>The key of the file.</p> required <code>output</code> <code>str</code> <p>The name of the output file. Defaults to None.</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>The chunk size in bytes. Defaults to 1024 * 1024.</p> <code>1048576</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3.</p> <code>'bucket-owner'</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>False</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to boto3.client(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional arguments to pass to boto3.client().get_object().</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def s3_get_object(\n    bucket,\n    key,\n    output=None,\n    chunk_size=1024 * 1024,\n    request_payer=\"bucket-owner\",\n    quiet=False,\n    client_args={},\n    **kwargs,\n):\n    \"\"\"Download a file from S3.\n\n    Args:\n        bucket (str): The name of the bucket.\n        key (key): The key of the file.\n        output (str, optional): The name of the output file. Defaults to None.\n        chunk_size (int, optional): The chunk size in bytes. Defaults to 1024 * 1024.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n        quiet (bool, optional): Suppress output. Defaults to False.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        client_args (dict, optional): Additional arguments to pass to boto3.client(). Defaults to {}.\n        **kwargs: Additional arguments to pass to boto3.client().get_object().\n    \"\"\"\n\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    # Set up the S3 client\n    s3 = boto3.client(\"s3\", **client_args)\n\n    if output is None:\n        output = key.split(\"/\")[-1]\n\n    out_dir = os.path.dirname(os.path.abspath(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    # Set up the progress bar\n    def progress_callback(bytes_amount):\n        # This function will be called by the StreamingBody object\n        # to report the number of bytes downloaded so far\n        total_size = int(response[\"ContentLength\"])\n        progress_percent = int(bytes_amount / total_size * 100)\n        if not quiet:\n            print(f\"\\rDownloading: {progress_percent}% complete.\", end=\"\")\n\n    # Download the file\n    response = s3.get_object(\n        Bucket=bucket, Key=key, RequestPayer=request_payer, **kwargs\n    )\n\n    # Save the file to disk\n    with open(output, \"wb\") as f:\n        # Use the StreamingBody object to read the file in chunks\n        # and track the download progress\n        body = response[\"Body\"]\n        downloaded_bytes = 0\n        for chunk in body.iter_chunks(chunk_size=chunk_size):\n            f.write(chunk)\n            downloaded_bytes += len(chunk)\n            progress_callback(downloaded_bytes)\n</code></pre>"},{"location":"common/#geojp.common.s3_get_objects","title":"<code>s3_get_objects(bucket, keys=None, out_dir=None, prefix=None, limit=None, ext=None, chunk_size=1048576, request_payer='bucket-owner', quiet=True, client_args={}, **kwargs)</code>","text":"<p>Download multiple files from S3.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the bucket.</p> required <code>keys</code> <code>list</code> <p>A list of keys. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The name of the output directory. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>Limits the response to keys that begin with the specified prefix. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of keys returned in the response body.</p> <code>None</code> <code>ext</code> <code>str</code> <p>Filter by file extension. Defaults to None.</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>The chunk size in bytes. Defaults to 1024 * 1024.</p> <code>1048576</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to True.</p> <code>True</code> <code>client_args</code> <code>dict</code> <p>Additional arguments to pass to boto3.client(). Defaults to {}.</p> <code>{}</code> <code>**kwargs</code> <p>Additional arguments to pass to boto3.client().get_object().</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def s3_get_objects(\n    bucket,\n    keys=None,\n    out_dir=None,\n    prefix=None,\n    limit=None,\n    ext=None,\n    chunk_size=1024 * 1024,\n    request_payer=\"bucket-owner\",\n    quiet=True,\n    client_args={},\n    **kwargs,\n):\n    \"\"\"Download multiple files from S3.\n\n    Args:\n        bucket (str): The name of the bucket.\n        keys (list, optional): A list of keys. Defaults to None.\n        out_dir (str, optional): The name of the output directory. Defaults to None.\n        prefix (str, optional): Limits the response to keys that begin with the specified prefix. Defaults to None.\n        limit (int, optional): The maximum number of keys returned in the response body.\n        ext (str, optional): Filter by file extension. Defaults to None.\n        chunk_size (int, optional): The chunk size in bytes. Defaults to 1024 * 1024.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n        quiet (bool, optional): Suppress output. Defaults to True.\n        client_args (dict, optional): Additional arguments to pass to boto3.client(). Defaults to {}.\n        **kwargs: Additional arguments to pass to boto3.client().get_object().\n\n    \"\"\"\n\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if keys is None:\n        fullpath = False\n        keys = s3_list_objects(\n            bucket, prefix, limit, ext, fullpath, request_payer, **kwargs\n        )\n\n    for index, key in enumerate(keys):\n        print(f\"Downloading {index+1} of {len(keys)}: {key}\")\n        output = os.path.join(out_dir, key.split(\"/\")[-1])\n        s3_get_object(\n            bucket, key, output, chunk_size, request_payer, quiet, client_args, **kwargs\n        )\n</code></pre>"},{"location":"common/#geojp.common.s3_list_objects","title":"<code>s3_list_objects(bucket, prefix=None, limit=None, ext=None, fullpath=True, request_payer='bucket-owner', **kwargs)</code>","text":"<p>List objects in a S3 bucket</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the bucket.</p> required <code>prefix</code> <code>str</code> <p>Limits the response to keys that begin with the specified prefix. Defaults to None.</p> <code>None</code> <code>limit</code> <code>init</code> <p>The maximum number of keys returned in the response body.</p> <code>None</code> <code>ext</code> <code>str</code> <p>Filter by file extension. Defaults to None.</p> <code>None</code> <code>fullpath</code> <code>bool</code> <p>Return full path. Defaults to True.</p> <code>True</code> <code>request_payer</code> <code>str</code> <p>Specifies who pays for the download from S3. Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".</p> <code>'bucket-owner'</code> <p>Returns:</p> Type Description <code>list</code> <p>List of objects.</p> Source code in <code>geojp/common.py</code> <pre><code>def s3_list_objects(\n    bucket,\n    prefix=None,\n    limit=None,\n    ext=None,\n    fullpath=True,\n    request_payer=\"bucket-owner\",\n    **kwargs,\n):\n    \"\"\"List objects in a S3 bucket\n\n    Args:\n        bucket (str): The name of the bucket.\n        prefix (str, optional): Limits the response to keys that begin with the specified prefix. Defaults to None.\n        limit (init, optional): The maximum number of keys returned in the response body.\n        ext (str, optional): Filter by file extension. Defaults to None.\n        fullpath (bool, optional): Return full path. Defaults to True.\n        request_payer (str, optional): Specifies who pays for the download from S3.\n            Can be \"bucket-owner\" or \"requester\". Defaults to \"bucket-owner\".\n\n    Returns:\n        list: List of objects.\n    \"\"\"\n    try:\n        import boto3\n    except ImportError:\n        raise ImportError(\"boto3 is not installed. Install it with pip install boto3\")\n\n    client = boto3.client(\"s3\")\n\n    if prefix is not None:\n        kwargs[\"Prefix\"] = prefix\n\n    files = []\n    kwargs[\"RequestPayer\"] = request_payer\n    if isinstance(limit, int) and limit &lt; 1000:\n        kwargs[\"MaxKeys\"] = limit\n        response = client.list_objects_v2(Bucket=bucket, **kwargs)\n        for obj in response[\"Contents\"]:\n            files.append(obj)\n    else:\n        paginator = client.get_paginator(\"list_objects_v2\")\n        pages = paginator.paginate(Bucket=bucket, **kwargs)\n\n        for page in pages:\n            files.extend(page.get(\"Contents\", []))\n\n    if ext is not None:\n        files = [f for f in files if f[\"Key\"].endswith(ext)]\n\n    if fullpath:\n        return [f\"s3://{bucket}/{r['Key']}\" for r in files]\n    else:\n        return [r[\"Key\"] for r in files]\n</code></pre>"},{"location":"common/#geojp.common.save_colorbar","title":"<code>save_colorbar(out_fig=None, width=4.0, height=0.3, vmin=0, vmax=1.0, palette=None, vis_params=None, cmap='gray', discrete=False, label=None, label_size=10, label_weight='normal', tick_size=8, bg_color='white', orientation='horizontal', dpi='figure', transparent=False, show_colorbar=True, **kwargs)</code>","text":"<p>Create a standalone colorbar and save it as an image.</p> <p>Parameters:</p> Name Type Description Default <code>out_fig</code> <code>str</code> <p>Path to the output image.</p> <code>None</code> <code>width</code> <code>float</code> <p>Width of the colorbar in inches. Default is 4.0.</p> <code>4.0</code> <code>height</code> <code>float</code> <p>Height of the colorbar in inches. Default is 0.3.</p> <code>0.3</code> <code>vmin</code> <code>float</code> <p>Minimum value of the colorbar. Default is 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>Maximum value of the colorbar. Default is 1.0.</p> <code>1.0</code> <code>palette</code> <code>list</code> <p>List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.</p> <code>None</code> <code>vis_params</code> <code>dict</code> <p>Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.</p> <code>'gray'</code> <code>discrete</code> <code>bool</code> <p>Whether to create a discrete colorbar. Defaults to False.</p> <code>False</code> <code>label</code> <code>str</code> <p>Label for the colorbar. Defaults to None.</p> <code>None</code> <code>label_size</code> <code>int</code> <p>Font size for the colorbar label. Defaults to 12.</p> <code>10</code> <code>label_weight</code> <code>str</code> <p>Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".</p> <code>'normal'</code> <code>tick_size</code> <code>int</code> <p>Font size for the colorbar tick labels. Defaults to 10.</p> <code>8</code> <code>bg_color</code> <code>str</code> <p>Background color for the colorbar. Defaults to \"white\".</p> <code>'white'</code> <code>orientation</code> <code>str</code> <p>Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".</p> <code>'horizontal'</code> <code>dpi</code> <code>float | str</code> <p>The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".</p> <code>'figure'</code> <code>transparent</code> <code>bool</code> <p>Whether to make the background transparent. Defaults to False.</p> <code>False</code> <code>show_colorbar</code> <code>bool</code> <p>Whether to show the colorbar. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Other keyword arguments to pass to matplotlib.pyplot.savefig().</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the output image.</p> Source code in <code>geojp/common.py</code> <pre><code>def save_colorbar(\n    out_fig=None,\n    width=4.0,\n    height=0.3,\n    vmin=0,\n    vmax=1.0,\n    palette=None,\n    vis_params=None,\n    cmap=\"gray\",\n    discrete=False,\n    label=None,\n    label_size=10,\n    label_weight=\"normal\",\n    tick_size=8,\n    bg_color=\"white\",\n    orientation=\"horizontal\",\n    dpi=\"figure\",\n    transparent=False,\n    show_colorbar=True,\n    **kwargs,\n):\n    \"\"\"Create a standalone colorbar and save it as an image.\n\n    Args:\n        out_fig (str): Path to the output image.\n        width (float): Width of the colorbar in inches. Default is 4.0.\n        height (float): Height of the colorbar in inches. Default is 0.3.\n        vmin (float): Minimum value of the colorbar. Default is 0.\n        vmax (float): Maximum value of the colorbar. Default is 1.0.\n        palette (list): List of colors to use for the colorbar. It can also be a cmap name, such as ndvi, ndwi, dem, coolwarm. Default is None.\n        vis_params (dict): Visualization parameters as a dictionary. See https://developers.google.com/earth-engine/guides/image_visualization for options.\n        cmap (str, optional): Matplotlib colormap. Defaults to \"gray\". See https://matplotlib.org/3.3.4/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py for options.\n        discrete (bool, optional): Whether to create a discrete colorbar. Defaults to False.\n        label (str, optional): Label for the colorbar. Defaults to None.\n        label_size (int, optional): Font size for the colorbar label. Defaults to 12.\n        label_weight (str, optional): Font weight for the colorbar label, can be \"normal\", \"bold\", etc. Defaults to \"normal\".\n        tick_size (int, optional): Font size for the colorbar tick labels. Defaults to 10.\n        bg_color (str, optional): Background color for the colorbar. Defaults to \"white\".\n        orientation (str, optional): Orientation of the colorbar, such as \"vertical\" and \"horizontal\". Defaults to \"horizontal\".\n        dpi (float | str, optional): The resolution in dots per inch.  If 'figure', use the figure's dpi value. Defaults to \"figure\".\n        transparent (bool, optional): Whether to make the background transparent. Defaults to False.\n        show_colorbar (bool, optional): Whether to show the colorbar. Defaults to True.\n        **kwargs: Other keyword arguments to pass to matplotlib.pyplot.savefig().\n\n    Returns:\n        str: Path to the output image.\n    \"\"\"\n    import matplotlib as mpl\n    import matplotlib.pyplot as plt\n    import numpy as np\n    from .colormaps import palettes, get_palette\n\n    if out_fig is None:\n        out_fig = temp_file_path(\"png\")\n    else:\n        out_fig = check_file_path(out_fig)\n\n    if vis_params is None:\n        vis_params = {}\n    elif not isinstance(vis_params, dict):\n        raise TypeError(\"The vis_params must be a dictionary.\")\n\n    if palette is not None:\n        if palette in [\"ndvi\", \"ndwi\", \"dem\"]:\n            palette = palettes[palette]\n        elif palette in list(palettes.keys()):\n            palette = get_palette(palette)\n        vis_params[\"palette\"] = palette\n\n    orientation = orientation.lower()\n    if orientation not in [\"horizontal\", \"vertical\"]:\n        raise ValueError(\"The orientation must be either horizontal or vertical.\")\n\n    if \"opacity\" in vis_params:\n        alpha = vis_params[\"opacity\"]\n        if type(alpha) not in (int, float):\n            raise ValueError(\"The provided opacity value must be type scalar.\")\n    else:\n        alpha = 1\n\n    if \"palette\" in vis_params:\n        hexcodes = to_hex_colors(vis_params[\"palette\"])\n        if discrete:\n            cmap = mpl.colors.ListedColormap(hexcodes)\n            vals = np.linspace(vmin, vmax, cmap.N + 1)\n            norm = mpl.colors.BoundaryNorm(vals, cmap.N)\n\n        else:\n            cmap = mpl.colors.LinearSegmentedColormap.from_list(\n                \"custom\", hexcodes, N=256\n            )\n            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    elif cmap is not None:\n        cmap = mpl.colormaps[cmap]\n        norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)\n\n    else:\n        raise ValueError(\n            'cmap keyword or \"palette\" key in vis_params must be provided.'\n        )\n\n    fig, ax = plt.subplots(figsize=(width, height))\n    cb = mpl.colorbar.ColorbarBase(\n        ax, norm=norm, alpha=alpha, cmap=cmap, orientation=orientation, **kwargs\n    )\n    if label is not None:\n        cb.set_label(label=label, size=label_size, weight=label_weight)\n    cb.ax.tick_params(labelsize=tick_size)\n\n    if transparent:\n        bg_color = None\n\n    if bg_color is not None:\n        kwargs[\"facecolor\"] = bg_color\n    if \"bbox_inches\" not in kwargs:\n        kwargs[\"bbox_inches\"] = \"tight\"\n\n    fig.savefig(out_fig, dpi=dpi, transparent=transparent, **kwargs)\n    if not show_colorbar:\n        plt.close(fig)\n    return out_fig\n</code></pre>"},{"location":"common/#geojp.common.save_data","title":"<code>save_data(data, file_ext=None, file_name=None)</code>","text":"<p>Save data in the memory to a file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>object</code> <p>The data to be saved.</p> required <code>file_ext</code> <code>str</code> <p>The file extension of the file.</p> <code>None</code> <code>file_name</code> <code>str</code> <p>The name of the file to be saved. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The path of the file.</p> Source code in <code>geojp/common.py</code> <pre><code>def save_data(data, file_ext=None, file_name=None):\n    \"\"\"Save data in the memory to a file.\n\n    Args:\n        data (object): The data to be saved.\n        file_ext (str): The file extension of the file.\n        file_name (str, optional): The name of the file to be saved. Defaults to None.\n\n    Returns:\n        str: The path of the file.\n    \"\"\"\n    import tempfile\n    import uuid\n\n    try:\n        if file_ext is None:\n            if hasattr(data, \"name\"):\n                _, file_ext = os.path.splitext(data.name)\n        else:\n            if not file_ext.startswith(\".\"):\n                file_ext = \".\" + file_ext\n\n        if file_name is not None:\n            file_path = os.path.abspath(file_name)\n            if not file_path.endswith(file_ext):\n                file_path = file_path + file_ext\n        else:\n            file_id = str(uuid.uuid4())\n            file_path = os.path.join(tempfile.gettempdir(), f\"{file_id}{file_ext}\")\n\n        with open(file_path, \"wb\") as file:\n            file.write(data.getbuffer())\n        return file_path\n    except Exception as e:\n        print(e)\n        return None\n</code></pre>"},{"location":"common/#geojp.common.screen_capture","title":"<code>screen_capture(outfile, monitor=1)</code>","text":"<p>Takes a full screenshot of the selected monitor.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>The output file path to the screenshot.</p> required <code>monitor</code> <code>int</code> <p>The monitor to take the screenshot. Defaults to 1.</p> <code>1</code> Source code in <code>geojp/common.py</code> <pre><code>def screen_capture(outfile, monitor=1):\n    \"\"\"Takes a full screenshot of the selected monitor.\n\n    Args:\n        outfile (str): The output file path to the screenshot.\n        monitor (int, optional): The monitor to take the screenshot. Defaults to 1.\n    \"\"\"\n    try:\n        from mss import mss\n    except ImportError:\n        raise ImportError(\"Please install mss using 'pip install mss'\")\n\n    out_dir = os.path.dirname(outfile)\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if not isinstance(monitor, int):\n        print(\"The monitor number must be an integer.\")\n        return\n\n    try:\n        with mss() as sct:\n            sct.shot(output=outfile, mon=monitor)\n            return outfile\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.search_qms","title":"<code>search_qms(keyword, limit=10, list_only=True, add_prefix=True)</code>","text":"<p>Search for QMS tile providers from Quick Map Services.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for.</p> required <code>limit</code> <code>int</code> <p>The maximum number of results to return. Defaults to 10.</p> <code>10</code> <code>list_only</code> <code>bool</code> <p>If True, only the list of services will be returned. Defaults to True.</p> <code>True</code> <code>add_prefix</code> <code>bool</code> <p>If True, the prefix \"qms.\" will be added to the service name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of QMS tile providers.</p> Source code in <code>geojp/common.py</code> <pre><code>def search_qms(keyword, limit=10, list_only=True, add_prefix=True):\n    \"\"\"Search for QMS tile providers from Quick Map Services.\n\n    Args:\n        keyword (str): The keyword to search for.\n        limit (int, optional): The maximum number of results to return. Defaults to 10.\n        list_only (bool, optional): If True, only the list of services will be returned. Defaults to True.\n        add_prefix (bool, optional): If True, the prefix \"qms.\" will be added to the service name. Defaults to True.\n\n    Returns:\n        list: A list of QMS tile providers.\n    \"\"\"\n\n    QMS_API = \"https://qms.nextgis.com/api/v1/geoservices\"\n    services = requests.get(\n        f\"{QMS_API}/?search={keyword}&amp;type=tms&amp;epsg=3857&amp;limit={limit}\"\n    )\n    services = services.json()\n    if services[\"results\"]:\n        providers = services[\"results\"]\n        if list_only:\n            if add_prefix:\n                return [\"qms.\" + provider[\"name\"] for provider in providers]\n            else:\n                return [provider[\"name\"] for provider in providers]\n        else:\n            return providers\n    else:\n        return None\n</code></pre>"},{"location":"common/#geojp.common.search_xyz_services","title":"<code>search_xyz_services(keyword, name=None, list_only=True, add_prefix=True)</code>","text":"<p>Search for XYZ tile providers from xyzservices.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for.</p> required <code>name</code> <code>str</code> <p>The name of the xyz tile. Defaults to None.</p> <code>None</code> <code>list_only</code> <code>bool</code> <p>If True, only the list of services will be returned. Defaults to True.</p> <code>True</code> <code>add_prefix</code> <code>bool</code> <p>If True, the prefix \"xyz.\" will be added to the service name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of XYZ tile providers.</p> Source code in <code>geojp/common.py</code> <pre><code>def search_xyz_services(keyword, name=None, list_only=True, add_prefix=True):\n    \"\"\"Search for XYZ tile providers from xyzservices.\n\n    Args:\n        keyword (str): The keyword to search for.\n        name (str, optional): The name of the xyz tile. Defaults to None.\n        list_only (bool, optional): If True, only the list of services will be returned. Defaults to True.\n        add_prefix (bool, optional): If True, the prefix \"xyz.\" will be added to the service name. Defaults to True.\n\n    Returns:\n        list: A list of XYZ tile providers.\n    \"\"\"\n\n    import xyzservices.providers as xyz\n\n    if name is None:\n        providers = xyz.filter(keyword=keyword).flatten()\n    else:\n        providers = xyz.filter(name=name).flatten()\n\n    if list_only:\n        if add_prefix:\n            return [\"xyz.\" + provider for provider in providers]\n        else:\n            return [provider for provider in providers]\n    else:\n        return providers\n</code></pre>"},{"location":"common/#geojp.common.select_largest","title":"<code>select_largest(source, column, count=1, output=None, **kwargs)</code>","text":"<p>Select the largest features in a GeoDataFrame based on a column.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | gpd.GeoDataFrame</code> <p>The path to the vector file or a GeoDataFrame.</p> required <code>column</code> <code>str</code> <p>The column to sort by.</p> required <code>count</code> <code>int</code> <p>The number of features to select. Defaults to 1.</p> <code>1</code> <code>output</code> <code>str</code> <p>The path to the output vector file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The path to the output vector file.</p> Source code in <code>geojp/common.py</code> <pre><code>def select_largest(source, column, count=1, output=None, **kwargs):\n    \"\"\"Select the largest features in a GeoDataFrame based on a column.\n\n    Args:\n        source (str | gpd.GeoDataFrame): The path to the vector file or a GeoDataFrame.\n        column (str): The column to sort by.\n        count (int, optional): The number of features to select. Defaults to 1.\n        output (str, optional): The path to the output vector file. Defaults to None.\n\n    Returns:\n        str: The path to the output vector file.\n    \"\"\"\n\n    import geopandas as gpd\n\n    if isinstance(source, str):\n        gdf = gpd.read_file(source, **kwargs)\n    else:\n        gdf = source\n\n    if not isinstance(gdf, gpd.GeoDataFrame):\n        raise TypeError(\"source must be a GeoDataFrame or a file path\")\n\n    gdf = gdf.sort_values(column, ascending=False).head(count)\n\n    if output is not None:\n        gdf.to_file(output)\n\n    else:\n        return gdf\n</code></pre>"},{"location":"common/#geojp.common.set_api_key","title":"<code>set_api_key(key, name='GOOGLE_MAPS_API_KEY')</code>","text":"<p>Sets the Google Maps API key. You can generate one from https://bit.ly/3sw0THG.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The Google Maps API key.</p> required <code>name</code> <code>str</code> <p>The name of the environment variable. Defaults to \"GOOGLE_MAPS_API_KEY\".</p> <code>'GOOGLE_MAPS_API_KEY'</code> Source code in <code>geojp/common.py</code> <pre><code>def set_api_key(key: str, name: str = \"GOOGLE_MAPS_API_KEY\"):\n    \"\"\"Sets the Google Maps API key. You can generate one from https://bit.ly/3sw0THG.\n\n    Args:\n        key (str): The Google Maps API key.\n        name (str, optional): The name of the environment variable. Defaults to \"GOOGLE_MAPS_API_KEY\".\n    \"\"\"\n    os.environ[name] = key\n</code></pre>"},{"location":"common/#geojp.common.set_proxy","title":"<code>set_proxy(port=1080, ip='http://127.0.0.1')</code>","text":"<p>Sets proxy if needed. This is only needed for countries where Google services are not available.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The proxy port number. Defaults to 1080.</p> <code>1080</code> <code>ip</code> <code>str</code> <p>The IP address. Defaults to 'http://127.0.0.1'.</p> <code>'http://127.0.0.1'</code> Source code in <code>geojp/common.py</code> <pre><code>def set_proxy(port: Optional[int] = 1080, ip: Optional[str] = \"http://127.0.0.1\"):\n    \"\"\"Sets proxy if needed. This is only needed for countries where Google services are not available.\n\n    Args:\n        port (int, optional): The proxy port number. Defaults to 1080.\n        ip (str, optional): The IP address. Defaults to 'http://127.0.0.1'.\n    \"\"\"\n\n    try:\n        if not ip.startswith(\"http\"):\n            ip = \"http://\" + ip\n        proxy = \"{}:{}\".format(ip, port)\n\n        os.environ[\"HTTP_PROXY\"] = proxy\n        os.environ[\"HTTPS_PROXY\"] = proxy\n\n        a = requests.get(\"https://google.com\")\n\n        if a.status_code != 200:\n            print(\n                \"Failed to connect to Google services. Please double check the port number and ip address.\"\n            )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.show_html","title":"<code>show_html(html)</code>","text":"<p>Shows HTML within Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>File path or HTML string.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <p>Returns:</p> Type Description <code>ipywidgets.HTML</code> <p>HTML widget.</p> Source code in <code>geojp/common.py</code> <pre><code>def show_html(html: str):\n    \"\"\"Shows HTML within Jupyter notebook.\n\n    Args:\n        html (str): File path or HTML string.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n\n    Returns:\n        ipywidgets.HTML: HTML widget.\n    \"\"\"\n    if os.path.exists(html):\n        with open(html, \"r\") as f:\n            content = f.read()\n\n        widget = widgets.HTML(value=content)\n        return widget\n    else:\n        try:\n            widget = widgets.HTML(value=html)\n            return widget\n        except Exception as e:\n            raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.show_image","title":"<code>show_image(img_path, width=None, height=None)</code>","text":"<p>Shows an image within Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The image file path.</p> required <code>width</code> <code>int</code> <p>Width of the image in pixels. Defaults to None.</p> <code>None</code> <code>height</code> <code>int</code> <p>Height of the image in pixels. Defaults to None.</p> <code>None</code> Source code in <code>geojp/common.py</code> <pre><code>def show_image(\n    img_path: str, width: Optional[int] = None, height: Optional[int] = None\n):\n    \"\"\"Shows an image within Jupyter notebook.\n\n    Args:\n        img_path (str): The image file path.\n        width (int, optional): Width of the image in pixels. Defaults to None.\n        height (int, optional): Height of the image in pixels. Defaults to None.\n\n    \"\"\"\n    from IPython.display import display\n\n    try:\n        out = widgets.Output()\n        # layout={'border': '1px solid black'})\n        # layout={'border': '1px solid black', 'width': str(width + 20) + 'px', 'height': str(height + 10) + 'px'},)\n        out.outputs = ()\n        display(out)\n        with out:\n            file = open(img_path, \"rb\")\n            image = file.read()\n            if (width is None) and (height is None):\n                display(widgets.Image(value=image))\n            elif (width is not None) and (height is not None):\n                display(widgets.Image(value=image, width=width, height=height))\n            else:\n                print(\"You need set both width and height.\")\n                return\n    except Exception as e:\n        print(e)\n</code></pre>"},{"location":"common/#geojp.common.show_youtube_video","title":"<code>show_youtube_video(url, width=800, height=450, allow_autoplay=False, **kwargs)</code>","text":"<p>Displays a Youtube video in a Jupyter notebook.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>string</code> <p>a link to a Youtube video.</p> required <code>width</code> <code>int</code> <p>the width of the video. Defaults to 800.</p> <code>800</code> <code>height</code> <code>int</code> <p>the height of the video. Defaults to 600.</p> <code>450</code> <code>allow_autoplay</code> <code>bool</code> <p>whether to allow autoplay. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>further arguments for IPython.display.YouTubeVideo</p> <code>{}</code> <p>Returns:</p> Type Description <code>YouTubeVideo</code> <p>a video that is displayed in your notebook.</p> Source code in <code>geojp/common.py</code> <pre><code>def show_youtube_video(url, width=800, height=450, allow_autoplay=False, **kwargs):\n    \"\"\"\n    Displays a Youtube video in a Jupyter notebook.\n\n    Args:\n        url (string): a link to a Youtube video.\n        width (int, optional): the width of the video. Defaults to 800.\n        height (int, optional): the height of the video. Defaults to 600.\n        allow_autoplay (bool, optional): whether to allow autoplay. Defaults to False.\n        **kwargs: further arguments for IPython.display.YouTubeVideo\n\n    Returns:\n        YouTubeVideo: a video that is displayed in your notebook.\n    \"\"\"\n    import re\n    from IPython.display import YouTubeVideo\n\n    if not isinstance(url, str):\n        raise TypeError(\"URL must be a string\")\n\n    match = re.match(\n        r\"^https?:\\/\\/(?:www\\.)?youtube\\.com\\/watch\\?(?=.*v=([^\\s&amp;]+)).*$|^https?:\\/\\/(?:www\\.)?youtu\\.be\\/([^\\s&amp;]+).*$\",\n        url,\n    )\n    if not match:\n        raise ValueError(\"Invalid YouTube video URL\")\n\n    video_id = match.group(1) if match.group(1) else match.group(2)\n\n    return YouTubeVideo(\n        video_id, width=width, height=height, allow_autoplay=allow_autoplay, **kwargs\n    )\n</code></pre>"},{"location":"common/#geojp.common.shp_to_gdf","title":"<code>shp_to_gdf(in_shp)</code>","text":"<p>Converts a shapefile to Geopandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>File path to the input shapefile.</p> required <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>The provided shp could not be found.</p> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>geopandas.GeoDataFrame</p> Source code in <code>geojp/common.py</code> <pre><code>def shp_to_gdf(in_shp):\n    \"\"\"Converts a shapefile to Geopandas dataframe.\n\n    Args:\n        in_shp (str): File path to the input shapefile.\n\n    Raises:\n        FileNotFoundError: The provided shp could not be found.\n\n    Returns:\n        gpd.GeoDataFrame: geopandas.GeoDataFrame\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n\n    in_shp = os.path.abspath(in_shp)\n    if not os.path.exists(in_shp):\n        raise FileNotFoundError(\"The provided shp could not be found.\")\n\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n\n    import geopandas as gpd\n\n    try:\n        return gpd.read_file(in_shp)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.shp_to_geojson","title":"<code>shp_to_geojson(in_shp, output=None, encoding='utf-8', crs='EPSG:4326', **kwargs)</code>","text":"<p>Converts a shapefile to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>in_shp</code> <code>str</code> <p>File path of the input shapefile.</p> required <code>output</code> <code>str</code> <p>File path of the output GeoJSON. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>The json object representing the shapefile.</p> Source code in <code>geojp/common.py</code> <pre><code>def shp_to_geojson(in_shp, output=None, encoding=\"utf-8\", crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Converts a shapefile to GeoJSON.\n\n    Args:\n        in_shp (str): File path of the input shapefile.\n        output (str, optional): File path of the output GeoJSON. Defaults to None.\n\n    Returns:\n        object: The json object representing the shapefile.\n    \"\"\"\n    try:\n        import geopandas as gpd\n\n        gdf = gpd.read_file(in_shp, **kwargs)\n        gdf.to_crs(crs, inplace=True)\n        if output is None:\n            return gdf.__geo_interface__\n        else:\n            gdf.to_file(output, driver=\"GeoJSON\")\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.skip_mkdocs_build","title":"<code>skip_mkdocs_build()</code>","text":"<p>Skips the MkDocs build if the USE_MKDOCS environment variable is set.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether to skip the MkDocs build.</p> Source code in <code>geojp/common.py</code> <pre><code>def skip_mkdocs_build():\n    \"\"\"Skips the MkDocs build if the USE_MKDOCS environment variable is set.\n\n    Returns:\n        bool: Whether to skip the MkDocs build.\n    \"\"\"\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"common/#geojp.common.split_raster","title":"<code>split_raster(filename, out_dir, tile_size=256, overlap=0)</code>","text":"<p>Split a raster into tiles.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path or http URL to the raster file.</p> required <code>out_dir</code> <code>str</code> <p>The path to the output directory.</p> required <code>tile_size</code> <code>int | tuple</code> <p>The size of the tiles. Can be an integer or a tuple of (width, height). Defaults to 256.</p> <code>256</code> <code>overlap</code> <code>int</code> <p>The number of pixels to overlap between tiles. Defaults to 0.</p> <code>0</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>Raised if GDAL is not installed.</p> Source code in <code>geojp/common.py</code> <pre><code>def split_raster(filename, out_dir, tile_size=256, overlap=0):\n    \"\"\"Split a raster into tiles.\n\n    Args:\n        filename (str): The path or http URL to the raster file.\n        out_dir (str): The path to the output directory.\n        tile_size (int | tuple, optional): The size of the tiles. Can be an integer or a tuple of (width, height). Defaults to 256.\n        overlap (int, optional): The number of pixels to overlap between tiles. Defaults to 0.\n\n    Raises:\n        ImportError: Raised if GDAL is not installed.\n    \"\"\"\n\n    try:\n        from osgeo import gdal\n    except ImportError:\n        raise ImportError(\n            \"GDAL is required to use this function. Install it with `conda install gdal -c conda-forge`\"\n        )\n\n    if isinstance(filename, str):\n        if filename.startswith(\"http\"):\n            output = filename.split(\"/\")[-1]\n            download_file(filename, output)\n            filename = output\n\n    # Open the input GeoTIFF file\n    ds = gdal.Open(filename)\n\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if isinstance(tile_size, int):\n        tile_width = tile_size\n        tile_height = tile_size\n    elif isinstance(tile_size, tuple):\n        tile_width = tile_size[0]\n        tile_height = tile_size[1]\n\n    # Get the size of the input raster\n    width = ds.RasterXSize\n    height = ds.RasterYSize\n\n    # Calculate the number of tiles needed in both directions, taking into account the overlap\n    num_tiles_x = (width - overlap) // (tile_width - overlap) + int(\n        (width - overlap) % (tile_width - overlap) &gt; 0\n    )\n    num_tiles_y = (height - overlap) // (tile_height - overlap) + int(\n        (height - overlap) % (tile_height - overlap) &gt; 0\n    )\n\n    # Get the georeferencing information of the input raster\n    geotransform = ds.GetGeoTransform()\n\n    # Loop over all the tiles\n    for i in range(num_tiles_x):\n        for j in range(num_tiles_y):\n            # Calculate the pixel coordinates of the tile, taking into account the overlap and clamping to the edge of the raster\n            x_min = i * (tile_width - overlap)\n            y_min = j * (tile_height - overlap)\n            x_max = min(x_min + tile_width, width)\n            y_max = min(y_min + tile_height, height)\n\n            # Adjust the size of the last tile in each row and column to include any remaining pixels\n            if i == num_tiles_x - 1:\n                x_min = max(x_max - tile_width, 0)\n            if j == num_tiles_y - 1:\n                y_min = max(y_max - tile_height, 0)\n\n            # Calculate the size of the tile, taking into account the overlap\n            tile_width = x_max - x_min\n            tile_height = y_max - y_min\n\n            # Set the output file name\n            output_file = f\"{out_dir}/tile_{i}_{j}.tif\"\n\n            # Create a new dataset for the tile\n            driver = gdal.GetDriverByName(\"GTiff\")\n            tile_ds = driver.Create(\n                output_file,\n                tile_width,\n                tile_height,\n                ds.RasterCount,\n                ds.GetRasterBand(1).DataType,\n            )\n\n            # Calculate the georeferencing information for the output tile\n            tile_geotransform = (\n                geotransform[0] + x_min * geotransform[1],\n                geotransform[1],\n                0,\n                geotransform[3] + y_min * geotransform[5],\n                0,\n                geotransform[5],\n            )\n\n            # Set the geotransform and projection of the tile\n            tile_ds.SetGeoTransform(tile_geotransform)\n            tile_ds.SetProjection(ds.GetProjection())\n\n            # Read the data from the input raster band(s) and write it to the tile band(s)\n            for k in range(ds.RasterCount):\n                band = ds.GetRasterBand(k + 1)\n                tile_band = tile_ds.GetRasterBand(k + 1)\n                tile_data = band.ReadAsArray(x_min, y_min, tile_width, tile_height)\n                tile_band.WriteArray(tile_data)\n\n            # Close the tile dataset\n            tile_ds = None\n\n    # Close the input dataset\n    ds = None\n</code></pre>"},{"location":"common/#geojp.common.st_download_button","title":"<code>st_download_button(label, data, file_name=None, mime=None, key=None, help=None, on_click=None, args=None, csv_sep=',', **kwargs)</code>","text":"<p>Streamlit function to create a download button.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>A short label explaining to the user what this button is for..</p> required <code>data</code> <code>str | list</code> <p>The contents of the file to be downloaded. See example below for caching techniques to avoid recomputing this data unnecessarily.</p> required <code>file_name</code> <code>str</code> <p>An optional string to use as the name of the file to be downloaded, such as 'my_file.csv'. If not specified, the name will be automatically generated. Defaults to None.</p> <code>None</code> <code>mime</code> <code>str</code> <p>The MIME type of the data. If None, defaults to \"text/plain\" (if data is of type str or is a textual file) or \"application/octet-stream\" (if data is of type bytes or is a binary file). Defaults to None.</p> <code>None</code> <code>key</code> <code>str</code> <p>An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. Multiple widgets of the same type may not share the same key. Defaults to None.</p> <code>None</code> <code>help</code> <code>str</code> <p>An optional tooltip that gets displayed when the button is hovered over. Defaults to None.</p> <code>None</code> <code>on_click</code> <code>str</code> <p>An optional callback invoked when this button is clicked. Defaults to None.</p> <code>None</code> <code>args</code> <code>list</code> <p>An optional tuple of args to pass to the callback. Defaults to None.</p> <code>None</code> <code>kwargs</code> <code>dict</code> <p>An optional tuple of args to pass to the callback.</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def st_download_button(\n    label,\n    data,\n    file_name=None,\n    mime=None,\n    key=None,\n    help=None,\n    on_click=None,\n    args=None,\n    csv_sep=\",\",\n    **kwargs,\n):\n    \"\"\"Streamlit function to create a download button.\n\n    Args:\n        label (str): A short label explaining to the user what this button is for..\n        data (str | list): The contents of the file to be downloaded. See example below for caching techniques to avoid recomputing this data unnecessarily.\n        file_name (str, optional): An optional string to use as the name of the file to be downloaded, such as 'my_file.csv'. If not specified, the name will be automatically generated. Defaults to None.\n        mime (str, optional): The MIME type of the data. If None, defaults to \"text/plain\" (if data is of type str or is a textual file) or \"application/octet-stream\" (if data is of type bytes or is a binary file). Defaults to None.\n        key (str, optional): An optional string or integer to use as the unique key for the widget. If this is omitted, a key will be generated for the widget based on its content. Multiple widgets of the same type may not share the same key. Defaults to None.\n        help (str, optional): An optional tooltip that gets displayed when the button is hovered over. Defaults to None.\n        on_click (str, optional): An optional callback invoked when this button is clicked. Defaults to None.\n        args (list, optional): An optional tuple of args to pass to the callback. Defaults to None.\n        kwargs (dict, optional): An optional tuple of args to pass to the callback.\n\n    \"\"\"\n    try:\n        import streamlit as st\n        import pandas as pd\n\n        if isinstance(data, str):\n            if file_name is None:\n                file_name = data.split(\"/\")[-1]\n\n            if data.endswith(\".csv\"):\n                data = pd.read_csv(data).to_csv(sep=csv_sep, index=False)\n                if mime is None:\n                    mime = \"text/csv\"\n                return st.download_button(\n                    label, data, file_name, mime, key, help, on_click, args, **kwargs\n                )\n            elif (\n                data.endswith(\".gif\") or data.endswith(\".png\") or data.endswith(\".jpg\")\n            ):\n                if mime is None:\n                    mime = f\"image/{os.path.splitext(data)[1][1:]}\"\n\n                with open(data, \"rb\") as file:\n                    return st.download_button(\n                        label,\n                        file,\n                        file_name,\n                        mime,\n                        key,\n                        help,\n                        on_click,\n                        args,\n                        **kwargs,\n                    )\n        elif isinstance(data, pd.DataFrame):\n            if file_name is None:\n                file_name = \"data.csv\"\n\n            data = data.to_csv(sep=csv_sep, index=False)\n            if mime is None:\n                mime = \"text/csv\"\n            return st.download_button(\n                label, data, file_name, mime, key, help, on_click, args, **kwargs\n            )\n\n        else:\n            # if mime is None:\n            #     mime = \"application/pdf\"\n            return st.download_button(\n                label,\n                data,\n                file_name,\n                mime,\n                key,\n                help,\n                on_click,\n                args,\n                **kwargs,\n            )\n\n    except ImportError:\n        print(\"Streamlit is not installed. Please run 'pip install streamlit'.\")\n        return\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.start_server","title":"<code>start_server(directory=None, port=8000, background=True, quiet=True)</code>","text":"<p>Start a simple web server to serve files from the specified directory with directory listing and CORS support. Optionally, run the server asynchronously in a background thread.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>The directory from which files will be served.</p> <code>None</code> <code>port</code> <code>int</code> <p>The port on which the web server will run. Defaults to 8000.</p> <code>8000</code> <code>background</code> <code>bool</code> <p>Whether to run the server in a separate background thread.                          Defaults to True.</p> <code>True</code> <code>quiet</code> <code>bool</code> <p>If True, suppress the log output. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If required modules are not found.</p> <code>Exception</code> <p>Catches other unexpected errors during execution.</p> <p>Returns:</p> Type Description <p>None. The function runs the server indefinitely until manually stopped.</p> Source code in <code>geojp/common.py</code> <pre><code>def start_server(\n    directory: str = None, port: int = 8000, background: bool = True, quiet: bool = True\n):\n    \"\"\"\n    Start a simple web server to serve files from the specified directory\n    with directory listing and CORS support. Optionally, run the server\n    asynchronously in a background thread.\n\n    Args:\n        directory (str): The directory from which files will be served.\n        port (int, optional): The port on which the web server will run. Defaults to 8000.\n        background (bool, optional): Whether to run the server in a separate background thread.\n                                     Defaults to True.\n        quiet (bool, optional): If True, suppress the log output. Defaults to True.\n\n    Raises:\n        ImportError: If required modules are not found.\n        Exception: Catches other unexpected errors during execution.\n\n    Returns:\n        None. The function runs the server indefinitely until manually stopped.\n    \"\"\"\n\n    # If no directory is specified, use the current working directory\n    if directory is None:\n        directory = os.getcwd()\n\n    def run_flask():\n        try:\n            from flask import Flask, send_from_directory, render_template_string\n            from flask_cors import CORS\n\n            app = Flask(__name__, static_folder=directory)\n            CORS(app)  # Enable CORS for all routes\n\n            if quiet:\n                # This will disable Flask's logging\n                import logging\n\n                log = logging.getLogger(\"werkzeug\")\n                log.disabled = True\n                app.logger.disabled = True\n\n            @app.route(\"/&lt;path:path&gt;\", methods=[\"GET\"])\n            def serve_file(path):\n                return send_from_directory(directory, path)\n\n            @app.route(\"/\", methods=[\"GET\"])\n            def index():\n                # List files and directories under the specified directory\n                items = os.listdir(directory)\n                items.sort()\n                # Generate an HTML representation of the directory listing\n                listing_template = \"\"\"\n                &lt;h2&gt;Directory listing for /&lt;/h2&gt;\n                &lt;hr&gt;\n                &lt;ul&gt;\n                    {% for item in items %}\n                        &lt;li&gt;&lt;a href=\"{{ item }}\"&gt;{{ item }}&lt;/a&gt;&lt;/li&gt;\n                    {% endfor %}\n                &lt;/ul&gt;\n                \"\"\"\n                return render_template_string(listing_template, items=items)\n\n            print(f\"Server is running at http://127.0.0.1:{port}/\")\n            app.run(port=port)\n\n        except ImportError as e:\n            print(f\"Error importing module: {e}\")\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n\n    if background:\n        import threading\n\n        # Start the Flask server in a new background thread\n        t = threading.Thread(target=run_flask)\n        t.start()\n    else:\n        # Run the Flask server in the main thread\n        run_flask()\n</code></pre>"},{"location":"common/#geojp.common.streamlit_legend","title":"<code>streamlit_legend(html, width=None, height=None, scrolling=True)</code>","text":"<p>Streamlit function to display a legend.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML string of the legend.</p> required <code>width</code> <code>str</code> <p>The width of the legend. Defaults to None.</p> <code>None</code> <code>height</code> <code>str</code> <p>The height of the legend. Defaults to None.</p> <code>None</code> <code>scrolling</code> <code>bool</code> <p>Whether to allow scrolling in the legend. Defaults to True.</p> <code>True</code> Source code in <code>geojp/common.py</code> <pre><code>def streamlit_legend(html, width=None, height=None, scrolling=True):\n    \"\"\"Streamlit function to display a legend.\n\n    Args:\n        html (str): The HTML string of the legend.\n        width (str, optional): The width of the legend. Defaults to None.\n        height (str, optional): The height of the legend. Defaults to None.\n        scrolling (bool, optional): Whether to allow scrolling in the legend. Defaults to True.\n\n    \"\"\"\n\n    try:\n        import streamlit.components.v1 as components\n\n        components.html(html, width=width, height=height, scrolling=scrolling)\n\n    except ImportError:\n        print(\"Streamlit is not installed. Please run 'pip install streamlit'.\")\n        return\n</code></pre>"},{"location":"common/#geojp.common.system_fonts","title":"<code>system_fonts(show_full_path=False)</code>","text":"<p>Gets a list of system fonts</p> <pre><code># Common font locations:\n# Linux: /usr/share/fonts/TTF/\n# Windows: C:/Windows/Fonts\n# macOS:  System &gt; Library &gt; Fonts\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>show_full_path</code> <code>bool</code> <p>Whether to show the full path of each system font. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of system fonts.</p> Source code in <code>geojp/common.py</code> <pre><code>def system_fonts(show_full_path: Optional[bool] = False) -&gt; List:\n    \"\"\"Gets a list of system fonts\n\n        # Common font locations:\n        # Linux: /usr/share/fonts/TTF/\n        # Windows: C:/Windows/Fonts\n        # macOS:  System &gt; Library &gt; Fonts\n\n    Args:\n        show_full_path (bool, optional): Whether to show the full path of each system font. Defaults to False.\n\n    Returns:\n        list: A list of system fonts.\n    \"\"\"\n    try:\n        import matplotlib.font_manager\n\n        font_list = matplotlib.font_manager.findSystemFonts(\n            fontpaths=None, fontext=\"ttf\"\n        )\n        font_list.sort()\n\n        font_names = [os.path.basename(f) for f in font_list]\n        font_names.sort()\n\n        if show_full_path:\n            return font_list\n        else:\n            return font_names\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.temp_file_path","title":"<code>temp_file_path(extension)</code>","text":"<p>Returns a temporary file path.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>The file extension.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The temporary file path.</p> Source code in <code>geojp/common.py</code> <pre><code>def temp_file_path(extension):\n    \"\"\"Returns a temporary file path.\n\n    Args:\n        extension (str): The file extension.\n\n    Returns:\n        str: The temporary file path.\n    \"\"\"\n\n    import tempfile\n    import uuid\n\n    if not extension.startswith(\".\"):\n        extension = \".\" + extension\n    file_id = str(uuid.uuid4())\n    file_path = os.path.join(tempfile.gettempdir(), f\"{file_id}{extension}\")\n\n    return file_path\n</code></pre>"},{"location":"common/#geojp.common.tif_to_jp2","title":"<code>tif_to_jp2(filename, output, creationOptions=None)</code>","text":"<p>Converts a GeoTIFF to JPEG2000.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the GeoTIFF file.</p> required <code>output</code> <code>str</code> <p>The path to the output JPEG2000 file.</p> required <code>creationOptions</code> <code>list</code> <p>A list of creation options for the JPEG2000 file. See https://gdal.org/drivers/raster/jp2openjpeg.html. For example, to specify the compression ratio, use <code>[\"QUALITY=20\"]</code>. A value of 20 means the file will be 20% of the size in comparison to uncompressed data.</p> <code>None</code> Source code in <code>geojp/common.py</code> <pre><code>def tif_to_jp2(filename, output, creationOptions=None):\n    \"\"\"Converts a GeoTIFF to JPEG2000.\n\n    Args:\n        filename (str): The path to the GeoTIFF file.\n        output (str): The path to the output JPEG2000 file.\n        creationOptions (list): A list of creation options for the JPEG2000 file. See\n            https://gdal.org/drivers/raster/jp2openjpeg.html. For example, to specify the compression\n            ratio, use ``[\"QUALITY=20\"]``. A value of 20 means the file will be 20% of the size in comparison\n            to uncompressed data.\n\n    \"\"\"\n\n    if not os.path.exists(filename):\n        raise Exception(f\"File {filename} does not exist\")\n\n    if not output.endswith(\".jp2\"):\n        output += \".jp2\"\n\n    from osgeo import gdal\n\n    in_ds = gdal.Open(filename)\n    gdal.Translate(output, in_ds, format=\"JP2OpenJPEG\", creationOptions=creationOptions)\n    in_ds = None\n</code></pre>"},{"location":"common/#geojp.common.tms_to_geotiff","title":"<code>tms_to_geotiff(output, bbox, zoom=None, resolution=None, source='OpenStreetMap', crs='EPSG:3857', to_cog=False, quiet=False, **kwargs)</code>","text":"<p>Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.     Credits to the GitHub user @gumblex.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The output GeoTIFF file.</p> required <code>bbox</code> <code>list</code> <p>The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]</p> required <code>zoom</code> <code>int</code> <p>The map zoom level. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>float</code> <p>The resolution in meters. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".</p> <code>'OpenStreetMap'</code> <code>crs</code> <code>str</code> <p>The coordinate reference system. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>to_cog</code> <code>bool</code> <p>Convert to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def map_tiles_to_geotiff(\n    output,\n    bbox,\n    zoom=None,\n    resolution=None,\n    source=\"OpenStreetMap\",\n    crs=\"EPSG:3857\",\n    to_cog=False,\n    quiet=False,\n    **kwargs,\n):\n    \"\"\"Download map tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.\n        Credits to the GitHub user @gumblex.\n\n    Args:\n        output (str): The output GeoTIFF file.\n        bbox (list): The bounding box [minx, miny, maxx, maxy] coordinates in EPSG:4326, e.g., [-122.5216, 37.733, -122.3661, 37.8095]\n        zoom (int, optional): The map zoom level. Defaults to None.\n        resolution (float, optional): The resolution in meters. Defaults to None.\n        source (str, optional): The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\",\n            \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".\n        crs (str, optional): The coordinate reference system. Defaults to \"EPSG:3857\".\n        to_cog (bool, optional): Convert to Cloud Optimized GeoTIFF. Defaults to False.\n        quiet (bool, optional): Suppress output. Defaults to False.\n        **kwargs: Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().\n\n    \"\"\"\n\n    import io\n    import math\n    import itertools\n    import concurrent.futures\n\n    import numpy\n    from PIL import Image\n\n    try:\n        from osgeo import gdal, osr\n    except ImportError:\n        raise ImportError(\"GDAL is not installed. Install it with pip install GDAL\")\n\n    try:\n        import httpx\n\n        SESSION = httpx.Client()\n    except ImportError:\n        import requests\n\n        SESSION = requests.Session()\n\n    SESSION.headers.update(\n        {\n            \"Accept\": \"*/*\",\n            \"Accept-Encoding\": \"gzip, deflate\",\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0\",\n        }\n    )\n\n    xyz_tiles = {\n        \"OPENSTREETMAP\": {\n            \"url\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"attribution\": \"OpenStreetMap\",\n            \"name\": \"OpenStreetMap\",\n        },\n        \"ROADMAP\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Maps\",\n        },\n        \"SATELLITE\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n        \"TERRAIN\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Terrain\",\n        },\n        \"HYBRID\": {\n            \"url\": \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n            \"attribution\": \"Google\",\n            \"name\": \"Google Satellite\",\n        },\n    }\n\n    if isinstance(source, str) and source.upper() in xyz_tiles:\n        source = xyz_tiles[source.upper()][\"url\"]\n    elif isinstance(source, str) and source.startswith(\"http\"):\n        pass\n    elif isinstance(source, str):\n        tiles = basemap_xyz_tiles()\n        if source in tiles:\n            source = tiles[source].url\n    else:\n        raise ValueError(\n            'source must be one of \"OpenStreetMap\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or a URL'\n        )\n\n    def resolution_to_zoom_level(resolution):\n        \"\"\"\n        Convert map resolution in meters to zoom level for Web Mercator (EPSG:3857) tiles.\n        \"\"\"\n        # Web Mercator tile size in meters at zoom level 0\n        initial_resolution = 156543.03392804097\n\n        # Calculate the zoom level\n        zoom_level = math.log2(initial_resolution / resolution)\n\n        return int(zoom_level)\n\n    if isinstance(bbox, list) and len(bbox) == 4:\n        west, south, east, north = bbox\n    else:\n        raise ValueError(\n            \"bbox must be a list of 4 coordinates in the format of [xmin, ymin, xmax, ymax]\"\n        )\n\n    if zoom is None and resolution is None:\n        raise ValueError(\"Either zoom or resolution must be provided\")\n    elif zoom is not None and resolution is not None:\n        raise ValueError(\"Only one of zoom or resolution can be provided\")\n\n    if resolution is not None:\n        zoom = resolution_to_zoom_level(resolution)\n\n    EARTH_EQUATORIAL_RADIUS = 6378137.0\n\n    Image.MAX_IMAGE_PIXELS = None\n\n    gdal.UseExceptions()\n    web_mercator = osr.SpatialReference()\n    web_mercator.ImportFromEPSG(3857)\n\n    WKT_3857 = web_mercator.ExportToWkt()\n\n    def from4326_to3857(lat, lon):\n        xtile = math.radians(lon) * EARTH_EQUATORIAL_RADIUS\n        ytile = (\n            math.log(math.tan(math.radians(45 + lat / 2.0))) * EARTH_EQUATORIAL_RADIUS\n        )\n        return (xtile, ytile)\n\n    def deg2num(lat, lon, zoom):\n        lat_r = math.radians(lat)\n        n = 2**zoom\n        xtile = (lon + 180) / 360 * n\n        ytile = (1 - math.log(math.tan(lat_r) + 1 / math.cos(lat_r)) / math.pi) / 2 * n\n        return (xtile, ytile)\n\n    def is_empty(im):\n        extrema = im.getextrema()\n        if len(extrema) &gt;= 3:\n            if len(extrema) &gt; 3 and extrema[-1] == (0, 0):\n                return True\n            for ext in extrema[:3]:\n                if ext != (0, 0):\n                    return False\n            return True\n        else:\n            return extrema[0] == (0, 0)\n\n    def paste_tile(bigim, base_size, tile, corner_xy, bbox):\n        if tile is None:\n            return bigim\n        im = Image.open(io.BytesIO(tile))\n        mode = \"RGB\" if im.mode == \"RGB\" else \"RGBA\"\n        size = im.size\n        if bigim is None:\n            base_size[0] = size[0]\n            base_size[1] = size[1]\n            newim = Image.new(\n                mode, (size[0] * (bbox[2] - bbox[0]), size[1] * (bbox[3] - bbox[1]))\n            )\n        else:\n            newim = bigim\n\n        dx = abs(corner_xy[0] - bbox[0])\n        dy = abs(corner_xy[1] - bbox[1])\n        xy0 = (size[0] * dx, size[1] * dy)\n        if mode == \"RGB\":\n            newim.paste(im, xy0)\n        else:\n            if im.mode != mode:\n                im = im.convert(mode)\n            if not is_empty(im):\n                newim.paste(im, xy0)\n        im.close()\n        return newim\n\n    def finish_picture(bigim, base_size, bbox, x0, y0, x1, y1):\n        xfrac = x0 - bbox[0]\n        yfrac = y0 - bbox[1]\n        x2 = round(base_size[0] * xfrac)\n        y2 = round(base_size[1] * yfrac)\n        imgw = round(base_size[0] * (x1 - x0))\n        imgh = round(base_size[1] * (y1 - y0))\n        retim = bigim.crop((x2, y2, x2 + imgw, y2 + imgh))\n        if retim.mode == \"RGBA\" and retim.getextrema()[3] == (255, 255):\n            retim = retim.convert(\"RGB\")\n        bigim.close()\n        return retim\n\n    def get_tile(url):\n        retry = 3\n        while 1:\n            try:\n                r = SESSION.get(url, timeout=60)\n                break\n            except Exception:\n                retry -= 1\n                if not retry:\n                    raise\n        if r.status_code == 404:\n            return None\n        elif not r.content:\n            return None\n        r.raise_for_status()\n        return r.content\n\n    def draw_tile(\n        source, lat0, lon0, lat1, lon1, zoom, filename, quiet=False, **kwargs\n    ):\n        x0, y0 = deg2num(lat0, lon0, zoom)\n        x1, y1 = deg2num(lat1, lon1, zoom)\n        x0, x1 = sorted([x0, x1])\n        y0, y1 = sorted([y0, y1])\n        corners = tuple(\n            itertools.product(\n                range(math.floor(x0), math.ceil(x1)),\n                range(math.floor(y0), math.ceil(y1)),\n            )\n        )\n        totalnum = len(corners)\n        futures = []\n        with concurrent.futures.ThreadPoolExecutor(5) as executor:\n            for x, y in corners:\n                futures.append(\n                    executor.submit(get_tile, source.format(z=zoom, x=x, y=y))\n                )\n            bbox = (math.floor(x0), math.floor(y0), math.ceil(x1), math.ceil(y1))\n            bigim = None\n            base_size = [256, 256]\n            for k, (fut, corner_xy) in enumerate(zip(futures, corners), 1):\n                bigim = paste_tile(bigim, base_size, fut.result(), corner_xy, bbox)\n                if not quiet:\n                    print(\"Downloaded image %d/%d\" % (k, totalnum))\n\n        if not quiet:\n            print(\"Saving GeoTIFF. Please wait...\")\n        img = finish_picture(bigim, base_size, bbox, x0, y0, x1, y1)\n        imgbands = len(img.getbands())\n        driver = gdal.GetDriverByName(\"GTiff\")\n\n        if \"options\" not in kwargs:\n            kwargs[\"options\"] = [\n                \"COMPRESS=DEFLATE\",\n                \"PREDICTOR=2\",\n                \"ZLEVEL=9\",\n                \"TILED=YES\",\n            ]\n\n        kwargs.pop(\"overwrite\", None)\n        gtiff = driver.Create(\n            filename,\n            img.size[0],\n            img.size[1],\n            imgbands,\n            gdal.GDT_Byte,\n            **kwargs,\n        )\n        xp0, yp0 = from4326_to3857(lat0, lon0)\n        xp1, yp1 = from4326_to3857(lat1, lon1)\n        pwidth = abs(xp1 - xp0) / img.size[0]\n        pheight = abs(yp1 - yp0) / img.size[1]\n        gtiff.SetGeoTransform((min(xp0, xp1), pwidth, 0, max(yp0, yp1), 0, -pheight))\n        gtiff.SetProjection(WKT_3857)\n        for band in range(imgbands):\n            array = numpy.array(img.getdata(band), dtype=\"u8\")\n            array = array.reshape((img.size[1], img.size[0]))\n            band = gtiff.GetRasterBand(band + 1)\n            band.WriteArray(array)\n        gtiff.FlushCache()\n\n        if not quiet:\n            print(f\"Image saved to {filename}\")\n        return img\n\n    try:\n        draw_tile(source, south, west, north, east, zoom, output, quiet, **kwargs)\n        if crs.upper() != \"EPSG:3857\":\n            reproject(output, output, crs, to_cog=to_cog)\n        elif to_cog:\n            image_to_cog(output, output)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.to_hex_colors","title":"<code>to_hex_colors(colors)</code>","text":"<p>Adds # to a list of hex color codes.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list</code> <p>A list of hex color codes.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of hex color codes prefixed with #.</p> Source code in <code>geojp/common.py</code> <pre><code>def to_hex_colors(colors):\n    \"\"\"Adds # to a list of hex color codes.\n\n    Args:\n        colors (list): A list of hex color codes.\n\n    Returns:\n        list: A list of hex color codes prefixed with #.\n    \"\"\"\n    result = all([len(color.strip()) == 6 for color in colors])\n    if result:\n        return [\"#\" + color.strip() for color in colors]\n    else:\n        return colors\n</code></pre>"},{"location":"common/#geojp.common.transform_bbox_coords","title":"<code>transform_bbox_coords(bbox, src_crs, dst_crs, **kwargs)</code>","text":"<p>Transforms the coordinates of a bounding box [x1, y1, x2, y2] from one CRS to another.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>list | tuple</code> <p>The bounding box [x1, y1, x2, y2] coordinates.</p> required <code>src_crs</code> <code>str</code> <p>The source CRS, e.g., \"EPSG:4326\".</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS, e.g., \"EPSG:3857\".</p> required <p>Returns:</p> Type Description <code>list</code> <p>The transformed bounding box [x1, y1, x2, y2] coordinates.</p> Source code in <code>geojp/common.py</code> <pre><code>def transform_bbox_coords(bbox, src_crs, dst_crs, **kwargs):\n    \"\"\"Transforms the coordinates of a bounding box [x1, y1, x2, y2] from one CRS to another.\n\n    Args:\n        bbox (list | tuple): The bounding box [x1, y1, x2, y2] coordinates.\n        src_crs (str): The source CRS, e.g., \"EPSG:4326\".\n        dst_crs (str): The destination CRS, e.g., \"EPSG:3857\".\n\n    Returns:\n        list: The transformed bounding box [x1, y1, x2, y2] coordinates.\n    \"\"\"\n    x1, y1, x2, y2 = bbox\n\n    x1, y1 = transform_coords(x1, y1, src_crs, dst_crs, **kwargs)\n    x2, y2 = transform_coords(x2, y2, src_crs, dst_crs, **kwargs)\n\n    return [x1, y1, x2, y2]\n</code></pre>"},{"location":"common/#geojp.common.transform_coords","title":"<code>transform_coords(x, y, src_crs, dst_crs, **kwargs)</code>","text":"<p>Transform coordinates from one CRS to another.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x coordinate.</p> required <code>y</code> <code>float</code> <p>The y coordinate.</p> required <code>src_crs</code> <code>str</code> <p>The source CRS, e.g., \"EPSG:4326\".</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS, e.g., \"EPSG:3857\".</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The transformed coordinates in the format of (x, y)</p> Source code in <code>geojp/common.py</code> <pre><code>def transform_coords(x, y, src_crs, dst_crs, **kwargs):\n    \"\"\"Transform coordinates from one CRS to another.\n\n    Args:\n        x (float): The x coordinate.\n        y (float): The y coordinate.\n        src_crs (str): The source CRS, e.g., \"EPSG:4326\".\n        dst_crs (str): The destination CRS, e.g., \"EPSG:3857\".\n\n    Returns:\n        dict: The transformed coordinates in the format of (x, y)\n    \"\"\"\n    import pyproj\n\n    transformer = pyproj.Transformer.from_crs(\n        src_crs, dst_crs, always_xy=True, **kwargs\n    )\n    return transformer.transform(x, y)\n</code></pre>"},{"location":"common/#geojp.common.update_package","title":"<code>update_package()</code>","text":"<p>Updates the leafmap package from the leafmap GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package.</p> Source code in <code>geojp/common.py</code> <pre><code>def update_package():\n    \"\"\"Updates the leafmap package from the leafmap GitHub repository without the need to use pip or conda.\n    In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package.\n\n    \"\"\"\n\n    try:\n        download_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n        if not os.path.exists(download_dir):\n            os.makedirs(download_dir)\n        _clone_repo(out_dir=download_dir)\n\n        pkg_dir = os.path.join(download_dir, \"leafmap-master\")\n        work_dir = os.getcwd()\n        os.chdir(pkg_dir)\n\n        if shutil.which(\"pip\") is None:\n            cmd = \"pip3 install .\"\n        else:\n            cmd = \"pip install .\"\n\n        os.system(cmd)\n        os.chdir(work_dir)\n\n        print(\n            \"\\nPlease comment out 'leafmap.update_package()' and restart the kernel to take effect:\\nJupyter menu -&gt; Kernel -&gt; Restart &amp; Clear Output\"\n        )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.upload_to_imgur","title":"<code>upload_to_imgur(in_gif)</code>","text":"<p>Uploads an image to imgur.com</p> <p>Parameters:</p> Name Type Description Default <code>in_gif</code> <code>str</code> <p>The file path to the image.</p> required Source code in <code>geojp/common.py</code> <pre><code>def upload_to_imgur(in_gif: str):\n    \"\"\"Uploads an image to imgur.com\n\n    Args:\n        in_gif (str): The file path to the image.\n    \"\"\"\n    import subprocess\n\n    pkg_name = \"imgur-uploader\"\n    if not _is_tool(pkg_name):\n        _check_install(pkg_name)\n\n    try:\n        IMGUR_API_ID = os.environ.get(\"IMGUR_API_ID\", None)\n        IMGUR_API_SECRET = os.environ.get(\"IMGUR_API_SECRET\", None)\n        credentials_path = os.path.join(\n            os.path.expanduser(\"~\"), \".config/imgur_uploader/uploader.cfg\"\n        )\n\n        if (\n            (IMGUR_API_ID is not None) and (IMGUR_API_SECRET is not None)\n        ) or os.path.exists(credentials_path):\n            proc = subprocess.Popen([\"imgur-uploader\", in_gif], stdout=subprocess.PIPE)\n            for _ in range(0, 2):\n                line = proc.stdout.readline()\n                print(line.rstrip().decode(\"utf-8\"))\n            # while True:\n            #     line = proc.stdout.readline()\n            #     if not line:\n            #         break\n            #     print(line.rstrip().decode(\"utf-8\"))\n        else:\n            print(\n                \"Imgur API credentials could not be found. Please check https://pypi.org/project/imgur-uploader/ for instructions on how to get Imgur API credentials\"\n            )\n            return\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.vector_area","title":"<code>vector_area(vector, unit='m2', crs='epsg:3857')</code>","text":"<p>Calculate the area of a vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>str</code> <p>A local path or HTTP URL to a vector.</p> required <code>unit</code> <code>str</code> <p>The unit of the area, can be 'm2', 'km2', 'ha', or 'acres'. Defaults to 'm2'.</p> <code>'m2'</code> <p>Returns:</p> Type Description <code>float</code> <p>The area of the vector.</p> Source code in <code>geojp/common.py</code> <pre><code>def vector_area(vector, unit=\"m2\", crs=\"epsg:3857\"):\n    \"\"\"Calculate the area of a vector.\n\n    Args:\n        vector (str): A local path or HTTP URL to a vector.\n        unit (str, optional): The unit of the area, can be 'm2', 'km2', 'ha', or 'acres'. Defaults to 'm2'.\n\n    Returns:\n        float: The area of the vector.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(vector, str):\n        gdf = gpd.read_file(vector)\n    elif isinstance(vector, gpd.GeoDataFrame):\n        gdf = vector\n\n    area = gdf.to_crs(crs).area.sum()\n\n    if unit == \"m2\":\n        return area\n    elif unit == \"km2\":\n        return area / 1000000\n    elif unit == \"ha\":\n        return area / 10000\n    elif unit == \"acres\":\n        return area / 4046.8564224\n    else:\n        raise ValueError(\"Invalid unit.\")\n</code></pre>"},{"location":"common/#geojp.common.vector_col_names","title":"<code>vector_col_names(filename, **kwargs)</code>","text":"<p>Retrieves the column names of a vector attribute table.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input file path.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The list of column names.</p> Source code in <code>geojp/common.py</code> <pre><code>def vector_col_names(filename, **kwargs):\n    \"\"\"Retrieves the column names of a vector attribute table.\n\n    Args:\n        filename (str): The input file path.\n\n    Returns:\n        list: The list of column names.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import fiona\n\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".kml\":\n        fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n        gdf = gpd.read_file(filename, driver=\"KML\", **kwargs)\n    else:\n        gdf = gpd.read_file(filename, **kwargs)\n    col_names = gdf.columns.values.tolist()\n    return col_names\n</code></pre>"},{"location":"common/#geojp.common.vector_set_crs","title":"<code>vector_set_crs(source, output=None, crs='EPSG:4326', **kwargs)</code>","text":"<p>Set CRS of a vector file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | gpd.GeoDataFrame</code> <p>The path to the vector file or a GeoDataFrame.</p> required <code>output</code> <code>str</code> <p>The path to the output vector file. Defaults to None.</p> <code>None</code> <code>crs</code> <code>str</code> <p>The CRS to set. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>The GeoDataFrame with the new CRS.</p> Source code in <code>geojp/common.py</code> <pre><code>def vector_set_crs(source, output=None, crs=\"EPSG:4326\", **kwargs):\n    \"\"\"Set CRS of a vector file.\n\n    Args:\n        source (str | gpd.GeoDataFrame): The path to the vector file or a GeoDataFrame.\n        output (str, optional): The path to the output vector file. Defaults to None.\n        crs (str, optional): The CRS to set. Defaults to \"EPSG:4326\".\n\n\n    Returns:\n        gpd.GeoDataFrame: The GeoDataFrame with the new CRS.\n    \"\"\"\n\n    import geopandas as gpd\n\n    if isinstance(source, str):\n        source = gpd.read_file(source, **kwargs)\n\n    if not isinstance(source, gpd.GeoDataFrame):\n        raise TypeError(\"source must be a GeoDataFrame or a file path\")\n\n    gdf = source.set_crs(crs)\n\n    if output is not None:\n        gdf.to_file(output)\n    else:\n        return gdf\n</code></pre>"},{"location":"common/#geojp.common.vector_to_geojson","title":"<code>vector_to_geojson(filename, out_geojson=None, bbox=None, mask=None, rows=None, epsg='4326', encoding='utf-8', **kwargs)</code>","text":"<p>Converts any geopandas-supported vector dataset to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).</p> required <code>out_geojson</code> <code>str</code> <p>The file path to the output GeoJSON. Defaults to None.</p> <code>None</code> <code>bbox</code> <code>tuple | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.</p> <code>None</code> <code>mask</code> <code>dict | GeoDataFrame or GeoSeries | shapely Geometry</code> <p>Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.</p> <code>None</code> <code>rows</code> <code>int or slice</code> <p>Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.</p> <code>None</code> <code>epsg</code> <code>str</code> <p>The EPSG number to convert to. Defaults to \"4326\".</p> <code>'4326'</code> <code>encoding</code> <code>str</code> <p>The encoding of the input file. Defaults to \"utf-8\".</p> <code>'utf-8'</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>When the output file path is invalid.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the GeoJSON.</p> Source code in <code>geojp/common.py</code> <pre><code>def vector_to_geojson(\n    filename,\n    out_geojson=None,\n    bbox=None,\n    mask=None,\n    rows=None,\n    epsg=\"4326\",\n    encoding=\"utf-8\",\n    **kwargs,\n):\n    \"\"\"Converts any geopandas-supported vector dataset to GeoJSON.\n\n    Args:\n        filename (str): Either the absolute or relative path to the file or URL to be opened, or any object with a read() method (such as an open file or StringIO).\n        out_geojson (str, optional): The file path to the output GeoJSON. Defaults to None.\n        bbox (tuple | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter features by given bounding box, GeoSeries, GeoDataFrame or a shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with mask. Defaults to None.\n        mask (dict | GeoDataFrame or GeoSeries | shapely Geometry, optional): Filter for features that intersect with the given dict-like geojson geometry, GeoSeries, GeoDataFrame or shapely geometry. CRS mis-matches are resolved if given a GeoSeries or GeoDataFrame. Cannot be used with bbox. Defaults to None.\n        rows (int or slice, optional): Load in specific rows by passing an integer (first n rows) or a slice() object.. Defaults to None.\n        epsg (str, optional): The EPSG number to convert to. Defaults to \"4326\".\n        encoding (str, optional): The encoding of the input file. Defaults to \"utf-8\".\n\n\n    Raises:\n        ValueError: When the output file path is invalid.\n\n    Returns:\n        dict: A dictionary containing the GeoJSON.\n    \"\"\"\n\n    warnings.filterwarnings(\"ignore\")\n    check_package(name=\"geopandas\", URL=\"https://geopandas.org\")\n    import geopandas as gpd\n    import fiona\n\n    if not filename.startswith(\"http\"):\n        filename = os.path.abspath(filename)\n        if filename.endswith(\".zip\"):\n            filename = \"zip://\" + filename\n    ext = os.path.splitext(filename)[1].lower()\n    if ext == \".kml\":\n        fiona.drvsupport.supported_drivers[\"KML\"] = \"rw\"\n        df = gpd.read_file(\n            filename,\n            bbox=bbox,\n            mask=mask,\n            rows=rows,\n            driver=\"KML\",\n            encoding=encoding,\n            **kwargs,\n        )\n    else:\n        df = gpd.read_file(\n            filename, bbox=bbox, mask=mask, rows=rows, encoding=encoding, **kwargs\n        )\n    gdf = df.to_crs(epsg=epsg)\n\n    if out_geojson is not None:\n        if not out_geojson.lower().endswith(\".geojson\"):\n            raise ValueError(\"The output file must have a geojson file extension.\")\n\n        out_geojson = os.path.abspath(out_geojson)\n        out_dir = os.path.dirname(out_geojson)\n        if not os.path.exists(out_dir):\n            os.makedirs(out_dir)\n\n        gdf.to_file(out_geojson, driver=\"GeoJSON\")\n\n    else:\n        return gdf.__geo_interface__\n</code></pre>"},{"location":"common/#geojp.common.vector_to_gif","title":"<code>vector_to_gif(filename, out_gif, colname, vmin=None, vmax=None, step=1, facecolor='black', figsize=(10, 8), padding=3, title=None, add_text=True, xy=('1%', '1%'), fontsize=20, add_progress_bar=True, progress_bar_color='blue', progress_bar_height=5, dpi=300, fps=10, loop=0, mp4=False, keep_png=False, verbose=True, open_args={}, plot_args={})</code>","text":"<p>Convert a vector to a gif. This function was inspired by by Johannes Uhl's shapefile2gif repo at         https://github.com/johannesuhl/shapefile2gif. Credits to Johannes Uhl.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The input vector file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"</p> required <code>out_gif</code> <code>str</code> <p>The output gif file.</p> required <code>colname</code> <code>str</code> <p>The column name of the vector that contains numerical values.</p> required <code>vmin</code> <code>float</code> <p>The minimum value to filter the data. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value to filter the data. Defaults to None.</p> <code>None</code> <code>step</code> <code>float</code> <p>The step to filter the data. Defaults to 1.</p> <code>1</code> <code>facecolor</code> <code>str</code> <p>The color to visualize the data. Defaults to \"black\".</p> <code>'black'</code> <code>figsize</code> <code>tuple</code> <p>The figure size. Defaults to (10, 8).</p> <code>(10, 8)</code> <code>padding</code> <code>int</code> <p>The padding of the figure tight_layout. Defaults to 3.</p> <code>3</code> <code>title</code> <code>str</code> <p>The title of the figure. Defaults to None.</p> <code>None</code> <code>add_text</code> <code>bool</code> <p>Whether to add text to the figure. Defaults to True.</p> <code>True</code> <code>xy</code> <code>tuple</code> <p>The position of the text from the lower-left corner. Defaults to (\"1%\", \"1%\").</p> <code>('1%', '1%')</code> <code>fontsize</code> <code>int</code> <p>The font size of the text. Defaults to 20.</p> <code>20</code> <code>add_progress_bar</code> <code>bool</code> <p>Whether to add a progress bar to the figure. Defaults to True.</p> <code>True</code> <code>progress_bar_color</code> <code>str</code> <p>The color of the progress bar. Defaults to \"blue\".</p> <code>'blue'</code> <code>progress_bar_height</code> <code>int</code> <p>The height of the progress bar. Defaults to 5.</p> <code>5</code> <code>dpi</code> <code>int</code> <p>The dpi of the figure. Defaults to 300.</p> <code>300</code> <code>fps</code> <code>int</code> <p>The frames per second (fps) of the gif. Defaults to 10.</p> <code>10</code> <code>loop</code> <code>int</code> <p>The number of loops of the gif. Defaults to 0, infinite loop.</p> <code>0</code> <code>mp4</code> <code>bool</code> <p>Whether to convert the gif to mp4. Defaults to False.</p> <code>False</code> <code>keep_png</code> <code>bool</code> <p>Whether to keep the png files. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print the progress. Defaults to True.</p> <code>True</code> <code>open_args</code> <code>dict</code> <p>The arguments for the geopandas.read_file() function. Defaults to {}.</p> <code>{}</code> <code>plot_args</code> <code>dict</code> <p>The arguments for the geopandas.GeoDataFrame.plot() function. Defaults to {}.</p> <code>{}</code> Source code in <code>geojp/common.py</code> <pre><code>def vector_to_gif(\n    filename,\n    out_gif,\n    colname,\n    vmin=None,\n    vmax=None,\n    step=1,\n    facecolor=\"black\",\n    figsize=(10, 8),\n    padding=3,\n    title=None,\n    add_text=True,\n    xy=(\"1%\", \"1%\"),\n    fontsize=20,\n    add_progress_bar=True,\n    progress_bar_color=\"blue\",\n    progress_bar_height=5,\n    dpi=300,\n    fps=10,\n    loop=0,\n    mp4=False,\n    keep_png=False,\n    verbose=True,\n    open_args={},\n    plot_args={},\n):\n    \"\"\"Convert a vector to a gif. This function was inspired by by Johannes Uhl's shapefile2gif repo at\n            https://github.com/johannesuhl/shapefile2gif. Credits to Johannes Uhl.\n\n    Args:\n        filename (str): The input vector file. Can be a directory path or http URL, e.g., \"https://i.imgur.com/ZWSZC5z.gif\"\n        out_gif (str): The output gif file.\n        colname (str): The column name of the vector that contains numerical values.\n        vmin (float, optional): The minimum value to filter the data. Defaults to None.\n        vmax (float, optional): The maximum value to filter the data. Defaults to None.\n        step (float, optional): The step to filter the data. Defaults to 1.\n        facecolor (str, optional): The color to visualize the data. Defaults to \"black\".\n        figsize (tuple, optional): The figure size. Defaults to (10, 8).\n        padding (int, optional): The padding of the figure tight_layout. Defaults to 3.\n        title (str, optional): The title of the figure. Defaults to None.\n        add_text (bool, optional): Whether to add text to the figure. Defaults to True.\n        xy (tuple, optional): The position of the text from the lower-left corner. Defaults to (\"1%\", \"1%\").\n        fontsize (int, optional): The font size of the text. Defaults to 20.\n        add_progress_bar (bool, optional): Whether to add a progress bar to the figure. Defaults to True.\n        progress_bar_color (str, optional): The color of the progress bar. Defaults to \"blue\".\n        progress_bar_height (int, optional): The height of the progress bar. Defaults to 5.\n        dpi (int, optional): The dpi of the figure. Defaults to 300.\n        fps (int, optional): The frames per second (fps) of the gif. Defaults to 10.\n        loop (int, optional): The number of loops of the gif. Defaults to 0, infinite loop.\n        mp4 (bool, optional): Whether to convert the gif to mp4. Defaults to False.\n        keep_png (bool, optional): Whether to keep the png files. Defaults to False.\n        verbose (bool, optional): Whether to print the progress. Defaults to True.\n        open_args (dict, optional): The arguments for the geopandas.read_file() function. Defaults to {}.\n        plot_args (dict, optional): The arguments for the geopandas.GeoDataFrame.plot() function. Defaults to {}.\n\n    \"\"\"\n    import geopandas as gpd\n    import matplotlib.pyplot as plt\n\n    out_dir = os.path.dirname(out_gif)\n    tmp_dir = os.path.join(out_dir, \"tmp_png\")\n    if not os.path.exists(tmp_dir):\n        os.makedirs(tmp_dir)\n\n    if isinstance(filename, str):\n        gdf = gpd.read_file(filename, **open_args)\n    elif isinstance(filename, gpd.GeoDataFrame):\n        gdf = filename\n    else:\n        raise ValueError(\n            \"filename must be a string or a geopandas.GeoDataFrame object.\"\n        )\n\n    bbox = gdf.total_bounds\n\n    if colname not in gdf.columns:\n        raise Exception(\n            f\"{colname} is not in the columns of the GeoDataFrame. It must be one of {gdf.columns}\"\n        )\n\n    values = gdf[colname].unique().tolist()\n    values.sort()\n\n    if vmin is None:\n        vmin = values[0]\n    if vmax is None:\n        vmax = values[-1]\n\n    options = range(vmin, vmax + step, step)\n\n    W = bbox[2] - bbox[0]\n    H = bbox[3] - bbox[1]\n\n    if xy is None:\n        # default text location is 5% width and 5% height of the image.\n        xy = (int(0.05 * W), int(0.05 * H))\n    elif (xy is not None) and (not isinstance(xy, tuple)) and (len(xy) == 2):\n        raise Exception(\"xy must be a tuple, e.g., (10, 10), ('10%', '10%')\")\n\n    elif all(isinstance(item, int) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (x &gt; 0) and (x &lt; W) and (y &gt; 0) and (y &lt; H):\n            pass\n        else:\n            print(\n                f\"xy is out of bounds. x must be within [0, {W}], and y must be within [0, {H}]\"\n            )\n            return\n    elif all(isinstance(item, str) for item in xy) and (len(xy) == 2):\n        x, y = xy\n        if (\"%\" in x) and (\"%\" in y):\n            try:\n                x = float(x.replace(\"%\", \"\")) / 100.0 * W\n                y = float(y.replace(\"%\", \"\")) / 100.0 * H\n            except Exception:\n                raise Exception(\n                    \"The specified xy is invalid. It must be formatted like this ('10%', '10%')\"\n                )\n    else:\n        raise Exception(\n            \"The specified xy is invalid. It must be formatted like this: (10, 10) or ('10%', '10%')\"\n        )\n\n    x = bbox[0] + x\n    y = bbox[1] + y\n\n    for index, v in enumerate(options):\n        if verbose:\n            print(f\"Processing {index+1}/{len(options)}: {v}...\")\n        yrdf = gdf[gdf[colname] &lt;= v]\n        fig, ax = plt.subplots()\n        ax = yrdf.plot(facecolor=facecolor, figsize=figsize, **plot_args)\n        ax.set_title(title, fontsize=fontsize)\n        ax.set_axis_off()\n        ax.set_xlim([bbox[0], bbox[2]])\n        ax.set_ylim([bbox[1], bbox[3]])\n        if add_text:\n            ax.text(x, y, v, fontsize=fontsize)\n        fig = ax.get_figure()\n        plt.tight_layout(pad=padding)\n        fig.savefig(tmp_dir + os.sep + \"%s.png\" % v, dpi=dpi)\n        plt.clf()\n        plt.close(\"all\")\n\n    png_to_gif(tmp_dir, out_gif, fps=fps, loop=loop)\n\n    if add_progress_bar:\n        add_progress_bar_to_gif(\n            out_gif,\n            out_gif,\n            progress_bar_color,\n            progress_bar_height,\n            duration=1000 / fps,\n            loop=loop,\n        )\n\n    if mp4:\n        gif_to_mp4(out_gif, out_gif.replace(\".gif\", \".mp4\"))\n\n    if not keep_png:\n        shutil.rmtree(tmp_dir)\n\n    if verbose:\n        print(f\"Done. The GIF is saved to {out_gif}.\")\n</code></pre>"},{"location":"common/#geojp.common.vector_to_mbtiles","title":"<code>vector_to_mbtiles(source_path, target_path, max_zoom=5, name=None, **kwargs)</code>","text":"<p>Convert a vector dataset to MBTiles format using the ogr2ogr command-line tool.</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>str</code> <p>The path to the source vector dataset (GeoPackage, Shapefile, etc.).</p> required <code>target_path</code> <code>str</code> <p>The path to the target MBTiles file to be created.</p> required <code>max_zoom</code> <code>int</code> <p>The maximum zoom level for the MBTiles dataset. Defaults to 5.</p> <code>5</code> <code>name</code> <code>str</code> <p>The name of the MBTiles dataset. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional options to be passed as keyword arguments. These options will be used as -dsco options       when calling ogr2ogr. See https://gdal.org/drivers/raster/mbtiles.html for a list of options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>subprocess.CalledProcessError</code> <p>If the ogr2ogr command fails to execute.</p> <p>Examples:</p> <p>source_path = \"countries.gpkg\" target_path = \"target.mbtiles\" name = \"My MBTiles\" max_zoom = 5 vector_to_mbtiles(source_path, target_path, name=name, max_zoom=max_zoom)</p> Source code in <code>geojp/common.py</code> <pre><code>def vector_to_mbtiles(\n    source_path: str, target_path: str, max_zoom: int = 5, name: str = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Convert a vector dataset to MBTiles format using the ogr2ogr command-line tool.\n\n    Args:\n        source_path (str): The path to the source vector dataset (GeoPackage, Shapefile, etc.).\n        target_path (str): The path to the target MBTiles file to be created.\n        max_zoom (int, optional): The maximum zoom level for the MBTiles dataset. Defaults to 5.\n        name (str, optional): The name of the MBTiles dataset. Defaults to None.\n        **kwargs: Additional options to be passed as keyword arguments. These options will be used as -dsco options\n                  when calling ogr2ogr. See https://gdal.org/drivers/raster/mbtiles.html for a list of options.\n\n    Returns:\n        None\n\n    Raises:\n        subprocess.CalledProcessError: If the ogr2ogr command fails to execute.\n\n    Example:\n        source_path = \"countries.gpkg\"\n        target_path = \"target.mbtiles\"\n        name = \"My MBTiles\"\n        max_zoom = 5\n        vector_to_mbtiles(source_path, target_path, name=name, max_zoom=max_zoom)\n    \"\"\"\n    import subprocess\n\n    command = [\n        \"ogr2ogr\",\n        \"-f\",\n        \"MBTILES\",\n        target_path,\n        source_path,\n        \"-dsco\",\n        f\"MAXZOOM={max_zoom}\",\n    ]\n\n    if name:\n        command.extend([\"-dsco\", f\"NAME={name}\"])\n\n    for key, value in kwargs.items():\n        command.extend([\"-dsco\", f\"{key.upper()}={value}\"])\n\n    try:\n        subprocess.run(command, check=True)\n    except subprocess.CalledProcessError as e:\n        raise e\n</code></pre>"},{"location":"common/#geojp.common.vector_to_parquet","title":"<code>vector_to_parquet(source, output, crs=None, overwrite=False, **kwargs)</code>","text":"<p>Convert a GeoDataFrame or a file containing vector data to Parquet format.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[gpd.GeoDataFrame, str]</code> <p>The source data to convert. It can be either a GeoDataFrame or a file path to the vector data file.</p> required <code>output</code> <code>str</code> <p>The file path where the Parquet file will be saved.</p> required <code>crs</code> <code>str</code> <p>The coordinate reference system (CRS) to use for the output file. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing output file. Default is False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the <code>to_parquet</code> function of GeoDataFrame.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>geojp/common.py</code> <pre><code>def vector_to_parquet(\n    source: str, output: str, crs=None, overwrite=False, **kwargs\n) -&gt; None:\n    \"\"\"\n    Convert a GeoDataFrame or a file containing vector data to Parquet format.\n\n    Args:\n        source (Union[gpd.GeoDataFrame, str]): The source data to convert. It can be either a GeoDataFrame\n            or a file path to the vector data file.\n        output (str): The file path where the Parquet file will be saved.\n        crs (str, optional): The coordinate reference system (CRS) to use for the output file. Defaults to None.\n        overwrite (bool): Whether to overwrite the existing output file. Default is False.\n        **kwargs: Additional keyword arguments to be passed to the `to_parquet` function of GeoDataFrame.\n\n    Returns:\n        None\n    \"\"\"\n\n    import geopandas as gpd\n\n    if os.path.exists(output) and not overwrite:\n        print(f\"File {output} already exists. Skipping...\")\n        return\n\n    if isinstance(source, gpd.GeoDataFrame):\n        gdf = source\n    else:\n        gdf = gpd.read_file(source)\n\n    if crs is not None:\n        gdf = gdf.to_crs(crs)\n\n    out_dir = os.path.dirname(os.path.abspath(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    gdf.to_parquet(output, **kwargs)\n</code></pre>"},{"location":"common/#geojp.common.vector_to_pmtiles","title":"<code>vector_to_pmtiles(source_path, target_path, max_zoom=5, name=None, **kwargs)</code>","text":"<p>Converts a vector file to PMTiles format.</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>str</code> <p>Path to the source vector file.</p> required <code>target_path</code> <code>str</code> <p>Path to the target PMTiles file.</p> required <code>max_zoom</code> <code>int</code> <p>Maximum zoom level for the PMTiles. Defaults to 5.</p> <code>5</code> <code>name</code> <code>str</code> <p>Name of the PMTiles dataset. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the underlying conversion functions.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the target file does not have a .pmtiles extension.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>geojp/common.py</code> <pre><code>def vector_to_pmtiles(\n    source_path: str, target_path: str, max_zoom: int = 5, name: str = None, **kwargs\n):\n    \"\"\"\n    Converts a vector file to PMTiles format.\n\n    Args:\n        source_path (str): Path to the source vector file.\n        target_path (str): Path to the target PMTiles file.\n        max_zoom (int, optional): Maximum zoom level for the PMTiles. Defaults to 5.\n        name (str, optional): Name of the PMTiles dataset. Defaults to None.\n        **kwargs: Additional keyword arguments to be passed to the underlying conversion functions.\n\n    Raises:\n        ValueError: If the target file does not have a .pmtiles extension.\n\n    Returns:\n        None\n    \"\"\"\n    if not target_path.endswith(\".pmtiles\"):\n        raise ValueError(\"Error: target file must be a .pmtiles file.\")\n    mbtiles = target_path.replace(\".pmtiles\", \".mbtiles\")\n    vector_to_mbtiles(source_path, mbtiles, max_zoom=max_zoom, name=name, **kwargs)\n    mbtiles_to_pmtiles(mbtiles, target_path)\n    os.remove(mbtiles)\n</code></pre>"},{"location":"common/#geojp.common.vector_to_raster","title":"<code>vector_to_raster(vector, output, field='FID', assign='last', nodata=True, cell_size=None, base=None, callback=None, verbose=False, to_epsg=None)</code>","text":"<p>Convert a vector to a raster.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>str | GeoPandas.GeoDataFrame</code> <p>The input vector data, can be a file path or a GeoDataFrame.</p> required <code>output</code> <code>str</code> <p>The output raster file path.</p> required <code>field</code> <code>str</code> <p>Input field name in attribute table. Defaults to 'FID'.</p> <code>'FID'</code> <code>assign</code> <code>str</code> <p>Assignment operation, where multiple points are in the same grid cell; options include 'first', 'last' (default), 'min', 'max', 'sum', 'number'. Defaults to 'last'.</p> <code>'last'</code> <code>nodata</code> <code>bool</code> <p>Background value to set to NoData. Without this flag, it will be set to 0.0.</p> <code>True</code> <code>cell_size</code> <code>float</code> <p>Optionally specified cell size of output raster. Not used when base raster is specified</p> <code>None</code> <code>base</code> <code>str</code> <p>Optionally specified input base raster file. Not used when a cell size is specified. Defaults to None.</p> <code>None</code> <code>callback</code> <code>fuct</code> <p>A callback function to report progress. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print progress to the console. Defaults to False.</p> <code>False</code> <code>to_epsg</code> <code>integer</code> <p>Optionally specified the EPSG code to reproject the raster to. Defaults to None.</p> <code>None</code> Source code in <code>geojp/common.py</code> <pre><code>def vector_to_raster(\n    vector,\n    output,\n    field=\"FID\",\n    assign=\"last\",\n    nodata=True,\n    cell_size=None,\n    base=None,\n    callback=None,\n    verbose=False,\n    to_epsg=None,\n):\n    \"\"\"Convert a vector to a raster.\n\n    Args:\n        vector (str | GeoPandas.GeoDataFrame): The input vector data, can be a file path or a GeoDataFrame.\n        output (str): The output raster file path.\n        field (str, optional): Input field name in attribute table. Defaults to 'FID'.\n        assign (str, optional): Assignment operation, where multiple points are in the same grid cell; options\n            include 'first', 'last' (default), 'min', 'max', 'sum', 'number'. Defaults to 'last'.\n        nodata (bool, optional): Background value to set to NoData. Without this flag, it will be set to 0.0.\n        cell_size (float, optional): Optionally specified cell size of output raster. Not used when base raster is specified\n        base (str, optional): Optionally specified input base raster file. Not used when a cell size is specified. Defaults to None.\n        callback (fuct, optional): A callback function to report progress. Defaults to None.\n        verbose (bool, optional): Whether to print progress to the console. Defaults to False.\n        to_epsg (integer, optional): Optionally specified the EPSG code to reproject the raster to. Defaults to None.\n\n    \"\"\"\n    import geopandas as gpd\n    import whitebox\n\n    output = os.path.abspath(output)\n\n    if isinstance(vector, str):\n        gdf = gpd.read_file(vector)\n    elif isinstance(vector, gpd.GeoDataFrame):\n        gdf = vector\n    else:\n        raise TypeError(\"vector must be a file path or a GeoDataFrame\")\n\n    if to_epsg is None:\n        to_epsg = 3857\n\n    if to_epsg == 4326:\n        raise ValueError(\"to_epsg cannot be 4326\")\n\n    if gdf.crs.is_geographic:\n        gdf = gdf.to_crs(epsg=to_epsg)\n        vector = temp_file_path(extension=\".shp\")\n        gdf.to_file(vector)\n    else:\n        to_epsg = gdf.crs.to_epsg()\n\n    wbt = whitebox.WhiteboxTools()\n    wbt.verbose = verbose\n\n    goem_type = gdf.geom_type[0]\n\n    if goem_type == \"LineString\":\n        wbt.vector_lines_to_raster(\n            vector, output, field, nodata, cell_size, base, callback\n        )\n    elif goem_type == \"Polygon\":\n        wbt.vector_polygons_to_raster(\n            vector, output, field, nodata, cell_size, base, callback\n        )\n    else:\n        wbt.vector_points_to_raster(\n            vector, output, field, assign, nodata, cell_size, base, callback\n        )\n\n    image_set_crs(output, to_epsg)\n</code></pre>"},{"location":"common/#geojp.common.view_lidar","title":"<code>view_lidar(filename, cmap='terrain', backend='pyvista', background=None, eye_dome_lighting=False, **kwargs)</code>","text":"<p>View LiDAR data in 3D.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filepath to the LiDAR data.</p> required <code>cmap</code> <code>str</code> <p>The colormap to use. Defaults to \"terrain\". cmap currently does not work for the open3d backend.</p> <code>'terrain'</code> <code>backend</code> <code>str</code> <p>The plotting backend to use, can be pyvista, ipygany, panel, and open3d. Defaults to \"pyvista\".</p> <code>'pyvista'</code> <code>background</code> <code>str</code> <p>The background color to use. Defaults to None.</p> <code>None</code> <code>eye_dome_lighting</code> <code>bool</code> <p>Whether to use eye dome lighting. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>ValueError</code> <p>If the backend is not supported.</p> Source code in <code>geojp/common.py</code> <pre><code>def view_lidar(\n    filename,\n    cmap=\"terrain\",\n    backend=\"pyvista\",\n    background=None,\n    eye_dome_lighting=False,\n    **kwargs,\n):\n    \"\"\"View LiDAR data in 3D.\n\n    Args:\n        filename (str): The filepath to the LiDAR data.\n        cmap (str, optional): The colormap to use. Defaults to \"terrain\". cmap currently does not work for the open3d backend.\n        backend (str, optional): The plotting backend to use, can be pyvista, ipygany, panel, and open3d. Defaults to \"pyvista\".\n        background (str, optional): The background color to use. Defaults to None.\n        eye_dome_lighting (bool, optional): Whether to use eye dome lighting. Defaults to False.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        ValueError: If the backend is not supported.\n    \"\"\"\n\n    import sys\n\n    if os.environ.get(\"USE_MKDOCS\") is not None:\n        return\n\n    if \"google.colab\" in sys.modules:\n        print(\"This function is not supported in Google Colab.\")\n        return\n\n    warnings.filterwarnings(\"ignore\")\n    filename = os.path.abspath(filename)\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"{filename} does not exist.\")\n\n    backend = backend.lower()\n    if backend in [\"pyvista\", \"ipygany\", \"panel\"]:\n        try:\n            import pyntcloud\n        except ImportError:\n            print(\n                \"The pyvista and pyntcloud packages are required for this function. Use pip install leafmap[lidar] to install them.\"\n            )\n            return\n\n        try:\n            if backend == \"pyvista\":\n                backend = None\n            if backend == \"ipygany\":\n                cmap = None\n            data = pyntcloud.PyntCloud.from_file(filename)\n            mesh = data.to_instance(\"pyvista\", mesh=False)\n            mesh = mesh.elevation()\n            mesh.plot(\n                scalars=\"Elevation\",\n                cmap=cmap,\n                jupyter_backend=backend,\n                background=background,\n                eye_dome_lighting=eye_dome_lighting,\n                **kwargs,\n            )\n\n        except Exception as e:\n            print(\"Something went wrong.\")\n            print(e)\n            return\n\n    elif backend == \"open3d\":\n        try:\n            import laspy\n            import open3d as o3d\n            import numpy as np\n        except ImportError:\n            print(\n                \"The laspy and open3d packages are required for this function. Use pip install laspy open3d to install them.\"\n            )\n            return\n\n        try:\n            las = laspy.read(filename)\n            point_data = np.stack([las.X, las.Y, las.Z], axis=0).transpose((1, 0))\n            geom = o3d.geometry.PointCloud()\n            geom.points = o3d.utility.Vector3dVector(point_data)\n            # geom.colors =  o3d.utility.Vector3dVector(colors)  # need to add colors. A list in the form of [[r,g,b], [r,g,b]] with value range 0-1. https://github.com/isl-org/Open3D/issues/614\n            o3d.visualization.draw_geometries([geom], **kwargs)\n\n        except Exception as e:\n            print(\"Something went wrong.\")\n            print(e)\n            return\n\n    else:\n        raise ValueError(f\"{backend} is not a valid backend.\")\n</code></pre>"},{"location":"common/#geojp.common.whiteboxgui","title":"<code>whiteboxgui(verbose=True, tree=False, reset=False, sandbox_path=None)</code>","text":"<p>Shows the WhiteboxTools GUI.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Whether to show progress info when the tool is running. Defaults to True.</p> <code>True</code> <code>tree</code> <code>bool</code> <p>Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False.</p> <code>False</code> <code>reset</code> <code>bool</code> <p>Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False.</p> <code>False</code> <code>sandbox_path</code> <code>str</code> <p>The path to the sandbox folder. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>A toolbox GUI.</p> Source code in <code>geojp/common.py</code> <pre><code>def whiteboxgui(\n    verbose: Optional[bool] = True,\n    tree: Optional[bool] = False,\n    reset: Optional[bool] = False,\n    sandbox_path: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"Shows the WhiteboxTools GUI.\n\n    Args:\n        verbose (bool, optional): Whether to show progress info when the tool is running. Defaults to True.\n        tree (bool, optional): Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False.\n        reset (bool, optional): Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False.\n        sandbox_path (str, optional): The path to the sandbox folder. Defaults to None.\n\n    Returns:\n        object: A toolbox GUI.\n    \"\"\"\n    import whiteboxgui\n\n    return whiteboxgui.show(verbose, tree, reset, sandbox_path)\n</code></pre>"},{"location":"common/#geojp.common.widget_template","title":"<code>widget_template(widget=None, opened=True, show_close_button=True, widget_icon='gear', close_button_icon='times', widget_args={}, close_button_args={}, display_widget=None, m=None, position='topright')</code>","text":"<p>Create a widget template.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>ipywidgets.Widget</code> <p>The widget to be displayed. Defaults to None.</p> <code>None</code> <code>opened</code> <code>bool</code> <p>Whether to open the toolbar. Defaults to True.</p> <code>True</code> <code>show_close_button</code> <code>bool</code> <p>Whether to show the close button. Defaults to True.</p> <code>True</code> <code>widget_icon</code> <code>str</code> <p>The icon name for the toolbar button. Defaults to 'gear'.</p> <code>'gear'</code> <code>close_button_icon</code> <code>str</code> <p>The icon name for the close button. Defaults to \"times\".</p> <code>'times'</code> <code>widget_args</code> <code>dict</code> <p>Additional arguments to pass to the toolbar button. Defaults to {}.</p> <code>{}</code> <code>close_button_args</code> <code>dict</code> <p>Additional arguments to pass to the close button. Defaults to {}.</p> <code>{}</code> <code>display_widget</code> <code>ipywidgets.Widget</code> <p>The widget to be displayed when the toolbar is clicked.</p> <code>None</code> <code>m</code> <code>geemap.Map</code> <p>The geemap.Map instance. Defaults to None.</p> <code>None</code> <code>position</code> <code>str</code> <p>The position of the toolbar. Defaults to \"topright\".</p> <code>'topright'</code> Source code in <code>geojp/common.py</code> <pre><code>def widget_template(\n    widget=None,\n    opened=True,\n    show_close_button=True,\n    widget_icon=\"gear\",\n    close_button_icon=\"times\",\n    widget_args={},\n    close_button_args={},\n    display_widget=None,\n    m=None,\n    position=\"topright\",\n):\n    \"\"\"Create a widget template.\n\n    Args:\n        widget (ipywidgets.Widget, optional): The widget to be displayed. Defaults to None.\n        opened (bool, optional): Whether to open the toolbar. Defaults to True.\n        show_close_button (bool, optional): Whether to show the close button. Defaults to True.\n        widget_icon (str, optional): The icon name for the toolbar button. Defaults to 'gear'.\n        close_button_icon (str, optional): The icon name for the close button. Defaults to \"times\".\n        widget_args (dict, optional): Additional arguments to pass to the toolbar button. Defaults to {}.\n        close_button_args (dict, optional): Additional arguments to pass to the close button. Defaults to {}.\n        display_widget (ipywidgets.Widget, optional): The widget to be displayed when the toolbar is clicked.\n        m (geemap.Map, optional): The geemap.Map instance. Defaults to None.\n        position (str, optional): The position of the toolbar. Defaults to \"topright\".\n    \"\"\"\n\n    name = \"_\" + random_string()  # a random attribute name\n\n    if \"value\" not in widget_args:\n        widget_args[\"value\"] = False\n    if \"tooltip\" not in widget_args:\n        widget_args[\"tooltip\"] = \"Toolbar\"\n    if \"layout\" not in widget_args:\n        widget_args[\"layout\"] = widgets.Layout(\n            width=\"28px\", height=\"28px\", padding=\"0px 0px 0px 4px\"\n        )\n    widget_args[\"icon\"] = widget_icon\n\n    if \"value\" not in close_button_args:\n        close_button_args[\"value\"] = False\n    if \"tooltip\" not in close_button_args:\n        close_button_args[\"tooltip\"] = \"Close the tool\"\n    if \"button_style\" not in close_button_args:\n        close_button_args[\"button_style\"] = \"primary\"\n    if \"layout\" not in close_button_args:\n        close_button_args[\"layout\"] = widgets.Layout(\n            height=\"28px\", width=\"28px\", padding=\"0px 0px 0px 4px\"\n        )\n    close_button_args[\"icon\"] = close_button_icon\n\n    toolbar_button = widgets.ToggleButton(**widget_args)\n\n    close_button = widgets.ToggleButton(**close_button_args)\n\n    toolbar_widget = widgets.VBox()\n    toolbar_widget.children = [toolbar_button]\n    toolbar_header = widgets.HBox()\n    if show_close_button:\n        toolbar_header.children = [close_button, toolbar_button]\n    else:\n        toolbar_header.children = [toolbar_button]\n    toolbar_footer = widgets.VBox()\n\n    if widget is not None:\n        toolbar_footer.children = [\n            widget,\n        ]\n    else:\n        toolbar_footer.children = []\n\n    def toolbar_btn_click(change):\n        if change[\"new\"]:\n            close_button.value = False\n            toolbar_widget.children = [toolbar_header, toolbar_footer]\n            if display_widget is not None:\n                widget.outputs = ()\n                with widget:\n                    display(display_widget)\n        else:\n            toolbar_widget.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_btn_click, \"value\")\n\n    def close_btn_click(change):\n        if change[\"new\"]:\n            toolbar_button.value = False\n            if m is not None:\n                control = getattr(m, name)\n                if control is not None and control in m.controls:\n                    m.remove_control(control)\n                    delattr(m, name)\n            toolbar_widget.close()\n\n    close_button.observe(close_btn_click, \"value\")\n\n    toolbar_button.value = opened\n    if m is not None:\n        import ipyleaflet\n\n        toolbar_control = ipyleaflet.WidgetControl(\n            widget=toolbar_widget, position=position\n        )\n\n        if toolbar_control not in m.controls:\n            m.add_control(toolbar_control)\n\n            setattr(m, name, toolbar_control)\n\n    else:\n        return toolbar_widget\n</code></pre>"},{"location":"common/#geojp.common.write_lidar","title":"<code>write_lidar(source, destination, do_compress=None, laz_backend=None)</code>","text":"<p>Writes to a stream or file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | laspy.lasdatas.base.LasBase</code> <p>The source data to be written.</p> required <code>destination</code> <code>str</code> <p>The destination filepath.</p> required <code>do_compress</code> <code>bool</code> <p>Flags to indicate if you want to compress the data. Defaults to None.</p> <code>None</code> <code>laz_backend</code> <code>str</code> <p>The laz backend to use. Defaults to None.</p> <code>None</code> Source code in <code>geojp/common.py</code> <pre><code>def write_lidar(source, destination, do_compress=None, laz_backend=None):\n    \"\"\"Writes to a stream or file.\n\n    Args:\n        source (str | laspy.lasdatas.base.LasBase): The source data to be written.\n        destination (str): The destination filepath.\n        do_compress (bool, optional): Flags to indicate if you want to compress the data. Defaults to None.\n        laz_backend (str, optional): The laz backend to use. Defaults to None.\n    \"\"\"\n\n    try:\n        import laspy\n    except ImportError:\n        print(\n            \"The laspy package is required for this function. Use `pip install laspy[lazrs,laszip]` to install it.\"\n        )\n        return\n\n    if isinstance(source, str):\n        source = read_lidar(source)\n\n    source.write(destination, do_compress=do_compress, laz_backend=laz_backend)\n</code></pre>"},{"location":"common/#geojp.common.xy_to_window","title":"<code>xy_to_window(xy)</code>","text":"<p>Converts a list of coordinates to a rasterio window.</p> <p>Parameters:</p> Name Type Description Default <code>xy</code> <code>list</code> <p>A list of coordinates in the format of [[x1, y1], [x2, y2]]</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>The rasterio window in the format of (col_off, row_off, width, height)</p> Source code in <code>geojp/common.py</code> <pre><code>def xy_to_window(xy):\n    \"\"\"Converts a list of coordinates to a rasterio window.\n\n    Args:\n        xy (list): A list of coordinates in the format of [[x1, y1], [x2, y2]]\n\n    Returns:\n        tuple: The rasterio window in the format of (col_off, row_off, width, height)\n    \"\"\"\n\n    x1, y1 = xy[0]\n    x2, y2 = xy[1]\n\n    left = min(x1, x2)\n    right = max(x1, x2)\n    top = min(y1, y2)\n    bottom = max(y1, y2)\n\n    width = right - left\n    height = bottom - top\n\n    return (left, top, width, height)\n</code></pre>"},{"location":"common/#geojp.common.zonal_stats","title":"<code>zonal_stats(vectors, raster, layer=0, band_num=1, nodata=None, affine=None, stats=None, all_touched=False, categorical=False, category_map=None, add_stats=None, raster_out=False, prefix=None, geojson_out=False, gdf_out=False, dst_crs=None, open_vector_args={}, open_raster_args={}, **kwargs)</code>","text":"<p>This function wraps rasterstats.zonal_stats and performs reprojection if necessary.     See https://pythonhosted.org/rasterstats/rasterstats.html.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>str | list | GeoDataFrame</code> <p>path to an vector source or geo-like python objects.</p> required <code>raster</code> <code>str | ndarray</code> <p>ndarray or path to a GDAL raster source.</p> required <code>layer</code> <code>int</code> <p>If vectors is a path to an fiona source, specify the vector layer to use either by name or number. Defaults to 0</p> <code>0</code> <code>band_num</code> <code>int | str</code> <p>If raster is a GDAL source, the band number to use (counting from 1). defaults to 1.</p> <code>1</code> <code>nodata</code> <code>float</code> <p>If raster is a GDAL source, this value overrides any NODATA value specified in the file\u2019s metadata. If None, the file\u2019s metadata\u2019s NODATA value (if any) will be used. defaults to None.</p> <code>None</code> <code>affine</code> <code>Affine</code> <p>required only for ndarrays, otherwise it is read from src. Defaults to None.</p> <code>None</code> <code>stats</code> <code>str | list</code> <p>Which statistics to calculate for each zone. It can be ['min', 'max', 'mean', 'count']. For more, see https://pythonhosted.org/rasterstats/manual.html#zonal-statistics Defaults to None.</p> <code>None</code> <code>all_touched</code> <code>bool</code> <p>Whether to include every raster cell touched by a geometry, or only those having a center point within the polygon. defaults to False</p> <code>False</code> <code>categorical</code> <code>bool</code> <p>If True, the raster values will be treated as categorical.</p> <code>False</code> <code>category_map</code> <code>dict</code> <p>A dictionary mapping raster values to human-readable categorical names. Only applies when categorical is True</p> <code>None</code> <code>add_stats</code> <code>dict</code> <p>with names and functions of additional stats to compute. Defaults to None.</p> <code>None</code> <code>raster_out</code> <code>bool</code> <p>Include the masked numpy array for each feature?. Defaults to False.</p> <code>False</code> <code>prefix</code> <code>str</code> <p>add a prefix to the keys. Defaults to None.</p> <code>None</code> <code>geojson_out</code> <code>bool</code> <p>Return list of GeoJSON-like features (default: False) Original feature geometry and properties will be retained with zonal stats appended as additional properties. Use with prefix to ensure unique and meaningful property names.. Defaults to False.</p> <code>False</code> <code>gdf_out</code> <code>bool</code> <p>Return a GeoDataFrame. Defaults to False.</p> <code>False</code> <code>dst_crs</code> <code>str</code> <p>The destination CRS. Defaults to None.</p> <code>None</code> <code>open_vector_args</code> <code>dict</code> <p>Pass additional arguments to geopandas.open_file(). Defaults to {}.</p> <code>{}</code> <code>open_raster_args</code> <code>dict</code> <p>Pass additional arguments to rasterio.open(). Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict | list | GeoDataFrame</code> <p>The zonal statistics results</p> Source code in <code>geojp/common.py</code> <pre><code>def zonal_stats(\n    vectors,\n    raster,\n    layer=0,\n    band_num=1,\n    nodata=None,\n    affine=None,\n    stats=None,\n    all_touched=False,\n    categorical=False,\n    category_map=None,\n    add_stats=None,\n    raster_out=False,\n    prefix=None,\n    geojson_out=False,\n    gdf_out=False,\n    dst_crs=None,\n    open_vector_args={},\n    open_raster_args={},\n    **kwargs,\n):\n    \"\"\"This function wraps rasterstats.zonal_stats and performs reprojection if necessary.\n        See https://pythonhosted.org/rasterstats/rasterstats.html.\n\n    Args:\n        vectors (str | list | GeoDataFrame): path to an vector source or geo-like python objects.\n        raster (str | ndarray): ndarray or path to a GDAL raster source.\n        layer (int, optional): If vectors is a path to an fiona source, specify the vector layer to\n            use either by name or number. Defaults to 0\n        band_num (int | str, optional): If raster is a GDAL source, the band number to use (counting from 1). defaults to 1.\n        nodata (float, optional): If raster is a GDAL source, this value overrides any NODATA value\n            specified in the file\u2019s metadata. If None, the file\u2019s metadata\u2019s NODATA value (if any)\n            will be used. defaults to None.\n        affine (Affine, optional): required only for ndarrays, otherwise it is read from src. Defaults to None.\n        stats (str | list, optional): Which statistics to calculate for each zone.\n            It can be ['min', 'max', 'mean', 'count']. For more, see https://pythonhosted.org/rasterstats/manual.html#zonal-statistics\n            Defaults to None.\n        all_touched (bool, optional): Whether to include every raster cell touched by a geometry, or only those having\n            a center point within the polygon. defaults to False\n        categorical (bool, optional): If True, the raster values will be treated as categorical.\n        category_map (dict, optional):A dictionary mapping raster values to human-readable categorical names.\n            Only applies when categorical is True\n        add_stats (dict, optional): with names and functions of additional stats to compute. Defaults to None.\n        raster_out (bool, optional): Include the masked numpy array for each feature?. Defaults to False.\n        prefix (str, optional): add a prefix to the keys. Defaults to None.\n        geojson_out (bool, optional): Return list of GeoJSON-like features (default: False)\n            Original feature geometry and properties will be retained with zonal stats\n            appended as additional properties. Use with prefix to ensure unique and\n            meaningful property names.. Defaults to False.\n        gdf_out (bool, optional): Return a GeoDataFrame. Defaults to False.\n        dst_crs (str, optional): The destination CRS. Defaults to None.\n        open_vector_args (dict, optional): Pass additional arguments to geopandas.open_file(). Defaults to {}.\n        open_raster_args (dict, optional): Pass additional arguments to rasterio.open(). Defaults to {}.\n\n    Returns:\n        dict | list | GeoDataFrame: The zonal statistics results\n    \"\"\"\n\n    import geopandas as gpd\n    import rasterio\n\n    try:\n        import rasterstats\n    except ImportError:\n        raise ImportError(\n            \"rasterstats is not installed. Install it with pip install rasterstats\"\n        )\n    try:\n        if isinstance(raster, str):\n            with rasterio.open(raster, **open_raster_args) as src:\n                affine = src.transform\n                nodata = src.nodata\n                array = src.read(band_num, masked=True)\n                raster_crs = src.crs\n        elif isinstance(raster, rasterio.io.DatasetReader):\n            affine = raster.transform\n            nodata = raster.nodata\n            array = raster.read(band_num, masked=True)\n            raster_crs = raster.crs\n        else:\n            array = raster\n\n        if isinstance(vectors, str):\n            gdf = gpd.read_file(vectors, **open_vector_args)\n        elif isinstance(vectors, list):\n            gdf = gpd.GeoDataFrame.from_features(vectors)\n        else:\n            gdf = vectors\n\n        vector_crs = gdf.crs\n\n        if gdf.crs.is_geographic:\n            if not raster_crs.is_geographic:\n                gdf = gdf.to_crs(raster_crs)\n        elif gdf.crs != raster_crs:\n            if not raster_crs.is_geographic:\n                gdf = gdf.to_crs(raster_crs)\n            else:\n                raise ValueError(\"The vector and raster CRSs are not compatible\")\n\n        if gdf_out is True:\n            geojson_out = True\n\n        result = rasterstats.zonal_stats(\n            gdf,\n            array,\n            layer=layer,\n            band_num=band_num,\n            nodata=nodata,\n            affine=affine,\n            stats=stats,\n            all_touched=all_touched,\n            categorical=categorical,\n            category_map=category_map,\n            add_stats=add_stats,\n            raster_out=raster_out,\n            prefix=prefix,\n            geojson_out=geojson_out,\n            **kwargs,\n        )\n\n        if gdf_out is True:\n            if dst_crs is None:\n                dst_crs = vector_crs\n\n            out_gdf = gpd.GeoDataFrame.from_features(result)\n            out_gdf.crs = raster_crs\n            return out_gdf.to_crs(dst_crs)\n        else:\n            return result\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#geojp.common.zoom_level_resolution","title":"<code>zoom_level_resolution(zoom, latitude=0)</code>","text":"<p>Returns the approximate pixel scale based on zoom level and latutude.     See https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>int</code> <p>The zoom level.</p> required <code>latitude</code> <code>float</code> <p>The latitude. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>float</code> <p>Map resolution in meters.</p> Source code in <code>geojp/common.py</code> <pre><code>def zoom_level_resolution(zoom, latitude=0):\n    \"\"\"Returns the approximate pixel scale based on zoom level and latutude.\n        See https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution\n\n    Args:\n        zoom (int): The zoom level.\n        latitude (float, optional): The latitude. Defaults to 0.\n\n    Returns:\n        float: Map resolution in meters.\n    \"\"\"\n    import math\n\n    resolution = 156543.04 * math.cos(latitude) / math.pow(2, zoom)\n    return abs(resolution)\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/BrycenHarris/geojp/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geojp could always use more documentation, whether as part of the official geojp docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/BrycenHarris/geojp/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geojp for local development.</p> <ol> <li> <p>Fork the geojp repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geojp.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geojp\n$ cd geojp/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geojp tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/BrycenHarris/geojp/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"geojp/","title":"geojp module","text":"<p>Main module.</p>"},{"location":"geojp/#geojp.geojp.Map","title":"<code> Map            (Map)         </code>","text":"<p>This is the map class that inherits from ipyleaflet.Map.</p> <p>Parameters:</p> Name Type Description Default <code>ipyleaflet</code> <code>Map</code> <p>The ipyleaflet.Map class.</p> required Source code in <code>geojp/geojp.py</code> <pre><code>class Map(ipyleaflet.Map):\n    \"\"\"This is the map class that inherits from ipyleaflet.Map.\n\n    Args:\n        ipyleaflet (Map): The ipyleaflet.Map class.\n    \"\"\"\n\n    def __init__(self, center=[20, 0], zoom=2, **kwargs):\n        \"\"\"Initialize the map.\n\n        Args:\n            center (list, optional): Set the center of the map. Defaults to [20, 0].\n            zoom (int, optional): Set the zoom level of the map. Defaults to 2.\n        \"\"\"\n        self.split_control=None\n\n        if \"basemap\" in kwargs:\n                    if isinstance(kwargs[\"basemap\"], str):\n                        kwargs[\"basemap\"] = get_basemap(kwargs[\"basemap\"])\n\n        if \"scroll_wheel_zoom\" not in kwargs:\n            kwargs[\"scroll_wheel_zoom\"] = True\n\n        if \"add_layer_control\" not in kwargs:\n            layer_control_flag = True\n\n\n\n\n        else:\n            layer_control_flag = kwargs[\"add_layer_control\"]\n        kwargs.pop(\"add_layer_control\", None)\n\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        if layer_control_flag:\n            self.add_layers_control()\n\n    def add_tile_layer(self, url, name, **kwargs):\n        layer = ipyleaflet.TileLayer(url=url, name=name, **kwargs)\n        self.add(layer)\n\n    def add_basemap(self, name):\n        \"\"\"\n        Adds a basemap to the current map.\n\n        Args:\n            name (str or object): The name of the basemap as a string, or an object representing the basemap.\n\n        Raises:\n            TypeError: If the name is neither a string nor an object representing a basemap.\n\n        Returns:\n            None\n        \"\"\"\n        if isinstance(name, str):\n            url = eval(f\"basemaps.{name}\").build_url()\n            self.add_tile_layer(url, name)\n        else:\n            self.add(name)\n\n    def add_layers_control(self, position=\"topright\"):\n        \"\"\"Adds a layers control to the map.\n\n        Args:\n            position (str, optional): The position of the layers control. Defaults to \"topright\".\n        \"\"\"\n        self.add_control(ipyleaflet.LayersControl(position=position))\n\n    def add_geojson(self, data, name=\"geojson\", **kwargs):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str | dict): The GeoJSON data as a string or a dictionary.\n            name (str, optional): The name of the layer. Defaults to \"geojson\".\n        \"\"\"\n        import json\n\n        if isinstance(data, str):\n            with open(data) as f:\n                data = json.load(f)\n\n        if \"style\" not in kwargs:\n            kwargs[\"style\"] = {\"color\": \"blue\", \"weight\": 1, \"fillOpacity\": 0}\n\n        if \"hover_style\" not in kwargs:\n            kwargs[\"hover_style\"] = {\"fillColor\": \"#ff0000\", \"fillOpacity\": 0.5}\n\n        layer = ipyleaflet.GeoJSON(data=data, name=name, **kwargs)\n        self.add(layer)\n\n    def add_shp(self, data, name=\"shp\", **kwargs):\n        \"\"\"\n        Adds a shapefile to the current map.\n\n        Args:\n            data (str or dict): The path to the shapefile as a string, or a dictionary representing the shapefile.\n            name (str, optional): The name of the layer. Defaults to \"shp\".\n            **kwargs: Arbitrary keyword arguments.\n\n        Raises:\n            TypeError: If the data is neither a string nor a dictionary representing a shapefile.\n\n        Returns:\n            None\n        \"\"\"\n        import shapefile\n        import json\n\n        if isinstance(data, str):\n            with shapefile.Reader(data) as shp:\n                data = shp.__geo_interface__\n\n        self.add_geojson(data, name, **kwargs)\n\n    def add_image(self, url, bounds, name=\"image\", **kwargs):\n        \"\"\"Adds an image overlay to the map.\n\n        Args:\n            url (str): The URL of the image.\n            bounds (list): The bounds of the image.\n            name (str, optional): The name of the layer. Defaults to \"image\".\n        \"\"\"\n        layer = ipyleaflet.ImageOverlay(url=url, bounds=bounds, name=name, **kwargs)\n        self.add(layer)\n\n    def add_raster(self, data, name=\"raster\", zoom_to_layer=True, **kwargs):\n        \"\"\"Adds a raster layer to the map.\n\n        Args:\n            data (str): The path to the raster file.\n            name (str, optional): The name of the layer. Defaults to \"raster\".\n        \"\"\"\n\n        try:\n            from localtileserver import TileClient, get_leaflet_tile_layer\n        except ImportError:\n            raise ImportError(\"Please install the localtileserver package.\")\n\n        client = TileClient(data)\n        layer = get_leaflet_tile_layer(client, name=name, **kwargs)\n        self.add(layer)\n\n        if zoom_to_layer:\n            self.center = client.center()\n            self.zoom = client.default_zoom\n\n    def add_vector(self, data, layer_name):\n\n        import geopandas as gpd\n        from ipyleaflet import GeoData\n\n        if isinstance(data, gpd.GeoDataFrame):\n            vector_layer = GeoData(geo_dataframe=data)\n\n        elif isinstance(data, str):\n            vector_layer = GeoData(geo_dataframe=gpd.read_file(data))\n\n        else:\n            raise ValueError(\"Unsupported data format. Please provide a GeoDataFrame or a file path.\")\n\n        self.add_layer(vector_layer, layer_name)\n\n    def add_zoom_slider(\n        self, description=\"Zoom level\", min=0, max=24, value=10, position=\"topright\"\n    ):\n        \"\"\"Adds a zoom slider to the map.\n\n        Args:\n            position (str, optional): The position of the zoom slider. Defaults to \"topright\".\n        \"\"\"\n        zoom_slider = widgets.IntSlider(\n            description=description, min=min, max=max, value=value\n        )\n\n        control = ipyleaflet.WidgetControl(widget=zoom_slider, position=position)\n        self.add(control)\n        widgets.jslink((zoom_slider, \"value\"), (self, \"zoom\"))\n\n    def add_widget(self, widget, position=\"topright\"):\n        \"\"\"Adds a widget to the map.\n\n        Args:\n            widget (object): The widget to be added.\n            position (str, optional): The position of the widget. Defaults to \"topright\".\n        \"\"\"\n        control = ipyleaflet.WidgetControl(widget=widget, position=position)\n        self.add(control)\n\n    def add_opacity_slider(\n        self, layer_index=-1, description=\"Opacity\", position=\"topright\"\n    ):\n        \"\"\"Adds an opacity slider to the map.\n\n        Args:\n            layer (object): The layer to which the opacity slider is added.\n            description (str, optional): The description of the opacity slider. Defaults to \"Opacity\".\n            position (str, optional): The position of the opacity slider. Defaults to \"topright\".\n        \"\"\"\n        layer = self.layers[layer_index]\n        opacity_slider = widgets.FloatSlider(\n            description=description,\n            min=0,\n            max=1,\n            value=layer.opacity,\n            style={\"description_width\": \"initial\"},\n        )\n\n        def update_opacity(change):\n            layer.opacity = change[\"new\"]\n\n        opacity_slider.observe(update_opacity, \"value\")\n\n        control = ipyleaflet.WidgetControl(widget=opacity_slider, position=position)\n        self.add(control)\n\n    def add_basemap_gui(self, basemaps=None, position=\"topright\"):\n        \"\"\"Adds a basemap GUI to the map.\n\n        Args:\n            position (str, optional): The position of the basemap GUI. Defaults to \"topright\".\n        \"\"\"\n\n        basemap_selector = widgets.Dropdown(\n            options=[\n                \"OpenStreetMap\",\n                \"OpenTopoMap\",\n                \"Esri.WorldImagery\",\n                \"Esri.NatGeoWorldMap\",\n                \"CartoDB.DarkMatter\",\n            ],\n            description=\"Basemap\",\n        )\n\n        def update_basemap(change):\n            self.add_basemap(change[\"new\"])\n\n        basemap_selector.observe(update_basemap, \"value\")\n\n        control = ipyleaflet.WidgetControl(widget=basemap_selector, position=position)\n        self.add(control)\n\n    def add_toolbar(self, position=\"topright\"):\n        \"\"\"Adds a toolbar to the map.\n\n        Args:\n            position (str, optional): The position of the toolbar. Defaults to \"topright\".\n        \"\"\"\n\n        padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n\n        toolbar_button = widgets.ToggleButton(\n            value=False,\n            tooltip=\"Toolbar\",\n            icon=\"wrench\",\n            layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=padding),\n        )\n\n        close_button = widgets.ToggleButton(\n            value=False,\n            tooltip=\"Close the tool\",\n            icon=\"times\",\n            button_style=\"primary\",\n            layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=padding),\n        )\n\n        toolbar = widgets.VBox([toolbar_button])\n\n        def close_click(change):\n            if change[\"new\"]:\n                toolbar_button.close()\n                close_button.close()\n                toolbar.close()\n\n        close_button.observe(close_click, \"value\")\n\n        rows = 2\n        cols = 2\n        grid = widgets.GridspecLayout(\n            rows, cols, grid_gap=\"0px\", layout=widgets.Layout(width=\"65px\")\n        )\n\n        icons = [\"folder-open\", \"map\", \"info\", \"question\"]\n\n        for i in range(rows):\n            for j in range(cols):\n                grid[i, j] = widgets.Button(\n                    description=\"\",\n                    button_style=\"primary\",\n                    icon=icons[i * rows + j],\n                    layout=widgets.Layout(width=\"28px\", padding=\"0px\"),\n                )\n\n        def toolbar_click(change):\n            if change[\"new\"]:\n                toolbar.children = [widgets.HBox([close_button, toolbar_button]), grid]\n            else:\n                toolbar.children = [toolbar_button]\n\n        toolbar_button.observe(toolbar_click, \"value\")\n        toolbar_ctrl = WidgetControl(widget=toolbar, position=\"topright\")\n        self.add(toolbar_ctrl)\n\n        output = widgets.Output()\n        output_control = WidgetControl(widget=output, position=\"bottomright\")\n        self.add(output_control)\n\n        def toolbar_callback(change):\n            if change.icon == \"folder-open\":\n                with output:\n                    output.clear_output()\n                    print(f\"You can open a file\")\n            elif change.icon == \"map\":\n                with output:\n                    output.clear_output()\n                    print(f\"You can add a layer\")\n            else:\n                with output:\n                    output.clear_output()\n                    print(f\"Icon: {change.icon}\")\n\n        for tool in grid.children:\n            tool.on_click(toolbar_callback)    \n\n    '''def split_map(\n        left_layer=\"TERRAIN\",\n        right_layer=\"OpenTopoMap\",\n        #left_args={},\n       # right_args={},\n        **kwargs,\n    ):\n\n        pass'''\n\n    def add_time_slider(\n            self,\n            layers={},\n            labels=None,\n            time_interval=1,\n            position=\"bottomright\",\n            slider_length=\"150px\",\n            zoom_to_layer=False,\n            **kwargs,\n        ):\n            \"\"\"Adds a time slider to the map.\n\n            Args:\n                layers (dict, optional): The dictionary containing a set of XYZ tile layers.\n                labels (list, optional): The list of labels to be used for the time series. Defaults to None.\n                time_interval (int, optional): Time interval in seconds. Defaults to 1.\n                position (str, optional): Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".\n                slider_length (str, optional): Length of the time slider. Defaults to \"150px\".\n                zoom_to_layer (bool, optional): Whether to zoom to the extent of the selected layer. Defaults to False.\n\n            \"\"\"\n            from .toolbar import time_slider\n\n            time_slider(\n                self,\n                layers,\n                labels,\n                time_interval,\n                position,\n                slider_length,\n                zoom_to_layer,\n                **kwargs,\n            )\n\n    def zoom_to_bounds(self, bounds):\n        \"\"\"Zooms to a bounding box in the form of [minx, miny, maxx, maxy].\n\n        Args:\n            bounds (list | tuple): A list/tuple containing minx, miny, maxx, maxy values for the bounds.\n        \"\"\"\n        #  The ipyleaflet fit_bounds method takes lat/lon bounds in the form [[south, west], [north, east]].\n        self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n\n    def add_heatmap(\n        self,\n        data,\n        latitude=\"latitude\",\n        longitude=\"longitude\",\n        value=\"value\",\n        name=\"Heat map\",\n        radius=25,\n        **kwargs,\n    ):\n        \"\"\"Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html\n\n        Args:\n            data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n            latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n            longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n            value (str, optional): The column name of values. Defaults to \"value\".\n            name (str, optional): Layer name to use. Defaults to \"Heat map\".\n            radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n        Raises:\n            ValueError: If data is not a list.\n        \"\"\"\n        import pandas as pd\n        from ipyleaflet import Heatmap\n\n        try:\n            if isinstance(data, str):\n                df = pd.read_csv(data)\n                data = df[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, pd.DataFrame):\n                data = data[[latitude, longitude, value]].values.tolist()\n            elif isinstance(data, list):\n                pass\n            else:\n                raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n            heatmap = Heatmap(locations=data, radius=radius, name=name, **kwargs)\n            self.add(heatmap)\n\n        except Exception as e:\n            raise Exception(e)\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.__init__","title":"<code>__init__(self, center=[20, 0], zoom=2, **kwargs)</code>  <code>special</code>","text":"<p>Initialize the map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>list</code> <p>Set the center of the map. Defaults to [20, 0].</p> <code>[20, 0]</code> <code>zoom</code> <code>int</code> <p>Set the zoom level of the map. Defaults to 2.</p> <code>2</code> Source code in <code>geojp/geojp.py</code> <pre><code>def __init__(self, center=[20, 0], zoom=2, **kwargs):\n    \"\"\"Initialize the map.\n\n    Args:\n        center (list, optional): Set the center of the map. Defaults to [20, 0].\n        zoom (int, optional): Set the zoom level of the map. Defaults to 2.\n    \"\"\"\n    self.split_control=None\n\n    if \"basemap\" in kwargs:\n                if isinstance(kwargs[\"basemap\"], str):\n                    kwargs[\"basemap\"] = get_basemap(kwargs[\"basemap\"])\n\n    if \"scroll_wheel_zoom\" not in kwargs:\n        kwargs[\"scroll_wheel_zoom\"] = True\n\n    if \"add_layer_control\" not in kwargs:\n        layer_control_flag = True\n\n\n\n\n    else:\n        layer_control_flag = kwargs[\"add_layer_control\"]\n    kwargs.pop(\"add_layer_control\", None)\n\n    super().__init__(center=center, zoom=zoom, **kwargs)\n    if layer_control_flag:\n        self.add_layers_control()\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_basemap","title":"<code>add_basemap(self, name)</code>","text":"<p>Adds a basemap to the current map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or object</code> <p>The name of the basemap as a string, or an object representing the basemap.</p> required <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the name is neither a string nor an object representing a basemap.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>geojp/geojp.py</code> <pre><code>def add_basemap(self, name):\n    \"\"\"\n    Adds a basemap to the current map.\n\n    Args:\n        name (str or object): The name of the basemap as a string, or an object representing the basemap.\n\n    Raises:\n        TypeError: If the name is neither a string nor an object representing a basemap.\n\n    Returns:\n        None\n    \"\"\"\n    if isinstance(name, str):\n        url = eval(f\"basemaps.{name}\").build_url()\n        self.add_tile_layer(url, name)\n    else:\n        self.add(name)\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_basemap_gui","title":"<code>add_basemap_gui(self, basemaps=None, position='topright')</code>","text":"<p>Adds a basemap GUI to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the basemap GUI. Defaults to \"topright\".</p> <code>'topright'</code> Source code in <code>geojp/geojp.py</code> <pre><code>def add_basemap_gui(self, basemaps=None, position=\"topright\"):\n    \"\"\"Adds a basemap GUI to the map.\n\n    Args:\n        position (str, optional): The position of the basemap GUI. Defaults to \"topright\".\n    \"\"\"\n\n    basemap_selector = widgets.Dropdown(\n        options=[\n            \"OpenStreetMap\",\n            \"OpenTopoMap\",\n            \"Esri.WorldImagery\",\n            \"Esri.NatGeoWorldMap\",\n            \"CartoDB.DarkMatter\",\n        ],\n        description=\"Basemap\",\n    )\n\n    def update_basemap(change):\n        self.add_basemap(change[\"new\"])\n\n    basemap_selector.observe(update_basemap, \"value\")\n\n    control = ipyleaflet.WidgetControl(widget=basemap_selector, position=position)\n    self.add(control)\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_geojson","title":"<code>add_geojson(self, data, name='geojson', **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | dict</code> <p>The GeoJSON data as a string or a dictionary.</p> required <code>name</code> <code>str</code> <p>The name of the layer. Defaults to \"geojson\".</p> <code>'geojson'</code> Source code in <code>geojp/geojp.py</code> <pre><code>def add_geojson(self, data, name=\"geojson\", **kwargs):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str | dict): The GeoJSON data as a string or a dictionary.\n        name (str, optional): The name of the layer. Defaults to \"geojson\".\n    \"\"\"\n    import json\n\n    if isinstance(data, str):\n        with open(data) as f:\n            data = json.load(f)\n\n    if \"style\" not in kwargs:\n        kwargs[\"style\"] = {\"color\": \"blue\", \"weight\": 1, \"fillOpacity\": 0}\n\n    if \"hover_style\" not in kwargs:\n        kwargs[\"hover_style\"] = {\"fillColor\": \"#ff0000\", \"fillOpacity\": 0.5}\n\n    layer = ipyleaflet.GeoJSON(data=data, name=name, **kwargs)\n    self.add(layer)\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_heatmap","title":"<code>add_heatmap(self, data, latitude='latitude', longitude='longitude', value='value', name='Heat map', radius=25, **kwargs)</code>","text":"<p>Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | list | pd.DataFrame</code> <p>File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv</p> required <code>latitude</code> <code>str</code> <p>The column name of latitude. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>longitude</code> <code>str</code> <p>The column name of longitude. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>value</code> <code>str</code> <p>The column name of values. Defaults to \"value\".</p> <code>'value'</code> <code>name</code> <code>str</code> <p>Layer name to use. Defaults to \"Heat map\".</p> <code>'Heat map'</code> <code>radius</code> <code>int</code> <p>Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.</p> <code>25</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data is not a list.</p> Source code in <code>geojp/geojp.py</code> <pre><code>def add_heatmap(\n    self,\n    data,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"value\",\n    name=\"Heat map\",\n    radius=25,\n    **kwargs,\n):\n    \"\"\"Adds a heat map to the map. Reference: https://ipyleaflet.readthedocs.io/en/latest/api_reference/heatmap.html\n\n    Args:\n        data (str | list | pd.DataFrame): File path or HTTP URL to the input file or a list of data points in the format of [[x1, y1, z1], [x2, y2, z2]]. For example, https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/world_cities.csv\n        latitude (str, optional): The column name of latitude. Defaults to \"latitude\".\n        longitude (str, optional): The column name of longitude. Defaults to \"longitude\".\n        value (str, optional): The column name of values. Defaults to \"value\".\n        name (str, optional): Layer name to use. Defaults to \"Heat map\".\n        radius (int, optional): Radius of each \u201cpoint\u201d of the heatmap. Defaults to 25.\n\n    Raises:\n        ValueError: If data is not a list.\n    \"\"\"\n    import pandas as pd\n    from ipyleaflet import Heatmap\n\n    try:\n        if isinstance(data, str):\n            df = pd.read_csv(data)\n            data = df[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, pd.DataFrame):\n            data = data[[latitude, longitude, value]].values.tolist()\n        elif isinstance(data, list):\n            pass\n        else:\n            raise ValueError(\"data must be a list, a DataFrame, or a file path.\")\n\n        heatmap = Heatmap(locations=data, radius=radius, name=name, **kwargs)\n        self.add(heatmap)\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_image","title":"<code>add_image(self, url, bounds, name='image', **kwargs)</code>","text":"<p>Adds an image overlay to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the image.</p> required <code>bounds</code> <code>list</code> <p>The bounds of the image.</p> required <code>name</code> <code>str</code> <p>The name of the layer. Defaults to \"image\".</p> <code>'image'</code> Source code in <code>geojp/geojp.py</code> <pre><code>def add_image(self, url, bounds, name=\"image\", **kwargs):\n    \"\"\"Adds an image overlay to the map.\n\n    Args:\n        url (str): The URL of the image.\n        bounds (list): The bounds of the image.\n        name (str, optional): The name of the layer. Defaults to \"image\".\n    \"\"\"\n    layer = ipyleaflet.ImageOverlay(url=url, bounds=bounds, name=name, **kwargs)\n    self.add(layer)\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_layers_control","title":"<code>add_layers_control(self, position='topright')</code>","text":"<p>Adds a layers control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the layers control. Defaults to \"topright\".</p> <code>'topright'</code> Source code in <code>geojp/geojp.py</code> <pre><code>def add_layers_control(self, position=\"topright\"):\n    \"\"\"Adds a layers control to the map.\n\n    Args:\n        position (str, optional): The position of the layers control. Defaults to \"topright\".\n    \"\"\"\n    self.add_control(ipyleaflet.LayersControl(position=position))\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_opacity_slider","title":"<code>add_opacity_slider(self, layer_index=-1, description='Opacity', position='topright')</code>","text":"<p>Adds an opacity slider to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>object</code> <p>The layer to which the opacity slider is added.</p> required <code>description</code> <code>str</code> <p>The description of the opacity slider. Defaults to \"Opacity\".</p> <code>'Opacity'</code> <code>position</code> <code>str</code> <p>The position of the opacity slider. Defaults to \"topright\".</p> <code>'topright'</code> Source code in <code>geojp/geojp.py</code> <pre><code>def add_opacity_slider(\n    self, layer_index=-1, description=\"Opacity\", position=\"topright\"\n):\n    \"\"\"Adds an opacity slider to the map.\n\n    Args:\n        layer (object): The layer to which the opacity slider is added.\n        description (str, optional): The description of the opacity slider. Defaults to \"Opacity\".\n        position (str, optional): The position of the opacity slider. Defaults to \"topright\".\n    \"\"\"\n    layer = self.layers[layer_index]\n    opacity_slider = widgets.FloatSlider(\n        description=description,\n        min=0,\n        max=1,\n        value=layer.opacity,\n        style={\"description_width\": \"initial\"},\n    )\n\n    def update_opacity(change):\n        layer.opacity = change[\"new\"]\n\n    opacity_slider.observe(update_opacity, \"value\")\n\n    control = ipyleaflet.WidgetControl(widget=opacity_slider, position=position)\n    self.add(control)\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_raster","title":"<code>add_raster(self, data, name='raster', zoom_to_layer=True, **kwargs)</code>","text":"<p>Adds a raster layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The path to the raster file.</p> required <code>name</code> <code>str</code> <p>The name of the layer. Defaults to \"raster\".</p> <code>'raster'</code> Source code in <code>geojp/geojp.py</code> <pre><code>def add_raster(self, data, name=\"raster\", zoom_to_layer=True, **kwargs):\n    \"\"\"Adds a raster layer to the map.\n\n    Args:\n        data (str): The path to the raster file.\n        name (str, optional): The name of the layer. Defaults to \"raster\".\n    \"\"\"\n\n    try:\n        from localtileserver import TileClient, get_leaflet_tile_layer\n    except ImportError:\n        raise ImportError(\"Please install the localtileserver package.\")\n\n    client = TileClient(data)\n    layer = get_leaflet_tile_layer(client, name=name, **kwargs)\n    self.add(layer)\n\n    if zoom_to_layer:\n        self.center = client.center()\n        self.zoom = client.default_zoom\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_shp","title":"<code>add_shp(self, data, name='shp', **kwargs)</code>","text":"<p>Adds a shapefile to the current map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The path to the shapefile as a string, or a dictionary representing the shapefile.</p> required <code>name</code> <code>str</code> <p>The name of the layer. Defaults to \"shp\".</p> <code>'shp'</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the data is neither a string nor a dictionary representing a shapefile.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>geojp/geojp.py</code> <pre><code>def add_shp(self, data, name=\"shp\", **kwargs):\n    \"\"\"\n    Adds a shapefile to the current map.\n\n    Args:\n        data (str or dict): The path to the shapefile as a string, or a dictionary representing the shapefile.\n        name (str, optional): The name of the layer. Defaults to \"shp\".\n        **kwargs: Arbitrary keyword arguments.\n\n    Raises:\n        TypeError: If the data is neither a string nor a dictionary representing a shapefile.\n\n    Returns:\n        None\n    \"\"\"\n    import shapefile\n    import json\n\n    if isinstance(data, str):\n        with shapefile.Reader(data) as shp:\n            data = shp.__geo_interface__\n\n    self.add_geojson(data, name, **kwargs)\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_time_slider","title":"<code>add_time_slider(self, layers={}, labels=None, time_interval=1, position='bottomright', slider_length='150px', zoom_to_layer=False, **kwargs)</code>","text":"<p>Adds a time slider to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>dict</code> <p>The dictionary containing a set of XYZ tile layers.</p> <code>{}</code> <code>labels</code> <code>list</code> <p>The list of labels to be used for the time series. Defaults to None.</p> <code>None</code> <code>time_interval</code> <code>int</code> <p>Time interval in seconds. Defaults to 1.</p> <code>1</code> <code>position</code> <code>str</code> <p>Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".</p> <code>'bottomright'</code> <code>slider_length</code> <code>str</code> <p>Length of the time slider. Defaults to \"150px\".</p> <code>'150px'</code> <code>zoom_to_layer</code> <code>bool</code> <p>Whether to zoom to the extent of the selected layer. Defaults to False.</p> <code>False</code> Source code in <code>geojp/geojp.py</code> <pre><code>def add_time_slider(\n        self,\n        layers={},\n        labels=None,\n        time_interval=1,\n        position=\"bottomright\",\n        slider_length=\"150px\",\n        zoom_to_layer=False,\n        **kwargs,\n    ):\n        \"\"\"Adds a time slider to the map.\n\n        Args:\n            layers (dict, optional): The dictionary containing a set of XYZ tile layers.\n            labels (list, optional): The list of labels to be used for the time series. Defaults to None.\n            time_interval (int, optional): Time interval in seconds. Defaults to 1.\n            position (str, optional): Position to place the time slider, can be any of ['topleft', 'topright', 'bottomleft', 'bottomright']. Defaults to \"bottomright\".\n            slider_length (str, optional): Length of the time slider. Defaults to \"150px\".\n            zoom_to_layer (bool, optional): Whether to zoom to the extent of the selected layer. Defaults to False.\n\n        \"\"\"\n        from .toolbar import time_slider\n\n        time_slider(\n            self,\n            layers,\n            labels,\n            time_interval,\n            position,\n            slider_length,\n            zoom_to_layer,\n            **kwargs,\n        )\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_toolbar","title":"<code>add_toolbar(self, position='topright')</code>","text":"<p>Adds a toolbar to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the toolbar. Defaults to \"topright\".</p> <code>'topright'</code> Source code in <code>geojp/geojp.py</code> <pre><code>def add_toolbar(self, position=\"topright\"):\n    \"\"\"Adds a toolbar to the map.\n\n    Args:\n        position (str, optional): The position of the toolbar. Defaults to \"topright\".\n    \"\"\"\n\n    padding = \"0px 0px 0px 5px\"  # upper, right, bottom, left\n\n    toolbar_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Toolbar\",\n        icon=\"wrench\",\n        layout=widgets.Layout(width=\"28px\", height=\"28px\", padding=padding),\n    )\n\n    close_button = widgets.ToggleButton(\n        value=False,\n        tooltip=\"Close the tool\",\n        icon=\"times\",\n        button_style=\"primary\",\n        layout=widgets.Layout(height=\"28px\", width=\"28px\", padding=padding),\n    )\n\n    toolbar = widgets.VBox([toolbar_button])\n\n    def close_click(change):\n        if change[\"new\"]:\n            toolbar_button.close()\n            close_button.close()\n            toolbar.close()\n\n    close_button.observe(close_click, \"value\")\n\n    rows = 2\n    cols = 2\n    grid = widgets.GridspecLayout(\n        rows, cols, grid_gap=\"0px\", layout=widgets.Layout(width=\"65px\")\n    )\n\n    icons = [\"folder-open\", \"map\", \"info\", \"question\"]\n\n    for i in range(rows):\n        for j in range(cols):\n            grid[i, j] = widgets.Button(\n                description=\"\",\n                button_style=\"primary\",\n                icon=icons[i * rows + j],\n                layout=widgets.Layout(width=\"28px\", padding=\"0px\"),\n            )\n\n    def toolbar_click(change):\n        if change[\"new\"]:\n            toolbar.children = [widgets.HBox([close_button, toolbar_button]), grid]\n        else:\n            toolbar.children = [toolbar_button]\n\n    toolbar_button.observe(toolbar_click, \"value\")\n    toolbar_ctrl = WidgetControl(widget=toolbar, position=\"topright\")\n    self.add(toolbar_ctrl)\n\n    output = widgets.Output()\n    output_control = WidgetControl(widget=output, position=\"bottomright\")\n    self.add(output_control)\n\n    def toolbar_callback(change):\n        if change.icon == \"folder-open\":\n            with output:\n                output.clear_output()\n                print(f\"You can open a file\")\n        elif change.icon == \"map\":\n            with output:\n                output.clear_output()\n                print(f\"You can add a layer\")\n        else:\n            with output:\n                output.clear_output()\n                print(f\"Icon: {change.icon}\")\n\n    for tool in grid.children:\n        tool.on_click(toolbar_callback)    \n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_widget","title":"<code>add_widget(self, widget, position='topright')</code>","text":"<p>Adds a widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>object</code> <p>The widget to be added.</p> required <code>position</code> <code>str</code> <p>The position of the widget. Defaults to \"topright\".</p> <code>'topright'</code> Source code in <code>geojp/geojp.py</code> <pre><code>def add_widget(self, widget, position=\"topright\"):\n    \"\"\"Adds a widget to the map.\n\n    Args:\n        widget (object): The widget to be added.\n        position (str, optional): The position of the widget. Defaults to \"topright\".\n    \"\"\"\n    control = ipyleaflet.WidgetControl(widget=widget, position=position)\n    self.add(control)\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.add_zoom_slider","title":"<code>add_zoom_slider(self, description='Zoom level', min=0, max=24, value=10, position='topright')</code>","text":"<p>Adds a zoom slider to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the zoom slider. Defaults to \"topright\".</p> <code>'topright'</code> Source code in <code>geojp/geojp.py</code> <pre><code>def add_zoom_slider(\n    self, description=\"Zoom level\", min=0, max=24, value=10, position=\"topright\"\n):\n    \"\"\"Adds a zoom slider to the map.\n\n    Args:\n        position (str, optional): The position of the zoom slider. Defaults to \"topright\".\n    \"\"\"\n    zoom_slider = widgets.IntSlider(\n        description=description, min=min, max=max, value=value\n    )\n\n    control = ipyleaflet.WidgetControl(widget=zoom_slider, position=position)\n    self.add(control)\n    widgets.jslink((zoom_slider, \"value\"), (self, \"zoom\"))\n</code></pre>"},{"location":"geojp/#geojp.geojp.Map.zoom_to_bounds","title":"<code>zoom_to_bounds(self, bounds)</code>","text":"<p>Zooms to a bounding box in the form of [minx, miny, maxx, maxy].</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>list | tuple</code> <p>A list/tuple containing minx, miny, maxx, maxy values for the bounds.</p> required Source code in <code>geojp/geojp.py</code> <pre><code>def zoom_to_bounds(self, bounds):\n    \"\"\"Zooms to a bounding box in the form of [minx, miny, maxx, maxy].\n\n    Args:\n        bounds (list | tuple): A list/tuple containing minx, miny, maxx, maxy values for the bounds.\n    \"\"\"\n    #  The ipyleaflet fit_bounds method takes lat/lon bounds in the form [[south, west], [north, east]].\n    self.fit_bounds([[bounds[1], bounds[0]], [bounds[3], bounds[2]]])\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geojp, run this command in your terminal:</p> <pre><code>pip install geojp\n</code></pre> <p>This is the preferred method to install geojp, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geojp from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/BrycenHarris/geojp\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use geojp in a project:</p> <pre><code>import geojp\n</code></pre>"},{"location":"utils/","title":"utils module","text":"<p>This is the utils module that contains utility functions for the geojp package.</p>"},{"location":"utils/#geojp.utils.csv_to_df","title":"<code>csv_to_df(csv_file)</code>","text":"<p>Converts a CSV file to a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>csv_file</code> <code>str</code> <p>The path to the CSV file.</p> required <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>The pandas DataFrame.</p> Source code in <code>geojp/utils.py</code> <pre><code>def csv_to_df(csv_file):\n    \"\"\"Converts a CSV file to a pandas DataFrame.\n\n    Args:\n        csv_file (str): The path to the CSV file.\n\n    Returns:\n        pandas.DataFrame: The pandas DataFrame.\n    \"\"\"\n    import pandas as pd\n\n    return pd.read_csv(csv_file)\n</code></pre>"},{"location":"Notebooks/lab4/","title":"Lab4","text":"In\u00a0[\u00a0]: Copied! <pre>from datetime import datetime\n\nnow = datetime.now()\nprint(f\"Submitted time: {now}\")\n</pre> from datetime import datetime  now = datetime.now() print(f\"Submitted time: {now}\") In\u00a0[97]: Copied! <pre>intro = \"Hello Professor! This is Brycen Harris. I look forward to learning more about code in your class\"\nprint(intro)\n</pre> intro = \"Hello Professor! This is Brycen Harris. I look forward to learning more about code in your class\" print(intro) <pre>Hello Professor! This is Brycen Harris. I look forward to learning more about code in your class\n</pre> In\u00a0[4]: Copied! <pre>UserName = \"Brycen Harris\"\n\nprint(UserName.lower())\n\nprint(UserName.upper())\n\nprint(UserName.title())\n</pre> UserName = \"Brycen Harris\"  print(UserName.lower())  print(UserName.upper())  print(UserName.title()) <pre>brycen harris\nBRYCEN HARRIS\nBrycen Harris\n</pre> In\u00a0[5]: Copied! <pre>quote = \"Mark 16:16 Whoever believes and is baptized will be saved; whoever does not believe will be condemned.\"\n\nauthor = \"Jesus Christ\"\n\nprint(f\"{author} promised in, \\\"{quote}\\\"\")\n</pre> quote = \"Mark 16:16 Whoever believes and is baptized will be saved; whoever does not believe will be condemned.\"  author = \"Jesus Christ\"  print(f\"{author} promised in, \\\"{quote}\\\"\") <pre>Jesus Christ promised in, \"Mark 16:16 Whoever believes and is baptized will be saved; whoever does not believe will be condemned.\"\n</pre> In\u00a0[96]: Copied! <pre>NameWithSpace = \"\\t\\tBrycen Harris\\n\"\n\nprint(NameWithSpace)\n\nprint(NameWithSpace.lstrip())\n\nprint(NameWithSpace.rstrip())\n\nprint(NameWithSpace.strip())\n</pre> NameWithSpace = \"\\t\\tBrycen Harris\\n\"  print(NameWithSpace)  print(NameWithSpace.lstrip())  print(NameWithSpace.rstrip())  print(NameWithSpace.strip()) <pre>\t\tBrycen Harris\n\nBrycen Harris\n\n\t\tBrycen Harris\nBrycen Harris\n</pre> In\u00a0[10]: Copied! <pre>FriendsNames = [\"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]\n\nfor FriendsNames in FriendsNames:\n\n    print (FriendsNames)\n</pre> FriendsNames = [\"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]  for FriendsNames in FriendsNames:      print (FriendsNames) <pre>Ryan\nJake\nTrevor\nRylee\n</pre> In\u00a0[13]: Copied! <pre>vehicle = [\"Ninja 600\", \"3000GT\", \"Jeep Wrangler\"]\n\nfor vehicle in vehicle:\n    \n    print(f\"I would like to own a {vehicle}.\\n\")\n</pre> vehicle = [\"Ninja 600\", \"3000GT\", \"Jeep Wrangler\"]  for vehicle in vehicle:          print(f\"I would like to own a {vehicle}.\\n\") <pre>I would like to own a Ninja 600.\n\nI would like to own a 3000GT.\n\nI would like to own a Jeep Wrangler.\n\n</pre> In\u00a0[19]: Copied! <pre>pizzas = [\"Pepperoni\",\"Meat Lovers\", \"Cheese\"]\n\nprint(\"List of favorite pizzas:\")\n\nfor pizza in pizzas:\n\n    print(pizza)\n\nprint(\"Pizzas I like:\")\n\nfor pizza in pizzas:\n\n    print(\"I like\", pizza, \"pizza.\")\n</pre> pizzas = [\"Pepperoni\",\"Meat Lovers\", \"Cheese\"]  print(\"List of favorite pizzas:\")  for pizza in pizzas:      print(pizza)  print(\"Pizzas I like:\")  for pizza in pizzas:      print(\"I like\", pizza, \"pizza.\") <pre>List of favorite pizzas:\nPepperoni\nMeat Lovers\nCheese\nPizzas I like:\nI like Pepperoni pizza.\nI like Meat Lovers pizza.\nI like Cheese pizza.\n</pre> <p>Add a line at the end of your program, outside the for loop, that states how much you like pizza. The output should consist of three or more lines about the kinds of pizza you like and then an additional sentence, such as I really love pizza!</p> In\u00a0[22]: Copied! <pre>pizzas = [\"Pepperoni\", \"Meat Lovers\", \"Cheese\"]\n\nfor pizza in pizzas:\n    \n    print(f\"I love eating {pizza} pizza.\\n\")\n\nprint(\"I really enjoy eating pizza!\")\n</pre> pizzas = [\"Pepperoni\", \"Meat Lovers\", \"Cheese\"]  for pizza in pizzas:          print(f\"I love eating {pizza} pizza.\\n\")  print(\"I really enjoy eating pizza!\") <pre>I love eating Pepperoni pizza.\n\nI love eating Meat Lovers pizza.\n\nI love eating Cheese pizza.\n\nI really enjoy eating pizza!\n</pre> In\u00a0[52]: Copied! <pre>pets = [\"Dog\", \"Cat\", \"snake\", \"Turtle\"]\n\nprint(\"Type of pets:\")\n\nfor type in pets:\n\n    print(type)\n\nprint (\"\")\n\nprint(\"What would make a good pet:\")\n\nfor type in pets:\n\n    print(f\"A {type} would make a great pet.\")\n</pre> pets = [\"Dog\", \"Cat\", \"snake\", \"Turtle\"]  print(\"Type of pets:\")  for type in pets:      print(type)  print (\"\")  print(\"What would make a good pet:\")  for type in pets:      print(f\"A {type} would make a great pet.\") <pre>Type of pets:\nDog\nCat\nsnake\nTurtle\n\nWhat would make a good pet:\nA Dog would make a great pet.\nA Cat would make a great pet.\nA snake would make a great pet.\nA Turtle would make a great pet.\n</pre> <p>Add a line at the end of your program stating what these animals have in common. You could print a sentence such as Any of these animals would make a great pet!</p> In\u00a0[54]: Copied! <pre>print(\"All of these animals popular options types of pets\")\n</pre> print(\"All of these animals popular options types of pets\") <pre>All of these animals popular options types of pets\n</pre> In\u00a0[73]: Copied! <pre>numbers = list(range(1, 101))\n\n#print(numbers)\n\nprint(\"Minimum number:\", min(numbers))\n\nprint(\"Maximum number:\", max(numbers))\n\nprint(\"Sum of the numbers:\", sum(numbers))\n</pre> numbers = list(range(1, 101))  #print(numbers)  print(\"Minimum number:\", min(numbers))  print(\"Maximum number:\", max(numbers))  print(\"Sum of the numbers:\", sum(numbers))  <pre>Minimum number: 1\nMaximum number: 100\nSum of the numbers: 5050\n</pre> In\u00a0[68]: Copied! <pre>OddNumbers = list(range(1, 21, 2))\n\nOddNumbers\n</pre> OddNumbers = list(range(1, 21, 2))  OddNumbers Out[68]: <pre>[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</pre> In\u00a0[72]: Copied! <pre>multiples = [number for number in range(3, 31, 3)]\n\nprint(\"Here are the multiples of 3 up to 30:\")\n\nfor number in multiples:\n    \n    print(number)\n</pre> multiples = [number for number in range(3, 31, 3)]  print(\"Here are the multiples of 3 up to 30:\")  for number in multiples:          print(number) <pre>Here are the multiples of 3 up to 30:\n3\n6\n9\n12\n15\n18\n21\n24\n27\n30\n</pre> In\u00a0[99]: Copied! <pre>cubes = [number ** 3 for number in range(1, 11)]\n\nprint(cubes)\n</pre> cubes = [number ** 3 for number in range(1, 11)]  print(cubes) <pre>[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n</pre> In\u00a0[75]: Copied! <pre>vehicle = [\"Ninja 600\", \"3000GT\", \"Jeep Wrangler\", \"Tacoma\", \"LandCrusier\"]\n\nprint('The first three items in the list are:', (vehicle[:3]))\n</pre> vehicle = [\"Ninja 600\", \"3000GT\", \"Jeep Wrangler\", \"Tacoma\", \"LandCrusier\"]  print('The first three items in the list are:', (vehicle[:3])) <pre>The first three items in the list are: ['Ninja 600', '3000GT', 'Jeep Wrangler']\n</pre> <p>Print the message Three items from the middle of the list are:. Use a slice to print three items from the middle of the list.</p> In\u00a0[80]: Copied! <pre>MiddleThree = len(vehicle) // 2 - 1\n\nprint('The three items from the middle in the list are:', (vehicle[MiddleThree:MiddleThree + 3]))\n</pre> MiddleThree = len(vehicle) // 2 - 1  print('The three items from the middle in the list are:', (vehicle[MiddleThree:MiddleThree + 3]))  <pre>The three items from the middle in the list are: ['3000GT', 'Jeep Wrangler', 'Tacoma']\n</pre> <p>Print the message The last three items in the list are:. Use a slice to print the last three items in the list.</p> In\u00a0[81]: Copied! <pre>print('The last three items in the list are:', (vehicle[-3:]))\n</pre> print('The last three items in the list are:', (vehicle[-3:])) <pre>The last three items in the list are: ['Jeep Wrangler', 'Tacoma', 'LandCrusier']\n</pre> In\u00a0[82]: Copied! <pre>AvailableFoods = (\"Burger\", \"Salad\", \"Pasta\", \"Ribs\")\n\nprint(\"Foods available at this restaurant:\")\n\nfor option in AvailableFoods:\n\n    print(option)\n</pre> AvailableFoods = (\"Burger\", \"Salad\", \"Pasta\", \"Ribs\")  print(\"Foods available at this restaurant:\")  for option in AvailableFoods:      print(option) <pre>Foods available at this restaurant:\nBurger\nSalad\nPasta\nRibs\n</pre> <p>The restaurant changes its menu, replacing two of the items with different foods. Add a line that rewrites the tuple, and then use a for loop to print each of the items on the revised menu.</p> In\u00a0[84]: Copied! <pre>OriginalAvailableFoods = (\"Burger\", \"Salad\", \"Pasta\", \"Ribs\")\n\nprint(\"Original Menu:\")\nfor option in OriginalAvailableFoods:\n    print(option)\n\nNewAvailableFoods = (\"Soup\", \"Pizza\", \"Sandwich\", \"Sushi\")\n\nprint(\"\")\n\nprint(\"New Menu:\")\nfor option in NewAvailableFoods:\n    print(option)\n</pre> OriginalAvailableFoods = (\"Burger\", \"Salad\", \"Pasta\", \"Ribs\")  print(\"Original Menu:\") for option in OriginalAvailableFoods:     print(option)  NewAvailableFoods = (\"Soup\", \"Pizza\", \"Sandwich\", \"Sushi\")  print(\"\")  print(\"New Menu:\") for option in NewAvailableFoods:     print(option) <pre>Original Menu:\nBurger\nSalad\nPasta\nRibs\n\nNew Menu:\nSoup\nPizza\nSandwich\nSushi\n</pre> In\u00a0[86]: Copied! <pre>#Pass\nalien_color = \"green\"\n\nif alien_color == \"green\":\n    print(\"Congratulations! You just earned 5 points.\")\nelse:\n    print(\"You did not earn any points.\")\n\n#Fail\nalien_color = \"red\"\n\nif alien_color == \"green\":\n    print(\"Congratulations! You just earned 5 points.\")\nelse:\n    print(\"You did not earn any points.\")\n</pre> #Pass alien_color = \"green\"  if alien_color == \"green\":     print(\"Congratulations! You just earned 5 points.\") else:     print(\"You did not earn any points.\")  #Fail alien_color = \"red\"  if alien_color == \"green\":     print(\"Congratulations! You just earned 5 points.\") else:     print(\"You did not earn any points.\")  <pre>Congratulations! You just earned 5 points.\nYou did not earn any points.\n</pre> In\u00a0[87]: Copied! <pre>age = 22\n\nif age &lt; 2:\n\n    print(\"The person is a baby.\")\n\nelif age &lt; 4:\n\n    print(\"The person is a toddler.\")\n\nelif age &lt; 13:\n\n    print(\"The person is a kid.\")\n\nelif age &lt; 20:\n\n    print(\"The person is a teenager.\")\n\nelif age &lt; 65:\n\n    print(\"The person is an adult.\")\n\nelse:\n    \n    print(\"The person is a senior citizen.\")\n</pre> age = 22  if age &lt; 2:      print(\"The person is a baby.\")  elif age &lt; 4:      print(\"The person is a toddler.\")  elif age &lt; 13:      print(\"The person is a kid.\")  elif age &lt; 20:      print(\"The person is a teenager.\")  elif age &lt; 65:      print(\"The person is an adult.\")  else:          print(\"The person is a senior citizen.\")  <pre>The person is an adult.\n</pre> In\u00a0[88]: Copied! <pre>FavoriteFruits = [\"banana\", \"apple\", \"strawberry\"]\n\nif \"banana\" in FavoriteFruits:\n\n    print(\"You really like bananas.\")\n\nif \"apple\" in FavoriteFruits:\n\n    print(\"You really like apples.\")\n\nif \"orange\" in FavoriteFruits:\n\n    print(\"You really like oranges.\")\n\nif \"strawberry\" in FavoriteFruits:\n\n    print(\"You really like strawberries.\")\n\nif \"kiwi\" in FavoriteFruits:\n\n    print(\"You really like kiwis.\")\n</pre> FavoriteFruits = [\"banana\", \"apple\", \"strawberry\"]  if \"banana\" in FavoriteFruits:      print(\"You really like bananas.\")  if \"apple\" in FavoriteFruits:      print(\"You really like apples.\")  if \"orange\" in FavoriteFruits:      print(\"You really like oranges.\")  if \"strawberry\" in FavoriteFruits:      print(\"You really like strawberries.\")  if \"kiwi\" in FavoriteFruits:      print(\"You really like kiwis.\")  <pre>You really like bananas.\nYou really like apples.\nYou really like strawberries.\n</pre> In\u00a0[91]: Copied! <pre>UserNames = [\"Admin\", \"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]\n\nfor name in UserNames:\n\n    if name == \"Admin\":\n\n        print(\"Hello Admin, would you like to see a status report?\")\n\n    else:\n\n        print(f\"Hello {name}, thank you for logging in again.\")\n</pre> UserNames = [\"Admin\", \"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]  for name in UserNames:      if name == \"Admin\":          print(\"Hello Admin, would you like to see a status report?\")      else:          print(f\"Hello {name}, thank you for logging in again.\")  <pre>Hello Admin, would you like to see a status report?\nHello Ryan, thank you for logging in again.\nHello Jake, thank you for logging in again.\nHello Trevor, thank you for logging in again.\nHello Rylee, thank you for logging in again.\n</pre> In\u00a0[95]: Copied! <pre>current_users = [\"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]\n\n\nnew_users = [\"Jack\", \"Ryan\", \"Sarah\", \"Dylan\", \"Trevor\"]\n\ncurrent_users_lower = [user.lower for user in current_users]\n\nfor new_user in new_users:\n\n    if new_user.lower in current_users_lower:\n\n        print(f\"Sorry, the username '{new_user}' is not available. Please enter a new username.\")\n    \n    else:\n        \n        print(f\"The username '{new_user}' is available.\")\n</pre> current_users = [\"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]   new_users = [\"Jack\", \"Ryan\", \"Sarah\", \"Dylan\", \"Trevor\"]  current_users_lower = [user.lower for user in current_users]  for new_user in new_users:      if new_user.lower in current_users_lower:          print(f\"Sorry, the username '{new_user}' is not available. Please enter a new username.\")          else:                  print(f\"The username '{new_user}' is available.\")  <pre>The username 'Jack' is available.\nSorry, the username 'Ryan' is not available. Please enter a new username.\nThe username 'Sarah' is available.\nThe username 'Dylan' is available.\nSorry, the username 'Trevor' is not available. Please enter a new username.\n</pre> In\u00a0[\u00a0]: Copied! <pre>numbers = list(range(1,10))\n\nfor number in numbers:\n\n    if number == 1:\n\n        print(\"1st\")\n\n    elif number == 2:\n\n        print(\"2nd\")\n\n    elif number == 3:\n\n        print(\"3rd\")\n\n    else:\n        \n        print(f\"{number}th\")\n</pre> numbers = list(range(1,10))  for number in numbers:      if number == 1:          print(\"1st\")      elif number == 2:          print(\"2nd\")      elif number == 3:          print(\"3rd\")      else:                  print(f\"{number}th\")"},{"location":"Notebooks/lab4/#lab-4","title":"Lab 4\u00b6","text":""},{"location":"Notebooks/lab4/#submission-instructions","title":"Submission instructions\u00b6","text":"<ol> <li>Download the notebook from https://geohey.gishub.org/labs/lab4</li> <li>Complete the lab questions</li> <li>Restart Kernel and Run All Cells</li> <li>Upload the notebook to your GitHub repository</li> <li>Make sure the notebook has an <code>Open In Colab</code> badge. Click on the badge to make sure your notebook can be opened in Colab.</li> <li>Submit the link to the notebook on your GitHub repository to Canvas</li> </ol>"},{"location":"Notebooks/lab4/#question-1","title":"Question 1\u00b6","text":"<p>Personal Message: Use a variable to represent a person\u2019s name, and print a message to that person. Your message should be simple, such as, \u201cHello Eric, would you like to learn some Python today?\u201d</p>"},{"location":"Notebooks/lab4/#question-2","title":"Question 2\u00b6","text":"<p>Name Cases: Use a variable to represent a person\u2019s name, and then print that person\u2019s name in lowercase, uppercase, and title case.</p>"},{"location":"Notebooks/lab4/#question-3","title":"Question 3\u00b6","text":"<p>Famous Quote: Find a quote from a famous person you admire. Print the quote and the name of its author. Your output should look something like the following, including the quotation marks:</p> <pre><code>Albert Einstein once said, \u201cA person who never made a mistake never tried anything new.\u201d\n</code></pre>"},{"location":"Notebooks/lab4/#question-4","title":"Question 4\u00b6","text":"<p>Stripping Names: Use a variable to represent a person\u2019s name, and include some whitespace characters at the beginning and end of the name. Make sure you use each character combination, \"\\t\" and \"\\n\", at least once. Print the name once, so the whitespace around the name is displayed. Then print the name using each of the three stripping functions, lstrip(), rstrip(), and strip().</p>"},{"location":"Notebooks/lab4/#question-5","title":"Question 5\u00b6","text":"<p>Names: Store the names of a few of your friends in a list called names. Print each person\u2019s name by accessing each element in the list, one at a time.</p>"},{"location":"Notebooks/lab4/#question-6","title":"Question 6\u00b6","text":"<p>Your Own List: Think of your favorite mode of transportation, such as a motorcycle or a car, and make a list that stores several examples. Use your list to print a series of statements about these items, such as \u201cI would like to own a Honda motorcycle.\u201d</p>"},{"location":"Notebooks/lab4/#question-7","title":"Question 7\u00b6","text":"<p>Pizzas: Think of at least three kinds of your favorite pizza. Store these pizza names in a list, and then use a for loop to print the name of each pizza.</p> <p>Modify your for loop to print a sentence using the name of the pizza instead of printing just the name of the pizza. For each pizza you should have one line of output containing a simple statement like I like pepperoni pizza.</p>"},{"location":"Notebooks/lab4/#question-8","title":"Question 8\u00b6","text":"<p>Animals: Think of at least three different animals that have a common characteristic. Store the names of these animals in a list, and then use a for loop to print out the name of each animal.</p> <p>Modify your program to print a statement about each animal, such as A dog would make a great pet.</p>"},{"location":"Notebooks/lab4/#question-9","title":"Question 9\u00b6","text":"<p>Summing a Hundred: Make a list of the numbers from one to one hundred, and then use <code>min()</code> and <code>max()</code> to make sure your list actually starts at one and ends at one hundred. Also, use the sum() function to see how quickly Python can add a hundred numbers.</p>"},{"location":"Notebooks/lab4/#question-10","title":"Question 10\u00b6","text":"<p>Odd Numbers: Use the third argument of the <code>range()</code> function to make a list of the odd numbers from 1 to 20. Use a <code>for</code> loop to print each number.</p>"},{"location":"Notebooks/lab4/#question-11","title":"Question 11\u00b6","text":"<p>Threes: Make a list of the multiples of 3 from 3 to 30. Use a <code>for</code> loop to print the numbers in your list.</p>"},{"location":"Notebooks/lab4/#question-12","title":"Question 12\u00b6","text":"<p>Cube Comprehension: Use a list comprehension to generate a list of the first 10 cubes.</p>"},{"location":"Notebooks/lab4/#question-13","title":"Question 13\u00b6","text":"<p>Slices: Using one of the programs you wrote in this lab, add several lines to the end of the program that do the following:</p> <p>Print the message The first three items in the list are:. Then use a slice to print the first three items from that program\u2019s list.</p>"},{"location":"Notebooks/lab4/#question-14","title":"Question 14\u00b6","text":"<p>Buffet: A buffet-style restaurant offers only five basic foods. Think of five simple foods, and store them in a tuple.</p> <p>Use a for loop to print each food the restaurant offers.</p>"},{"location":"Notebooks/lab4/#question-15","title":"Question 15\u00b6","text":"<p>Alien Colors: Imagine an alien was just shot down in a game. Create a variable called <code>alien_color</code> and assign it a value of <code>green, yellow,</code> or <code>red</code>.</p> <ul> <li>Write an if statement to test whether the alien\u2019s color is green. If it is, print a message that the player just earned 5 points.</li> <li>Write one version of this program that passes the if test and another that fails. (The version that fails will have no output.)</li> </ul>"},{"location":"Notebooks/lab4/#question-16","title":"Question 16\u00b6","text":"<p>Stages of Life: Write an <code>if-elif-else</code> chain that determines a person\u2019s stage of life. Set a value for the variable <code>age</code>, and then:</p> <ul> <li>If the person is less than 2 years old, print a message that the person is a baby.</li> <li>If the person is at least 2 years old but less than 4, print a message that the person is a toddler.</li> <li>If the person is at least 4 years old but less than 13, print a message that the person is a kid.</li> <li>If the person is at least 13 years old but less than 20, print a message that the person is a teenager.</li> <li>If the person is at least 20 years old but less than 65, print a message that the person is an adult.</li> </ul>"},{"location":"Notebooks/lab4/#question-17","title":"Question 17\u00b6","text":"<p>Favorite Fruit: Make a list of your favorite fruits, and then write a series of independent <code>if</code> statements that check for certain fruits in your list.</p> <ul> <li>Make a list of your three favorite fruits and call it favorite_fruits.</li> <li>Write five if statements. Each should check whether a certain kind of fruit is in your list. If the fruit is in your list, the if block should print a statement, such as You really like bananas!</li> </ul>"},{"location":"Notebooks/lab4/#question-18","title":"Question 18\u00b6","text":"<p>Hello Admin: Make a list of five or more usernames, including the name <code>admin</code>. Imagine you are writing code that will print a greeting to each user after they log in to a website. Loop through the list, and print a greeting to each user:</p> <ul> <li>If the username is 'admin', print a special greeting, such as Hello admin, would you like to see a status report?</li> <li>Otherwise, print a generic greeting, such as Hello Jaden, thank you for logging in again.</li> </ul>"},{"location":"Notebooks/lab4/#question-19","title":"Question 19\u00b6","text":"<p>Checking Usernames: Do the following to create a program that simulates how websites ensure that everyone has a unique username.</p> <ul> <li>Make a list of five or more usernames called <code>current_users</code>.</li> <li>Make another list of five usernames called <code>new_users</code>. Make sure one or two of the new usernames are also in the <code>current_users</code> list.</li> <li>Loop through the <code>new_users</code> list to see if each new username has already been used. If it has, print a message that the person will need to enter a new username. If a username has not been used, print a message saying that the username is available.</li> <li>Make sure your comparison is case insensitive. If 'John' has been used, 'JOHN' should not be accepted. (To do this, you\u2019ll need to make a copy of <code>current_users</code> containing the lowercase versions of all existing users.)</li> </ul>"},{"location":"Notebooks/lab4/#question-20","title":"Question 20\u00b6","text":"<p>Ordinal Numbers: Ordinal numbers indicate their position in a list, such as 1st or 2nd. Most ordinal numbers end in th, except 1, 2, and 3.</p> <ul> <li>Store the numbers 1 through 9 in a list.</li> <li>Loop through the list.</li> <li>Use an <code>if-elif-else</code> chain inside the loop to print the proper ordinal ending for each number. Your output should read \"1st 2nd 3rd 4th 5th 6th 7th 8th 9th\", and each result should be on a separate line.</li> </ul>"},{"location":"Notebooks/lab5/","title":"Lab5","text":"In\u00a0[4]: Copied! <pre># Create a dictionary to store information about a person\nperson_info = {\n    'first_name': 'Ryan',\n    'last_name': 'Willson',\n    'age': 30,\n    'city': 'Washington D.C.'\n}\n\n# Print each piece of information stored in the dictionary\nprint(\"First Name:\", person_info['first_name'])\nprint(\"Last Name:\", person_info['last_name'])\nprint(\"Age:\", person_info['age'])\nprint(\"City:\", person_info['city'])\n</pre> # Create a dictionary to store information about a person person_info = {     'first_name': 'Ryan',     'last_name': 'Willson',     'age': 30,     'city': 'Washington D.C.' }  # Print each piece of information stored in the dictionary print(\"First Name:\", person_info['first_name']) print(\"Last Name:\", person_info['last_name']) print(\"Age:\", person_info['age']) print(\"City:\", person_info['city'])  <pre>First Name: Ryan\nLast Name: Willson\nAge: 30\nCity: Washington D.C.\n</pre> In\u00a0[5]: Copied! <pre># Create a dictionary to store people's favorite numbers\nfavorite_numbers = {\n    'Ryan': 25,\n    'Jake': 42,\n    'Trevor': 7,\n    'Dylan': 8,\n    'Rylee': 16\n}\n\n# Print each person's name and their favorite number\nfor person, number in favorite_numbers.items():\n    print(f\"{person}'s favorite number is {number}.\")\n</pre> # Create a dictionary to store people's favorite numbers favorite_numbers = {     'Ryan': 25,     'Jake': 42,     'Trevor': 7,     'Dylan': 8,     'Rylee': 16 }  # Print each person's name and their favorite number for person, number in favorite_numbers.items():     print(f\"{person}'s favorite number is {number}.\")  <pre>Ryan's favorite number is 25.\nJake's favorite number is 42.\nTrevor's favorite number is 7.\nDylan's favorite number is 8.\nRylee's favorite number is 16.\n</pre> In\u00a0[9]: Copied! <pre># Create a glossary dictionary\nglossary = {\n    'list': 'A collection of items, ordered and changeable, used to store multiple values in a single variable.',\n    'definition': 'A statement or description that explains the meaning of a word or the purpose of a concept in programming.',\n    'function': 'A reusable block of code that performs a specific task.',\n    'variable': 'A named storage location in a program that can hold a value.',\n    'loop': 'A control flow statement that allows code to be repeatedly executed.',\n}\n\n# Print each word and its meaning neatly formatted\nfor word, meaning in glossary.items():\n    print(f\"{word}:\\n{meaning}\\n\")\n</pre> # Create a glossary dictionary glossary = {     'list': 'A collection of items, ordered and changeable, used to store multiple values in a single variable.',     'definition': 'A statement or description that explains the meaning of a word or the purpose of a concept in programming.',     'function': 'A reusable block of code that performs a specific task.',     'variable': 'A named storage location in a program that can hold a value.',     'loop': 'A control flow statement that allows code to be repeatedly executed.', }  # Print each word and its meaning neatly formatted for word, meaning in glossary.items():     print(f\"{word}:\\n{meaning}\\n\") <pre>list:\nA collection of items, ordered and changeable, used to store multiple values in a single variable.\n\ndefinition:\nA statement or description that explains the meaning of a word or the purpose of a concept in programming.\n\nfunction:\nA reusable block of code that performs a specific task.\n\nvariable:\nA named storage location in a program that can hold a value.\n\nloop:\nA control flow statement that allows code to be repeatedly executed.\n\n</pre> In\u00a0[10]: Copied! <pre>#Adding more python terms to the glossary\nglossary.update({\n    'dictionary': 'A collection of key-value pairs, allowing efficient data retrieval.',\n    'module': 'A file containing Python definitions and statements, intended for reuse.',\n    'exception': 'An event that occurs during the execution of a program and disrupts the normal flow.',\n    'syntax': 'A set of rules that dictate how programs in a specific language are constructed.',\n    'algorithm': 'A step-by-step procedure or formula for solving a problem or accomplishing a task.'\n})\n\n# Print each word and its meaning using a loop\nfor word, meaning in glossary.items():\n    print(f\"{word}:\\n{meaning}\\n\")\n</pre> #Adding more python terms to the glossary glossary.update({     'dictionary': 'A collection of key-value pairs, allowing efficient data retrieval.',     'module': 'A file containing Python definitions and statements, intended for reuse.',     'exception': 'An event that occurs during the execution of a program and disrupts the normal flow.',     'syntax': 'A set of rules that dictate how programs in a specific language are constructed.',     'algorithm': 'A step-by-step procedure or formula for solving a problem or accomplishing a task.' })  # Print each word and its meaning using a loop for word, meaning in glossary.items():     print(f\"{word}:\\n{meaning}\\n\") <pre>list:\nA collection of items, ordered and changeable, used to store multiple values in a single variable.\n\ndefinition:\nA statement or description that explains the meaning of a word or the purpose of a concept in programming.\n\nfunction:\nA reusable block of code that performs a specific task.\n\nvariable:\nA named storage location in a program that can hold a value.\n\nloop:\nA control flow statement that allows code to be repeatedly executed.\n\ndictionary:\nA collection of key-value pairs, allowing efficient data retrieval.\n\nmodule:\nA file containing Python definitions and statements, intended for reuse.\n\nexception:\nAn event that occurs during the execution of a program and disrupts the normal flow.\n\nsyntax:\nA set of rules that dictate how programs in a specific language are constructed.\n\nalgorithm:\nA step-by-step procedure or formula for solving a problem or accomplishing a task.\n\n</pre> In\u00a0[16]: Copied! <pre># Create a dictionary of major rivers and the countries they run through\nrivers = {\n    'Mississippi River': 'United States of America',\n    'Amazon': 'Brazil',\n    'Nile': 'Egypt'\n    \n    \n}\n\n# Use a loop to print a sentence about each river\nprint(\"River Information:\")\nfor river, country in rivers.items():\n    print(f\"The {river} is located in {country}.\")\n\n# Use a loop to print the names of each river\nprint(\"\\nNames of Rivers:\")\nfor river in rivers.keys():\n    print(river)\n\n# Use a loop to print the names of each country\nprint(\"\\nNames of Countries:\")\nfor country in rivers.values():\n    print(country)\n</pre> # Create a dictionary of major rivers and the countries they run through rivers = {     'Mississippi River': 'United States of America',     'Amazon': 'Brazil',     'Nile': 'Egypt'           }  # Use a loop to print a sentence about each river print(\"River Information:\") for river, country in rivers.items():     print(f\"The {river} is located in {country}.\")  # Use a loop to print the names of each river print(\"\\nNames of Rivers:\") for river in rivers.keys():     print(river)  # Use a loop to print the names of each country print(\"\\nNames of Countries:\") for country in rivers.values():     print(country)  <pre>River Information:\nThe Mississippi River is located in United States of America.\nThe Amazon is located in Brazil.\nThe Nile is located in Egypt.\n\nNames of Rivers:\nMississippi River\nAmazon\nNile\n\nNames of Countries:\nUnited States of America\nBrazil\nEgypt\n</pre> In\u00a0[47]: Copied! <pre># Create a dictionary of cities and their information\ncities = {\n    'New York': {\n        'country': 'United States',\n        'population': \"8.468 million\",\n        'fact': 'The Statue of Liberty is located in New York Harbor.'\n    },\n    'Tokyo': {\n        'country': 'Japan',\n        'population': \"13.96 million\",\n        'fact': 'Tokyo is the most populous metropolitan area in the world.'\n    },\n    'Paris': {\n        'country': 'France',\n        'population': \"2.161 million\",\n        'fact': 'Paris is known as the \"City of Light\" and is famous for its art and culture.'\n    }\n}\n\n# Print the name of each city and its information\nfor city, info in cities.items():\n    print(f\"\\nCity: {city}\")\n    print(f\"Country: {info['country']}\")\n    print(f\"Population: {info['population']}\")\n    print(f\"Fact: {info['fact']}\")\n</pre> # Create a dictionary of cities and their information cities = {     'New York': {         'country': 'United States',         'population': \"8.468 million\",         'fact': 'The Statue of Liberty is located in New York Harbor.'     },     'Tokyo': {         'country': 'Japan',         'population': \"13.96 million\",         'fact': 'Tokyo is the most populous metropolitan area in the world.'     },     'Paris': {         'country': 'France',         'population': \"2.161 million\",         'fact': 'Paris is known as the \"City of Light\" and is famous for its art and culture.'     } }  # Print the name of each city and its information for city, info in cities.items():     print(f\"\\nCity: {city}\")     print(f\"Country: {info['country']}\")     print(f\"Population: {info['population']}\")     print(f\"Fact: {info['fact']}\")  <pre>\nCity: New York\nCountry: United States\nPopulation: 8.468 million\nFact: The Statue of Liberty is located in New York Harbor.\n\nCity: Tokyo\nCountry: Japan\nPopulation: 13.96 million\nFact: Tokyo is the most populous metropolitan area in the world.\n\nCity: Paris\nCountry: France\nPopulation: 2.161 million\nFact: Paris is known as the \"City of Light\" and is famous for its art and culture.\n</pre> In\u00a0[18]: Copied! <pre># Ask the user what kind of rental car they would like\nrental_car = input(\"What kind of rental car would you like? \")\n\n# Print a message based on the user's choice\nprint(f\"Let me see if I can find you a {rental_car}.\")\n</pre> # Ask the user what kind of rental car they would like rental_car = input(\"What kind of rental car would you like? \")  # Print a message based on the user's choice print(f\"Let me see if I can find you a {rental_car}.\")  <pre>Let me see if I can find you a tacoma.\n</pre> In\u00a0[21]: Copied! <pre># Ask the user how many people are in their dinner group\nnum_people = int(input(\"How many people are in your dinner group? \"))\n\n# Check the number of people and provide a response\nif num_people &gt; 8:\n    print(\"I'm sorry, but you'll have to wait for a table.\")\nelse:\n    print(\"Your table is ready. Enjoy your meal!\")\n</pre> # Ask the user how many people are in their dinner group num_people = int(input(\"How many people are in your dinner group? \"))  # Check the number of people and provide a response if num_people &gt; 8:     print(\"I'm sorry, but you'll have to wait for a table.\") else:     print(\"Your table is ready. Enjoy your meal!\")  <pre>Your table is ready. Enjoy your meal!\n</pre> In\u00a0[22]: Copied! <pre># Ask the user for a number\nuser_number = int(input(\"Please enter a number: \"))\n\n# Check if the number is a multiple of 10\nif user_number % 10 == 0:\n    print(f\"{user_number} is a multiple of 10.\")\nelse:\n    print(f\"{user_number} is not a multiple of 10.\")\n</pre> # Ask the user for a number user_number = int(input(\"Please enter a number: \"))  # Check if the number is a multiple of 10 if user_number % 10 == 0:     print(f\"{user_number} is a multiple of 10.\") else:     print(f\"{user_number} is not a multiple of 10.\")  <pre>5 is not a multiple of 10.\n</pre> In\u00a0[31]: Copied! <pre># Initialize an empty list to store pizza toppings\npizza_toppings = []\n\n# Prompt the user to enter pizza toppings\nwhile True:\n    topping = input(\"Enter a pizza topping (type 'quit' to finish): \")\n\n    # Check if the user wants to quit\n    if topping.lower() == 'quit':\n        break\n\n    # Add the topping to the list and print a message\n    pizza_toppings.append(topping)\n    print(f\"Adding {topping} to your pizza.\")\n\n# Print the final list of pizza toppings\nprint(\"\\nYour pizza will have the following toppings:\")\nfor topping in pizza_toppings:\n    print(f\"- {topping}\")\n</pre> # Initialize an empty list to store pizza toppings pizza_toppings = []  # Prompt the user to enter pizza toppings while True:     topping = input(\"Enter a pizza topping (type 'quit' to finish): \")      # Check if the user wants to quit     if topping.lower() == 'quit':         break      # Add the topping to the list and print a message     pizza_toppings.append(topping)     print(f\"Adding {topping} to your pizza.\")  # Print the final list of pizza toppings print(\"\\nYour pizza will have the following toppings:\") for topping in pizza_toppings:     print(f\"- {topping}\")  <pre>Adding bacon to your pizza.\nAdding pepperoni to your pizza.\n\nYour pizza will have the following toppings:\n- bacon\n- pepperoni\n</pre> In\u00a0[40]: Copied! <pre># Define the display_message function\ndef message():\n    print(\"In this notebook, I am learning about Python functions and basic programming concepts.\")\n\n# Call the function to display the message\nmessage()\n</pre> # Define the display_message function def message():     print(\"In this notebook, I am learning about Python functions and basic programming concepts.\")  # Call the function to display the message message()  <pre>In this notebook, I am learning about Python functions and basic programming concepts.\n</pre> In\u00a0[41]: Copied! <pre># Define the favorite_book function\ndef favorite_book(title):\n    print(f\"One of my favorite books is {title}.\")\n\n# Call the function with a book title\nfavorite_book(\"Jurassic Park\")\n</pre> # Define the favorite_book function def favorite_book(title):     print(f\"One of my favorite books is {title}.\")  # Call the function with a book title favorite_book(\"Jurassic Park\")  <pre>One of my favorite books is Jurassic Park.\n</pre> In\u00a0[42]: Copied! <pre># Define the make_shirt function\ndef make_shirt(size, message):\n    print(f\"Creating a shirt of size {size} with the message: '{message}'.\")\n\n# Call the function once using positional arguments\nmake_shirt(\"Medium\", \"So Cool It Hurts\")\n\n# Call the function a second time using keyword arguments\nmake_shirt(size=\"Large\", message=\"Python Lover\")\n</pre> # Define the make_shirt function def make_shirt(size, message):     print(f\"Creating a shirt of size {size} with the message: '{message}'.\")  # Call the function once using positional arguments make_shirt(\"Medium\", \"So Cool It Hurts\")  # Call the function a second time using keyword arguments make_shirt(size=\"Large\", message=\"Python Lover\")  <pre>Creating a shirt of size Medium with the message: 'So Cool It Hurts'.\nCreating a shirt of size Large with the message: 'Python Lover'.\n</pre> In\u00a0[43]: Copied! <pre># Modified make_shirt function with default values\ndef make_shirt(size=\"Large\", message=\"I love Python\"):\n    print(f\"Creating a shirt of size {size} with the message: '{message}'.\")\n\n# Create a large shirt with the default message\nmake_shirt()\n\n# Create a medium shirt with the default message\nmake_shirt(size=\"Medium\")\n\n# Create a custom-sized shirt with a different message\nmake_shirt(size=\"Small\", message=\"Python is Fun!\")\n</pre> # Modified make_shirt function with default values def make_shirt(size=\"Large\", message=\"I love Python\"):     print(f\"Creating a shirt of size {size} with the message: '{message}'.\")  # Create a large shirt with the default message make_shirt()  # Create a medium shirt with the default message make_shirt(size=\"Medium\")  # Create a custom-sized shirt with a different message make_shirt(size=\"Small\", message=\"Python is Fun!\")  <pre>Creating a shirt of size Large with the message: 'I love Python'.\nCreating a shirt of size Medium with the message: 'I love Python'.\nCreating a shirt of size Small with the message: 'Python is Fun!'.\n</pre> In\u00a0[44]: Copied! <pre># Define the describe_city function with a default country\ndef describe_city(city, country=\"USA\"):\n    print(f\"{city} is in {country}.\")\n\n# Call the function for three different cities\ndescribe_city(\"New York\")\ndescribe_city(\"Washington D.C.\")\ndescribe_city(\"Tokyo\", \"Japan\")\n</pre> # Define the describe_city function with a default country def describe_city(city, country=\"USA\"):     print(f\"{city} is in {country}.\")  # Call the function for three different cities describe_city(\"New York\") describe_city(\"Washington D.C.\") describe_city(\"Tokyo\", \"Japan\")  <pre>New York is in USA.\nWashington D.C. is in USA.\nTokyo is in Japan.\n</pre> In\u00a0[49]: Copied! <pre>def city_country(city, country):\n    return f\"{city}, {country}\"\n\nprint(city_country(\"Tokyo\", \"Japan\"))\nprint(city_country(\"New York\", \"USA\"))\nprint(city_country(\"Paris\", \"France\"))\n</pre> def city_country(city, country):     return f\"{city}, {country}\"  print(city_country(\"Tokyo\", \"Japan\")) print(city_country(\"New York\", \"USA\")) print(city_country(\"Paris\", \"France\"))  <pre>Tokyo, Japan\nNew York, USA\nParis, France\n</pre> In\u00a0[50]: Copied! <pre># Define the make_album function\ndef make_album(artist, title, songs=None):\n    album = {'artist': artist, 'title': title}\n    if songs is not None:\n        album['songs'] = songs\n    return album\n\n# Make three dictionaries representing different albums\nalbum1 = make_album(\"Imagine Dragons\", \"Night Visions\", songs=13)\nalbum2 = make_album(\"The Beatles\", \"Abbey Road\", songs=17)\nalbum3 = make_album(\"Ed Sheeran\", \"\u00f7 (Divide)\", songs=16)\n\n# Print each return value to show the stored album information\nprint(album1)\nprint(album2)\nprint(album3)\n\nalbum4 = make_album(\"John Williams\", \"Jurassic Park\", songs=16)\nprint(album4)\n</pre> # Define the make_album function def make_album(artist, title, songs=None):     album = {'artist': artist, 'title': title}     if songs is not None:         album['songs'] = songs     return album  # Make three dictionaries representing different albums album1 = make_album(\"Imagine Dragons\", \"Night Visions\", songs=13) album2 = make_album(\"The Beatles\", \"Abbey Road\", songs=17) album3 = make_album(\"Ed Sheeran\", \"\u00f7 (Divide)\", songs=16)  # Print each return value to show the stored album information print(album1) print(album2) print(album3)  album4 = make_album(\"John Williams\", \"Jurassic Park\", songs=16) print(album4) <pre>{'artist': 'Imagine Dragons', 'title': 'Night Visions', 'songs': 13}\n{'artist': 'The Beatles', 'title': 'Abbey Road', 'songs': 17}\n{'artist': 'Ed Sheeran', 'title': '\u00f7 (Divide)', 'songs': 16}\n{'artist': 'John Williams', 'title': 'Jurassic Park', 'songs': 16}\n</pre> In\u00a0[60]: Copied! <pre># Define the make_album function\ndef make_album(artist, title, songs=None):\n    album = {'artist': artist, 'title': title}\n    if songs is not None:\n        album['songs'] = songs\n    return album\n\nalbums = [\n    (\"Imagine Dragons\", \"Night Visions\"),\n    (\"The Beatles\", \"Abbey Road\"),\n    (\"Ed Sheeran\", \"\u00f7 (Divide)\"),\n    (\"end\", \"end\") \n]\n\nfor artist, title in albums:\n    if artist.lower() == 'end' or title.lower() == 'end':\n        print(\"bye\")\n        break\n    else:\n        album = make_album(artist, title)\n        print(album)\n</pre> # Define the make_album function def make_album(artist, title, songs=None):     album = {'artist': artist, 'title': title}     if songs is not None:         album['songs'] = songs     return album  albums = [     (\"Imagine Dragons\", \"Night Visions\"),     (\"The Beatles\", \"Abbey Road\"),     (\"Ed Sheeran\", \"\u00f7 (Divide)\"),     (\"end\", \"end\")  ]  for artist, title in albums:     if artist.lower() == 'end' or title.lower() == 'end':         print(\"bye\")         break     else:         album = make_album(artist, title)         print(album)   <pre>{'artist': 'Imagine Dragons', 'title': 'Night Visions'}\n{'artist': 'The Beatles', 'title': 'Abbey Road'}\n{'artist': 'Ed Sheeran', 'title': '\u00f7 (Divide)'}\nbye\n</pre> In\u00a0[61]: Copied! <pre># Define the show_messages function\ndef show_messages(messages):\n    for message in messages:\n        print(message)\n\n# Create a list of short text messages\ntext_messages = [\n    \"Hello!\",\n    \"How are you?\",\n    \"Python is fun!\",\n    \"Keep coding!\",\n    \"Have a great day!\"\n]\n\n# Call the show_messages function with the list of messages\nshow_messages(text_messages)\n</pre> # Define the show_messages function def show_messages(messages):     for message in messages:         print(message)  # Create a list of short text messages text_messages = [     \"Hello!\",     \"How are you?\",     \"Python is fun!\",     \"Keep coding!\",     \"Have a great day!\" ]  # Call the show_messages function with the list of messages show_messages(text_messages)  <pre>Hello!\nHow are you?\nPython is fun!\nKeep coding!\nHave a great day!\n</pre> In\u00a0[73]: Copied! <pre># Define the send_messages function\ndef send_messages(messages, sent_messages):\n    while messages:\n        current_message = messages.pop()\n        print(f\"Sending message: {current_message}\")\n        sent_messages.append(current_message)\n    return sent_messages\n\n# Create a list of short text messages\ntext_messages = [\n    \"Hello!\",\n    \"How are you?\",\n    \"Python is fun!\",\n    \"Keep coding!\",\n    \"Have a great day!\"\n]\n\n# Create an empty list to store sent messages\nsent_messages = []\n\n# Call the send_messages function with the list of messages\nsend_messages(text_messages, sent_messages)\n\n# Print both lists to verify messages were moved correctly\nprint(\"\\nOriginal messages:\")\nprint(text_messages)\n\nprint(\"\\nSent messages:\")\nprint(sent_messages)\n</pre> # Define the send_messages function def send_messages(messages, sent_messages):     while messages:         current_message = messages.pop()         print(f\"Sending message: {current_message}\")         sent_messages.append(current_message)     return sent_messages  # Create a list of short text messages text_messages = [     \"Hello!\",     \"How are you?\",     \"Python is fun!\",     \"Keep coding!\",     \"Have a great day!\" ]  # Create an empty list to store sent messages sent_messages = []  # Call the send_messages function with the list of messages send_messages(text_messages, sent_messages)  # Print both lists to verify messages were moved correctly print(\"\\nOriginal messages:\") print(text_messages)  print(\"\\nSent messages:\") print(sent_messages)  <pre>Sending message: Have a great day!\nSending message: Keep coding!\nSending message: Python is fun!\nSending message: How are you?\nSending message: Hello!\n\nOriginal messages:\n[]\n\nSent messages:\n['Have a great day!', 'Keep coding!', 'Python is fun!', 'How are you?', 'Hello!']\n</pre> In\u00a0[78]: Copied! <pre>filename = 'learning_python.txt'\n\n# Read the entire file and print its contents\nwith open(filename) as text_file:\n    contents = text_file.read()\nprint(\"Read entire file:\")\nprint(contents)\n\n# Loop over the file object and print each line\nprint(\"\\nLooping over the file object:\")\nwith open(filename) as text_file:\n    for line in text_file:\n        print(line.rstrip())\n\n# Store lines in a list and print outside the with block\nprint(\"\\nLines stored in a list and printed outside the with block:\")\nwith open(filename) as text_file:\n    lines = text_file.readlines()\n\n# Strip to remove extra newline characters\nfor line in lines:\n    print(line.rstrip())\n</pre> filename = 'learning_python.txt'  # Read the entire file and print its contents with open(filename) as text_file:     contents = text_file.read() print(\"Read entire file:\") print(contents)  # Loop over the file object and print each line print(\"\\nLooping over the file object:\") with open(filename) as text_file:     for line in text_file:         print(line.rstrip())  # Store lines in a list and print outside the with block print(\"\\nLines stored in a list and printed outside the with block:\") with open(filename) as text_file:     lines = text_file.readlines()  # Strip to remove extra newline characters for line in lines:     print(line.rstrip())  <pre>Read entire file:\nIn Python you can define functions to encapsulate reusable code.\nIn Python you can use dictionaries to store key-value pairs.\nIn Python you can work with files using the built-in file handling capabilities.\n\n\nLooping over the file object:\nIn Python you can define functions to encapsulate reusable code.\nIn Python you can use dictionaries to store key-value pairs.\nIn Python you can work with files using the built-in file handling capabilities.\n\nLines stored in a list and printed outside the with block:\nIn Python you can define functions to encapsulate reusable code.\nIn Python you can use dictionaries to store key-value pairs.\nIn Python you can work with files using the built-in file handling capabilities.\n</pre> In\u00a0[79]: Copied! <pre>filename = 'learning_python.txt'\n\nwith open(filename) as text_file:\n    file = text_file.readlines()\n\nfor line in file:\n    modified_line = line.replace('Python', 'C')\n    print(modified_line.rstrip())\n</pre> filename = 'learning_python.txt'  with open(filename) as text_file:     file = text_file.readlines()  for line in file:     modified_line = line.replace('Python', 'C')     print(modified_line.rstrip())  <pre>In C you can define functions to encapsulate reusable code.\nIn C you can use dictionaries to store key-value pairs.\nIn C you can work with files using the built-in file handling capabilities.\n</pre> In\u00a0[80]: Copied! <pre># Prompt the user for their name\nuser_name = input(\"Please enter your name: \")\n\n# Write the user's name to guest.txt\nwith open('guest.txt', 'w') as file:\n    file.write(user_name)\n\nprint(f\"Thank you, {user_name}! Your name has been written to guest.txt.\")\n</pre> # Prompt the user for their name user_name = input(\"Please enter your name: \")  # Write the user's name to guest.txt with open('guest.txt', 'w') as file:     file.write(user_name)  print(f\"Thank you, {user_name}! Your name has been written to guest.txt.\")  <pre>Thank you, Brycen Harris! Your name has been written to guest.txt.\n</pre> In\u00a0[81]: Copied! <pre># Open guest_book.txt in append mode to record visits\nwith open('guest_book.txt', 'a') as guest_book:\n    while True:\n        # Prompt the user for their name\n        user_name = input(\"Please enter your name (type 'quit' to exit): \")\n\n        # Check if the user wants to quit\n        if user_name.lower() == 'quit':\n            break\n\n        # Print a greeting to the screen\n        print(f\"Welcome, {user_name}!\")\n\n        # Write the user's visit to guest_book.txt\n        guest_book.write(f\"{user_name}\\n\")\n\nprint(\"Thanks for visiting! Check guest_book.txt for recorded visits.\")\n</pre> # Open guest_book.txt in append mode to record visits with open('guest_book.txt', 'a') as guest_book:     while True:         # Prompt the user for their name         user_name = input(\"Please enter your name (type 'quit' to exit): \")          # Check if the user wants to quit         if user_name.lower() == 'quit':             break          # Print a greeting to the screen         print(f\"Welcome, {user_name}!\")          # Write the user's visit to guest_book.txt         guest_book.write(f\"{user_name}\\n\")  print(\"Thanks for visiting! Check guest_book.txt for recorded visits.\")  <pre>Welcome, Brycen Harris!\nWelcome, Ryan Willson!\nThanks for visiting! Check guest_book.txt for recorded visits.\n</pre> In\u00a0[82]: Copied! <pre># Open poll_responses.txt in append mode to store responses\nwith open('poll_responses.txt', 'a') as poll_responses:\n    print(\"Welcome to the Programming Poll! Type 'quit' to exit.\")\n\n    while True:\n        # Prompt the user for their reason for liking programming\n        reason = input(\"Why do you like programming? \")\n\n        # Check if the user wants to quit\n        if reason.lower() == 'quit':\n            break\n\n        # Write the user's reason to poll_responses.txt\n        poll_responses.write(f\"{reason}\\n\")\n\nprint(\"Thank you for participating! Responses have been recorded in poll_responses.txt.\")\n</pre> # Open poll_responses.txt in append mode to store responses with open('poll_responses.txt', 'a') as poll_responses:     print(\"Welcome to the Programming Poll! Type 'quit' to exit.\")      while True:         # Prompt the user for their reason for liking programming         reason = input(\"Why do you like programming? \")          # Check if the user wants to quit         if reason.lower() == 'quit':             break          # Write the user's reason to poll_responses.txt         poll_responses.write(f\"{reason}\\n\")  print(\"Thank you for participating! Responses have been recorded in poll_responses.txt.\")  <pre>Welcome to the Programming Poll! Type 'quit' to exit.\nThank you for participating! Responses have been recorded in poll_responses.txt.\n</pre> In\u00a0[84]: Copied! <pre>while True:\n    try:\n        # Prompt the user for two numbers\n        num1 = input(\"Enter the first number: \")\n        num2 = input(\"Enter the second number: \")\n\n        # Convert input to integers and add them together\n        result = int(num1) + int(num2)\n\n        # Print the result\n        print(f\"The sum of {num1} and {num2} is: {result}\")\n\n        # Break out of the loop after successful input\n        break\n\n    except ValueError:\n        # Handle ValueError if input is not a number\n        print(\"Invalid input. Please enter valid numbers.\")\n</pre> while True:     try:         # Prompt the user for two numbers         num1 = input(\"Enter the first number: \")         num2 = input(\"Enter the second number: \")          # Convert input to integers and add them together         result = int(num1) + int(num2)          # Print the result         print(f\"The sum of {num1} and {num2} is: {result}\")          # Break out of the loop after successful input         break      except ValueError:         # Handle ValueError if input is not a number         print(\"Invalid input. Please enter valid numbers.\")  <pre>Invalid input. Please enter valid numbers.\nThe sum of 6 and 8 is: 14\n</pre> In\u00a0[85]: Copied! <pre>while True:\n    try:\n        # Prompt the user for two numbers\n        num1 = input(\"Enter the first number (or 'quit' to exit): \")\n\n        # Check if the user wants to quit\n        if num1.lower() == 'quit':\n            break\n\n        num2 = input(\"Enter the second number: \")\n\n        # Convert input to integers and add them together\n        result = int(num1) + int(num2)\n\n        # Print the result\n        print(f\"The sum of {num1} and {num2} is: {result}\")\n\n    except ValueError:\n        # Handle ValueError if input is not a number\n        print(\"Invalid input. Please enter valid numbers.\")\n</pre> while True:     try:         # Prompt the user for two numbers         num1 = input(\"Enter the first number (or 'quit' to exit): \")          # Check if the user wants to quit         if num1.lower() == 'quit':             break          num2 = input(\"Enter the second number: \")          # Convert input to integers and add them together         result = int(num1) + int(num2)          # Print the result         print(f\"The sum of {num1} and {num2} is: {result}\")      except ValueError:         # Handle ValueError if input is not a number         print(\"Invalid input. Please enter valid numbers.\")  <pre>The sum of 6 and 8 is: 14\nThe sum of 5 and 4 is: 9\nThe sum of 10 and 15 is: 25\n</pre> In\u00a0[88]: Copied! <pre>filenames = ['dogs.txt', 'cats.txt']\n\nfor filename in filenames:\n    try:\n        with open(filename) as text_file:\n            print(f\"Contents of {filename}:\")\n            contents = text_file.read()\n            print(contents)\n            print()\n    except FileNotFoundError:\n        print(f\"Sorry, the file '{filename}' does not exist or cannot be found.\")\n</pre> filenames = ['dogs.txt', 'cats.txt']  for filename in filenames:     try:         with open(filename) as text_file:             print(f\"Contents of {filename}:\")             contents = text_file.read()             print(contents)             print()     except FileNotFoundError:         print(f\"Sorry, the file '{filename}' does not exist or cannot be found.\")  <pre>Contents of dogs.txt:\nGrace\nJunior\nMitsy\n\nContents of cats.txt:\nLuna\nMilo\nOliver\n\n</pre> In\u00a0[89]: Copied! <pre>filenames = ['dogs.txt', 'cats.txt']\n\nfor filename in filenames:\n    try:\n        with open(filename) as text_file:\n            print(f\"Contents of {filename}:\")\n            contents = text_file.read()\n            print(contents)\n            print()\n    except FileNotFoundError:\n        pass\n</pre> filenames = ['dogs.txt', 'cats.txt']  for filename in filenames:     try:         with open(filename) as text_file:             print(f\"Contents of {filename}:\")             contents = text_file.read()             print(contents)             print()     except FileNotFoundError:         pass  <pre>Contents of dogs.txt:\nGrace\nJunior\nMitsy\n\nContents of cats.txt:\nLuna\nMilo\nOliver\n\n</pre> In\u00a0[\u00a0]: Copied! <pre>line = \"Row, row, row your boat\"\nline.count(\"row\")\n</pre> line = \"Row, row, row your boat\" line.count(\"row\") In\u00a0[\u00a0]: Copied! <pre>line.lower().count(\"row\")\n</pre> line.lower().count(\"row\") <p>Notice that converting the string to lowercase using lower() catches all appearances of the word you\u2019re looking for, regardless of how it\u2019s formatted.</p> <p>Write a program that reads the files you found at Project Gutenberg and determines how many times the word <code>the</code> appears in each text. This will be an approximation because it will also count words such as <code>then</code> and <code>there</code>. Try counting <code>the</code>, with a space in the string, and see how much lower your count is.</p> In\u00a0[101]: Copied! <pre>def count_the(file_name, target_word):\n    try:\n        with open(file_name, 'r', encoding='utf-8') as file:\n            content = file.read()\n            # Count occurrences with a space\n            with_space = content.lower().count(target_word.lower())\n            \n            # Count occurrences without a space\n            no_space = content.lower().count(target_word.lower() + \" \")\n\n            print(f\"The word '{target_word}' with space show up {with_space} times in the text file.\")\n            print(f\"The word '{target_word}' without a space shows up {no_space} times in the text file.\")\n\n    except FileNotFoundError:\n        print(f\"Sorry, the file '{filename}' does not exist or cannot be found.\")\n\n# Example usage for the gutenberg_file.txt\ncount_the(\"gutenberg_file.txt\", \"the\")\n</pre> def count_the(file_name, target_word):     try:         with open(file_name, 'r', encoding='utf-8') as file:             content = file.read()             # Count occurrences with a space             with_space = content.lower().count(target_word.lower())                          # Count occurrences without a space             no_space = content.lower().count(target_word.lower() + \" \")              print(f\"The word '{target_word}' with space show up {with_space} times in the text file.\")             print(f\"The word '{target_word}' without a space shows up {no_space} times in the text file.\")      except FileNotFoundError:         print(f\"Sorry, the file '{filename}' does not exist or cannot be found.\")  # Example usage for the gutenberg_file.txt count_the(\"gutenberg_file.txt\", \"the\") <pre>The word 'the' with space show up 3151 times in the text file.\nThe word 'the' without a space shows up 2215 times in the text file.\n</pre>"},{"location":"Notebooks/lab5/#lab-5","title":"Lab 5\u00b6","text":""},{"location":"Notebooks/lab5/#submission-instructions","title":"Submission instructions\u00b6","text":"<ol> <li>Download the notebook from https://geohey.gishub.org/labs/lab5</li> <li>Complete the lab questions</li> <li>Restart Kernel and Run All Cells</li> <li>Upload the notebook to your GitHub repository</li> <li>Make sure the notebook has an <code>Open In Colab</code> badge. Click on the badge to make sure your notebook can be opened in Colab.</li> <li>Submit the link to the notebook on your GitHub repository to Canvas</li> </ol>"},{"location":"Notebooks/lab5/#question-1","title":"Question 1\u00b6","text":"<p>Person: Use a dictionary to store information about a person you know. Store their first name, last name, age, and the city in which they live. You should have keys such as first_name, last_name, age, and city. Print each piece of information stored in your dictionary.</p>"},{"location":"Notebooks/lab5/#question-2","title":"Question 2\u00b6","text":"<p>Favorite Numbers: Use a dictionary to store people\u2019s favorite numbers. Think of five names, and use them as keys in your dictionary. Think of a favorite number for each person, and store each as a value in your dictionary. Print each person\u2019s name and their favorite number. For even more fun, poll a few friends and get some actual data for your program.</p>"},{"location":"Notebooks/lab5/#question-3","title":"Question 3\u00b6","text":"<p>Glossary: A Python dictionary can be used to model an actual dictionary. However, to avoid confusion, let\u2019s call it a glossary.</p> <ul> <li>Think of five programming words you\u2019ve learned about in the previous chapters. Use these words as the keys in your glossary, and store their meanings as values.</li> <li>Print each word and its meaning as neatly formatted output. You might print the word followed by a colon and then its meaning, or print the word on one line and then print its meaning indented on a second line. Use the newline character (\\n) to insert a blank line between each word-meaning pair in your output.</li> </ul>"},{"location":"Notebooks/lab5/#question-4","title":"Question 4\u00b6","text":"<p>Glossary 2: Now that you know how to loop through a dictionary, clean up the code from Question 3 by replacing your series of print() calls with a loop that runs through the dictionary\u2019s keys and values. When you\u2019re sure that your loop works, add five more Python terms to your glossary. When you run your program again, these new words and meanings should automatically be included in the output.</p>"},{"location":"Notebooks/lab5/#question-5","title":"Question 5\u00b6","text":"<p>Rivers: Make a dictionary containing three major rivers and the country each river runs through. One key-value pair might be 'nile': 'egypt'.</p> <ul> <li>Use a loop to print a sentence about each river, such as The Nile runs through Egypt.</li> <li>Use a loop to print the name of each river included in the dictionary.</li> <li>Use a loop to print the name of each country included in the dictionary.</li> </ul>"},{"location":"Notebooks/lab5/#question-6","title":"Question 6\u00b6","text":"<p>Cities: Make a dictionary called <code>cities</code>. Use the names of three cities as keys in your dictionary. Create a dictionary of information about each city and include the country that the city is in, its approximate population, and one fact about that city. The keys for each city\u2019s dictionary should be something like <code>country</code>, <code>population</code>, and <code>fact</code>. Print the name of each city and all of the information you have stored about it.</p>"},{"location":"Notebooks/lab5/#question-7","title":"Question 7\u00b6","text":"<p>Rental Car: Write a program that asks the user what kind of rental car they would like. Print a message about that car, such as \u201cLet me see if I can find you a Subaru.\u201d</p>"},{"location":"Notebooks/lab5/#question-8","title":"Question 8\u00b6","text":"<p>Restaurant Seating: Write a program that asks the user how many people are in their dinner group. If the answer is more than eight, print a message saying they\u2019ll have to wait for a table. Otherwise, report that their table is ready.</p>"},{"location":"Notebooks/lab5/#question-9","title":"Question 9\u00b6","text":"<p>Multiples of Ten: Ask the user for a number, and then report whether the number is a multiple of 10 or not.</p>"},{"location":"Notebooks/lab5/#question-10","title":"Question 10\u00b6","text":"<p>Pizza Toppings: Write a loop that prompts the user to enter a series of pizza toppings until they enter a 'quit' value. As they enter each topping, print a message saying you\u2019ll add that topping to their pizza.</p>"},{"location":"Notebooks/lab5/#question-11","title":"Question 11\u00b6","text":"<p>Message: Write a function called <code>display_message()</code> that prints one sentence telling everyone what you are learning about in this chapter. Call the function, and make sure the message displays correctly.</p>"},{"location":"Notebooks/lab5/#question-12","title":"Question 12\u00b6","text":"<p>Favorite Book: Write a function called <code>favorite_book()</code> that accepts one parameter, title. The function should print a message, such as <code>One of my favorite books is Alice in Wonderland</code>. Call the function, making sure to include a book title as an argument in the function call.</p>"},{"location":"Notebooks/lab5/#question-13","title":"Question 13\u00b6","text":"<p>T-Shirt: Write a function called <code>make_shirt()</code> that accepts a size and the text of a message that should be printed on the shirt. The function should print a sentence summarizing the size of the shirt and the message printed on it.</p> <p>Call the function once using positional arguments to make a shirt. Call the function a second time using keyword arguments.</p>"},{"location":"Notebooks/lab5/#question-14","title":"Question 14\u00b6","text":"<p>Large Shirts: Modify the <code>make_shirt()</code> function so that shirts are large by default with a message that reads I love Python. Make a large shirt and a medium shirt with the default message, and a shirt of any size with a different message.</p>"},{"location":"Notebooks/lab5/#question-15","title":"Question 15\u00b6","text":"<p>Cities: Write a function called <code>describe_city()</code> that accepts the name of a city and its country. The function should print a simple sentence, such as <code>Reykjavik is in Iceland</code>. Give the parameter for the country a default value. Call your function for three different cities, at least one of which is not in the default country.</p>"},{"location":"Notebooks/lab5/#question-16","title":"Question 16\u00b6","text":"<p>City Names: Write a function called <code>city_country()</code> that takes in the name of a city and its country. The function should return a string formatted like this:</p> <pre>Santiago, Chile\n</pre> <p>Call your function with at least three city-country pairs, and print the values that are returned.</p>"},{"location":"Notebooks/lab5/#question-17","title":"Question 17\u00b6","text":"<p>Album: Write a function called <code>make_album()</code> that builds a dictionary describing a music album. The function should take in an artist name and an album title, and it should return a dictionary containing these two pieces of information. Use the function to make three dictionaries representing different albums. Print each return value to show that the dictionaries are storing the album information correctly.</p> <p>Use None to add an optional parameter to make_album() that allows you to store the number of songs on an album. If the calling line includes a value for the number of songs, add that value to the album\u2019s dictionary. Make at least one new function call that includes the number of songs on an album.</p>"},{"location":"Notebooks/lab5/#question-18","title":"Question 18\u00b6","text":"<p>User Albums: Start with your program from Question 17. Write a <code>while</code> loop that allows users to enter an album\u2019s artist and title. Once you have that information, call <code>make_album()</code> with the user\u2019s input and print the dictionary that\u2019s created. Be sure to include a quit value in the <code>while</code> loop.</p>"},{"location":"Notebooks/lab5/#question-19","title":"Question 19\u00b6","text":"<p>Messages: Make a list containing a series of short text messages. Pass the list to a function called <code>show_messages()</code>, which prints each text message.</p>"},{"location":"Notebooks/lab5/#question-20","title":"Question 20\u00b6","text":"<p>Sending Messages: Start with a copy of your program from Question 19. Write a function called <code>send_messages()</code> that prints each text message and moves each message to a new list called <code>sent_messages</code> as it\u2019s printed. After calling the function, print both of your lists to make sure the messages were moved correctly.</p>"},{"location":"Notebooks/lab5/#question-21","title":"Question 21\u00b6","text":"<p>Learning Python: Open a blank file in your text editor and write a few lines summarizing what you\u2019ve learned about Python so far. Start each line with the phrase In Python you can. . .. Save the file as learning_python.txt in the same directory as your exercises from this chapter. Write a program that reads the file and prints what you wrote three times. Print the contents once by reading in the entire file, once by looping over the file object, and once by storing the lines in a list and then working with them outside the with block.</p>"},{"location":"Notebooks/lab5/#question-22","title":"Question 22\u00b6","text":"<p>Learning C: You can use the replace() method to replace any word in a string with a different word. Here\u2019s a quick example showing how to replace 'dog' with 'cat' in a sentence:</p> <pre>message = \"I really like dogs.\"\nmessage.replace('dog', 'cat')\n'I really like cats.'\n</pre> <p>Read in each line from the file you just created, learning_python.txt, and replace the word Python with the name of another language, such as C. Print each modified line to the screen.</p>"},{"location":"Notebooks/lab5/#question-23","title":"Question 23\u00b6","text":"<p>Guest: Write a program that prompts the user for their name. When they respond, write their name to a file called guest.txt.</p>"},{"location":"Notebooks/lab5/#question-24","title":"Question 24\u00b6","text":"<p>Guest Book: Write a while loop that prompts users for their name. When they enter their name, print a greeting to the screen and add a line recording their visit in a file called guest_book.txt. Make sure each entry appears on a new line in the file.</p>"},{"location":"Notebooks/lab5/#question-25","title":"Question 25\u00b6","text":"<p>Programming Poll: Write a while loop that asks people why they like programming. Each time someone enters a reason, add their reason to a file that stores all the responses.</p>"},{"location":"Notebooks/lab5/#question-26","title":"Question 26\u00b6","text":"<p>Addition: One common problem when prompting for numerical input occurs when people provide text instead of numbers. When you try to convert the input to an int, you\u2019ll get a ValueError. Write a program that prompts for two numbers. Add them together and print the result. Catch the ValueError if either input value is not a number, and print a friendly error message. Test your program by entering two numbers and then by entering some text instead of a number.</p>"},{"location":"Notebooks/lab5/#question-27","title":"Question 27\u00b6","text":"<p>Addition Calculator: Wrap your code from Question 26 in a while loop so the user can continue entering numbers even if they make a mistake and enter text instead of a number.</p>"},{"location":"Notebooks/lab5/#question-28","title":"Question 28\u00b6","text":"<p>Cats and Dogs: Make two files, cats.txt and dogs.txt. Store at least three names of cats in the first file and three names of dogs in the second file. Write a program that tries to read these files and print the contents of the file to the screen. Wrap your code in a <code>try-except</code> block to catch the <code>FileNotFound</code> error, and print a friendly message if a file is missing. Move one of the files to a different location on your system, and make sure the code in the <code>except</code> block executes properly.</p>"},{"location":"Notebooks/lab5/#question-29","title":"Question 29\u00b6","text":"<p>Silent Cats and Dogs: Modify your except block in Question 28 to fail silently if either file is missing.</p>"},{"location":"Notebooks/lab5/#question-30","title":"Question 30\u00b6","text":"<p>Common Words: Visit Project Gutenberg (https://gutenberg.org/) and find a few texts you\u2019d like to analyze. Download the text files for these works, or copy the raw text from your browser into a text file on your computer. You can use the <code>count()</code> method to find out how many times a word or phrase appears in a string. For example, the following code counts the number of times 'row' appears in a string:</p>"},{"location":"examples/csv/","title":"Csv","text":"In\u00a0[1]: Copied! <pre>import geojp\n</pre> import geojp In\u00a0[2]: Copied! <pre>from geojp import utils\n</pre> from geojp import utils In\u00a0[3]: Copied! <pre>csv = \"https://github.com/opengeos/datasets/releases/download/us/us_states.csv\"\ndf = utils.csv_to_df(csv)\ndf\n</pre> csv = \"https://github.com/opengeos/datasets/releases/download/us/us_states.csv\" df = utils.csv_to_df(csv) df Out[3]: id name 0 AL Alabama 1 AK Alaska 2 AZ Arizona 3 AR Arkansas 4 CA California 5 CO Colorado 6 CT Connecticut 7 DE Delaware 8 FL Florida 9 GA Georgia 10 HI Hawaii 11 ID Idaho 12 IL Illinois 13 IN Indiana 14 IA Iowa 15 KS Kansas 16 KY Kentucky 17 LA Louisiana 18 ME Maine 19 MD Maryland 20 MA Massachusetts 21 MI Michigan 22 MN Minnesota 23 MS Mississippi 24 MO Missouri 25 MT Montana 26 NE Nebraska 27 NV Nevada 28 NH New Hampshire 29 NJ New Jersey 30 NM New Mexico 31 NY New York 32 NC North Carolina 33 ND North Dakota 34 OH Ohio 35 OK Oklahoma 36 OR Oregon 37 PA Pennsylvania 38 RI Rhode Island 39 SC South Carolina 40 SD South Dakota 41 TN Tennessee 42 TX Texas 43 UT Utah 44 VT Vermont 45 VA Virginia 46 WA Washington 47 WV West Virginia 48 WI Wisconsin 49 WY Wyoming 50 DC District of Columbia In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/heatmap/","title":"Heatmap","text":"<p>Creating heat maps from csv</p> In\u00a0[1]: Copied! <pre># !pip install geojp\n</pre> # !pip install geojp <p>Specify the file path to the CSV. It can either be a file locally or on the Internet.</p> In\u00a0[2]: Copied! <pre>filepath = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\"\n</pre> filepath = \"https://raw.githubusercontent.com/opengeos/leafmap/master/examples/data/us_cities.csv\" <p>Use the ipyleaflet plotting backend.</p> In\u00a0[3]: Copied! <pre>import geojp.geojp as geojp\n</pre> import geojp.geojp as geojp <p>Specify the <code>latitude</code>, <code>longitude</code>, and <code>value</code> columns to create the heat map.</p> In\u00a0[4]: Copied! <pre>m = geojp.Map()\nm.add_heatmap(\n    filepath,\n    latitude=\"latitude\",\n    longitude=\"longitude\",\n    value=\"pop_max\",\n    name=\"Heat map\",\n    radius=20,\n)\nm\n</pre> m = geojp.Map() m.add_heatmap(     filepath,     latitude=\"latitude\",     longitude=\"longitude\",     value=\"pop_max\",     name=\"Heat map\",     radius=20, ) m Out[4]: <pre>Map(center=[20, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out_text\u2026</pre>"},{"location":"examples/image/","title":"Image","text":"In\u00a0[3]: Copied! <pre>import geojp\n</pre> import geojp In\u00a0[4]: Copied! <pre>m = geojp.Map()\n\nurl = \"https://oyster.ignimgs.com/wordpress/stg.ign.com/2013/04/JurassicPark_040413_1600.jpg?width=1920\"\nbounds = ((45, -80), (30,-120))\nm.add_image(url, bounds)\nm\n</pre> m = geojp.Map()  url = \"https://oyster.ignimgs.com/wordpress/stg.ign.com/2013/04/JurassicPark_040413_1600.jpg?width=1920\" bounds = ((45, -80), (30,-120)) m.add_image(url, bounds) m Out[4]: <pre>Map(center=[20, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out_text\u2026</pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[\u00a0]: Copied! <pre>print('Hello World!')\n</pre> print('Hello World!')"},{"location":"examples/ipyleaflet/","title":"Ipyleaflet","text":"In\u00a0[1]: Copied! <pre>import geojp\n</pre> import geojp In\u00a0[2]: Copied! <pre>from ipyleaflet import basemaps\n</pre> from ipyleaflet import basemaps In\u00a0[3]: Copied! <pre>eval('basemaps.OpenTopoMap').build_url()\n</pre> eval('basemaps.OpenTopoMap').build_url() Out[3]: <pre>'https://a.tile.opentopomap.org/{z}/{x}/{y}.png'</pre> In\u00a0[4]: Copied! <pre>import leafmap\n</pre> import leafmap In\u00a0[5]: Copied! <pre>m = leafmap.Map()\nm\n</pre> m = leafmap.Map() m Out[5]: <pre>Map(center=[20, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out_text\u2026</pre> In\u00a0[6]: Copied! <pre>m = geojp.Map()\nm.add_basemap(\"OpenTopoMap\")\n#m.add_layer_control(position=\"topleft\")\nm\n</pre> m = geojp.Map() m.add_basemap(\"OpenTopoMap\") #m.add_layer_control(position=\"topleft\") m Out[6]: <pre>Map(center=[20, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out_text\u2026</pre> In\u00a0[7]: Copied! <pre>m.layers\n</pre> m.layers Out[7]: <pre>(TileLayer(attribution='&amp;copy; &lt;a href=\"https://www.openstreetmap.org/copyright\"&gt;OpenStreetMap&lt;/a&gt; contributors', base=True, max_zoom=19, min_zoom=1, name='OpenStreetMap.Mapnik', options=['attribution', 'bounds', 'detect_retina', 'max_native_zoom', 'max_zoom', 'min_native_zoom', 'min_zoom', 'no_wrap', 'tile_size', 'tms', 'zoom_offset'], url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'),\n TileLayer(name='OpenTopoMap', options=['attribution', 'bounds', 'detect_retina', 'max_native_zoom', 'max_zoom', 'min_native_zoom', 'min_zoom', 'no_wrap', 'tile_size', 'tms', 'zoom_offset'], url='https://a.tile.opentopomap.org/{z}/{x}/{y}.png'))</pre> In\u00a0[8]: Copied! <pre>from ipyleaflet import basemaps\n</pre> from ipyleaflet import basemaps"},{"location":"examples/map/","title":"Map","text":"<p>Creating Dropdown List for Basemap Selection</p> In\u00a0[1]: Copied! <pre>import geojp\n</pre> import geojp In\u00a0[2]: Copied! <pre>import ipywidgets as widgets\nfrom ipyleaflet import WidgetControl\n</pre> import ipywidgets as widgets from ipyleaflet import WidgetControl In\u00a0[3]: Copied! <pre>import geojp\n</pre> import geojp In\u00a0[12]: Copied! <pre>m= geojp.Map()\nm.add_basemap_gui()\nm\n</pre> m= geojp.Map() m.add_basemap_gui() m  Out[12]: <pre>Map(center=[20, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out_text\u2026</pre> In\u00a0[5]: Copied! <pre>def handle_interaction(**kwargs):\n    latlon = kwargs.get(\"coordinates\")\n    # latlon = [round(x, 2) for x in latlon]\n    if kwargs.get(\"type\") == \"click\":\n        with output:\n            output.clear_output()\n            print(\"You clicked at: {}\".format(latlon))\n\n\nm.on_interaction(handle_interaction)\n</pre> def handle_interaction(**kwargs):     latlon = kwargs.get(\"coordinates\")     # latlon = [round(x, 2) for x in latlon]     if kwargs.get(\"type\") == \"click\":         with output:             output.clear_output()             print(\"You clicked at: {}\".format(latlon))   m.on_interaction(handle_interaction) In\u00a0[6]: Copied! <pre>button = widgets.Button(\n    icon=\"times\",\n    button_style=\"primary\"\n)\nbutton.layout.width = \"35px\"\nbutton\n</pre> button = widgets.Button(     icon=\"times\",     button_style=\"primary\" ) button.layout.width = \"35px\" button Out[6]: <pre>Button(button_style='primary', icon='times', layout=Layout(width='35px'), style=ButtonStyle())</pre> In\u00a0[7]: Copied! <pre>dropdown = widgets.Dropdown(\n    options=[\"OpenStreetMap\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.NatGeoWorldMap\",\"CartoDB.DarkMatter\"],\n    value=\"OpenStreetMap\",\n)\ndropdown.layout.width = \"150px\"\ndropdown\n</pre> dropdown = widgets.Dropdown(     options=[\"OpenStreetMap\", \"OpenTopoMap\", \"Esri.WorldImagery\", \"Esri.NatGeoWorldMap\",\"CartoDB.DarkMatter\"],     value=\"OpenStreetMap\", ) dropdown.layout.width = \"150px\" dropdown Out[7]: <pre>Dropdown(layout=Layout(width='150px'), options=('OpenStreetMap', 'OpenTopoMap', 'Esri.WorldImagery', 'Esri.Nat\u2026</pre> In\u00a0[8]: Copied! <pre>box = widgets.HBox([dropdown, button])\nbox\n</pre> box = widgets.HBox([dropdown, button]) box Out[8]: <pre>HBox(children=(Dropdown(layout=Layout(width='150px'), options=('OpenStreetMap', 'OpenTopoMap', 'Esri.WorldImag\u2026</pre> In\u00a0[9]: Copied! <pre>m= geojp.Map()\nm\n</pre> m= geojp.Map() m  Out[9]: <pre>Map(center=[20, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out_text\u2026</pre> In\u00a0[10]: Copied! <pre>m.add_widget(box)\n</pre> m.add_widget(box) In\u00a0[11]: Copied! <pre>#m.controls = m.controls[:-1]\n</pre> #m.controls = m.controls[:-1]"},{"location":"examples/random/","title":"Random","text":"In\u00a0[1]: Copied! <pre>import random\n</pre> import random In\u00a0[3]: Copied! <pre>random.random()\n</pre> random.random() Out[3]: <pre>0.044150750842981146</pre>"},{"location":"examples/raster/","title":"Raster","text":"In\u00a0[16]: Copied! <pre>from ipyleaflet import Map, ImageOverlay\n\nm = Map(center=(25, -115), zoom=4)\n\nimage = ImageOverlay(\n    url=\"https://i.imgur.com/06Q1fSz.png\",\n    bounds=((13, -130), (32, -100)),\n)\n\nm.add(image)\nm\n</pre> from ipyleaflet import Map, ImageOverlay  m = Map(center=(25, -115), zoom=4)  image = ImageOverlay(     url=\"https://i.imgur.com/06Q1fSz.png\",     bounds=((13, -130), (32, -100)), )  m.add(image) m Out[16]: <pre>Map(center=[25, -115], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out_t\u2026</pre> In\u00a0[17]: Copied! <pre>import geojp\n</pre> import geojp In\u00a0[18]: Copied! <pre>m = geojp.Map()\n\nurl = \"https://oyster.ignimgs.com/wordpress/stg.ign.com/2013/04/JurassicPark_040413_1600.jpg?width=1920\"\nbounds = ((45, -80), (30,-120))\nm.add_image(url, bounds)\nm\n</pre> m = geojp.Map()  url = \"https://oyster.ignimgs.com/wordpress/stg.ign.com/2013/04/JurassicPark_040413_1600.jpg?width=1920\" bounds = ((45, -80), (30,-120)) m.add_image(url, bounds) m Out[18]: <pre>Map(center=[20, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out_text\u2026</pre> In\u00a0[19]: Copied! <pre>from localtileserver import TileClient, get_leaflet_tile_layer, examples\nfrom ipyleaflet import Map\n\n# Create a TileClient from a raster file\n# client = TileClient('srtm90.tif')\nclient = TileClient(\n    \"https://github.com/opengeos/datasets/releases/download/raster/srtm90.tif\"\n)\n# client = TileClient('https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif')\n# client = examples.get_san_francisco()  # use example data\n\n# Create ipyleaflet TileLayer from that server\nt = get_leaflet_tile_layer(client)\n# Create ipyleaflet map, add tile layer, and display\nm = Map()\nm.add(t)\nm.center = client.center()\nm.zoom = client.default_zoom\nm\n</pre> from localtileserver import TileClient, get_leaflet_tile_layer, examples from ipyleaflet import Map  # Create a TileClient from a raster file # client = TileClient('srtm90.tif') client = TileClient(     \"https://github.com/opengeos/datasets/releases/download/raster/srtm90.tif\" ) # client = TileClient('https://opendata.digitalglobe.com/events/california-fire-2020/pre-event/2018-02-16/pine-gulch-fire20/1030010076004E00.tif') # client = examples.get_san_francisco()  # use example data  # Create ipyleaflet TileLayer from that server t = get_leaflet_tile_layer(client) # Create ipyleaflet map, add tile layer, and display m = Map() m.add(t) m.center = client.center() m.zoom = client.default_zoom m Out[19]: <pre>Map(center=[37.630466999999996, -119.03021849999999], controls=(ZoomControl(options=['position', 'zoom_in_text\u2026</pre> In\u00a0[20]: Copied! <pre>import geojp\n</pre> import geojp In\u00a0[21]: Copied! <pre>m = geojp.Map(add_layer_control=False)\ndata = \"https://github.com/opengeos/datasets/releases/download/raster/srtm90.tif\"\nm.add_raster(data, cmap=\"terrain\", name=\"DEM\")\nm\n</pre> m = geojp.Map(add_layer_control=False) data = \"https://github.com/opengeos/datasets/releases/download/raster/srtm90.tif\" m.add_raster(data, cmap=\"terrain\", name=\"DEM\") m <pre>c:\\anaconda312\\anaconda3\\envs\\geo\\Lib\\site-packages\\localtileserver\\widgets.py:89: UserWarning: The `cmap` keyword argument is deprecated. Please use `colormap` instead.\n  warnings.warn(\n</pre> Out[21]: <pre>Map(center=[37.630466999999996, -119.03021849999999], controls=(ZoomControl(options=['position', 'zoom_in_text\u2026</pre> In\u00a0[22]: Copied! <pre>m.layers[0].interact(opacity=(0.0, 1.0, 0.1))\n</pre> m.layers[0].interact(opacity=(0.0, 1.0, 0.1)) Out[22]: <pre>Box(children=(FloatSlider(value=1.0, description='opacity', max=1.0),))</pre> In\u00a0[23]: Copied! <pre>m.layers\n</pre> m.layers Out[23]: <pre>(TileLayer(attribution='&amp;copy; &lt;a href=\"https://www.openstreetmap.org/copyright\"&gt;OpenStreetMap&lt;/a&gt; contributors', base=True, max_zoom=19, min_zoom=1, name='OpenStreetMap.Mapnik', options=['attribution', 'bounds', 'detect_retina', 'max_native_zoom', 'max_zoom', 'min_native_zoom', 'min_zoom', 'no_wrap', 'tile_size', 'tms', 'zoom_offset'], url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'),\n BoundTileLayer(attribution=\"Raster file served by &lt;a href='https://github.com/banesullivan/localtileserver' target='_blank'&gt;localtileserver&lt;/a&gt;.\", bounds=((36.634011, -120.755927), (38.626923, -117.30451)), max_native_zoom=30, max_zoom=30, name='DEM', options=['attribution', 'bounds', 'detect_retina', 'max_native_zoom', 'max_zoom', 'min_native_zoom', 'min_zoom', 'no_wrap', 'tile_size', 'tms', 'zoom_offset'], show_loading=True, url='http://localhost:55854/api/tiles/{z}/{x}/{y}.png?&amp;filename=%2Fvsicurl%3Furl%3Dhttps%253A%252F%252Fgithub.com%252Fopengeos%252Fdatasets%252Freleases%252Fdownload%252Fraster%252Fsrtm90.tif%26use_head%3Dno%26list_dir%3Dno&amp;colormap=terrain'))</pre> In\u00a0[24]: Copied! <pre>client.center()\n</pre> client.center() Out[24]: <pre>(37.630466999999996, -119.03021849999999)</pre> In\u00a0[25]: Copied! <pre>client.default_zoom\n</pre> client.default_zoom Out[25]: <pre>7</pre> In\u00a0[26]: Copied! <pre>m.layers\n</pre> m.layers Out[26]: <pre>(TileLayer(attribution='&amp;copy; &lt;a href=\"https://www.openstreetmap.org/copyright\"&gt;OpenStreetMap&lt;/a&gt; contributors', base=True, max_zoom=19, min_zoom=1, name='OpenStreetMap.Mapnik', options=['attribution', 'bounds', 'detect_retina', 'max_native_zoom', 'max_zoom', 'min_native_zoom', 'min_zoom', 'no_wrap', 'tile_size', 'tms', 'zoom_offset'], url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'),\n BoundTileLayer(attribution=\"Raster file served by &lt;a href='https://github.com/banesullivan/localtileserver' target='_blank'&gt;localtileserver&lt;/a&gt;.\", bounds=((36.634011, -120.755927), (38.626923, -117.30451)), max_native_zoom=30, max_zoom=30, name='DEM', options=['attribution', 'bounds', 'detect_retina', 'max_native_zoom', 'max_zoom', 'min_native_zoom', 'min_zoom', 'no_wrap', 'tile_size', 'tms', 'zoom_offset'], show_loading=True, url='http://localhost:55854/api/tiles/{z}/{x}/{y}.png?&amp;filename=%2Fvsicurl%3Furl%3Dhttps%253A%252F%252Fgithub.com%252Fopengeos%252Fdatasets%252Freleases%252Fdownload%252Fraster%252Fsrtm90.tif%26use_head%3Dno%26list_dir%3Dno&amp;colormap=terrain'))</pre>"},{"location":"examples/timeslider/","title":"Timeslider","text":"<p>Visualizing river changes images interactively with a time slider</p> In\u00a0[1]: Copied! <pre># %pip install -U geojp\n</pre> # %pip install -U geojp In\u00a0[2]: Copied! <pre>import geojp\n</pre> import geojp In\u00a0[3]: Copied! <pre>from geojp import geojp\n</pre> from geojp import geojp In\u00a0[4]: Copied! <pre>#url = \"https://open.gishub.org/data/landsat/timeseries.zip\"\n#leafmap.download_file(url)\n</pre> #url = \"https://open.gishub.org/data/landsat/timeseries.zip\" #leafmap.download_file(url) <p>Visualize time series images interactively with a time slider. You can pass a list of file paths or a string representing a directory to the <code>add_time_slider</code> function.</p> In\u00a0[5]: Copied! <pre>m = geojp.Map()\nimages = \"landsat\"\nm.add_time_slider(\n    images,\n    time_interval=0.5,\n    position=\"bottomright\",\n    band=[1, 2, 3],\n    zoom_to_layer=True,\n)\nm\n</pre> m = geojp.Map() images = \"landsat\" m.add_time_slider(     images,     time_interval=0.5,     position=\"bottomright\",     band=[1, 2, 3],     zoom_to_layer=True, ) m Out[5]: <pre>Map(center=[20, 0], controls=(ZoomControl(options=['position', 'zoom_in_text', 'zoom_in_title', 'zoom_out_text\u2026</pre>"},{"location":"labs/lab4/","title":"Lab4","text":"In\u00a0[\u00a0]: Copied! <pre>from datetime import datetime\n\nnow = datetime.now()\nprint(f\"Submitted time: {now}\")\n</pre> from datetime import datetime  now = datetime.now() print(f\"Submitted time: {now}\") In\u00a0[97]: Copied! <pre>intro = \"Hello Professor! This is Brycen Harris. I look forward to learning more about code in your class\"\nprint(intro)\n</pre> intro = \"Hello Professor! This is Brycen Harris. I look forward to learning more about code in your class\" print(intro) <pre>Hello Professor! This is Brycen Harris. I look forward to learning more about code in your class\n</pre> In\u00a0[4]: Copied! <pre>UserName = \"Brycen Harris\"\n\nprint(UserName.lower())\n\nprint(UserName.upper())\n\nprint(UserName.title())\n</pre> UserName = \"Brycen Harris\"  print(UserName.lower())  print(UserName.upper())  print(UserName.title()) <pre>brycen harris\nBRYCEN HARRIS\nBrycen Harris\n</pre> In\u00a0[5]: Copied! <pre>quote = \"Mark 16:16 Whoever believes and is baptized will be saved; whoever does not believe will be condemned.\"\n\nauthor = \"Jesus Christ\"\n\nprint(f\"{author} promised in, \\\"{quote}\\\"\")\n</pre> quote = \"Mark 16:16 Whoever believes and is baptized will be saved; whoever does not believe will be condemned.\"  author = \"Jesus Christ\"  print(f\"{author} promised in, \\\"{quote}\\\"\") <pre>Jesus Christ promised in, \"Mark 16:16 Whoever believes and is baptized will be saved; whoever does not believe will be condemned.\"\n</pre> In\u00a0[96]: Copied! <pre>NameWithSpace = \"\\t\\tBrycen Harris\\n\"\n\nprint(NameWithSpace)\n\nprint(NameWithSpace.lstrip())\n\nprint(NameWithSpace.rstrip())\n\nprint(NameWithSpace.strip())\n</pre> NameWithSpace = \"\\t\\tBrycen Harris\\n\"  print(NameWithSpace)  print(NameWithSpace.lstrip())  print(NameWithSpace.rstrip())  print(NameWithSpace.strip()) <pre>\t\tBrycen Harris\n\nBrycen Harris\n\n\t\tBrycen Harris\nBrycen Harris\n</pre> In\u00a0[10]: Copied! <pre>FriendsNames = [\"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]\n\nfor FriendsNames in FriendsNames:\n\n    print (FriendsNames)\n</pre> FriendsNames = [\"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]  for FriendsNames in FriendsNames:      print (FriendsNames) <pre>Ryan\nJake\nTrevor\nRylee\n</pre> In\u00a0[13]: Copied! <pre>vehicle = [\"Ninja 600\", \"3000GT\", \"Jeep Wrangler\"]\n\nfor vehicle in vehicle:\n    \n    print(f\"I would like to own a {vehicle}.\\n\")\n</pre> vehicle = [\"Ninja 600\", \"3000GT\", \"Jeep Wrangler\"]  for vehicle in vehicle:          print(f\"I would like to own a {vehicle}.\\n\") <pre>I would like to own a Ninja 600.\n\nI would like to own a 3000GT.\n\nI would like to own a Jeep Wrangler.\n\n</pre> In\u00a0[19]: Copied! <pre>pizzas = [\"Pepperoni\",\"Meat Lovers\", \"Cheese\"]\n\nprint(\"List of favorite pizzas:\")\n\nfor pizza in pizzas:\n\n    print(pizza)\n\nprint(\"Pizzas I like:\")\n\nfor pizza in pizzas:\n\n    print(\"I like\", pizza, \"pizza.\")\n</pre> pizzas = [\"Pepperoni\",\"Meat Lovers\", \"Cheese\"]  print(\"List of favorite pizzas:\")  for pizza in pizzas:      print(pizza)  print(\"Pizzas I like:\")  for pizza in pizzas:      print(\"I like\", pizza, \"pizza.\") <pre>List of favorite pizzas:\nPepperoni\nMeat Lovers\nCheese\nPizzas I like:\nI like Pepperoni pizza.\nI like Meat Lovers pizza.\nI like Cheese pizza.\n</pre> <p>Add a line at the end of your program, outside the for loop, that states how much you like pizza. The output should consist of three or more lines about the kinds of pizza you like and then an additional sentence, such as I really love pizza!</p> In\u00a0[22]: Copied! <pre>pizzas = [\"Pepperoni\", \"Meat Lovers\", \"Cheese\"]\n\nfor pizza in pizzas:\n    \n    print(f\"I love eating {pizza} pizza.\\n\")\n\nprint(\"I really enjoy eating pizza!\")\n</pre> pizzas = [\"Pepperoni\", \"Meat Lovers\", \"Cheese\"]  for pizza in pizzas:          print(f\"I love eating {pizza} pizza.\\n\")  print(\"I really enjoy eating pizza!\") <pre>I love eating Pepperoni pizza.\n\nI love eating Meat Lovers pizza.\n\nI love eating Cheese pizza.\n\nI really enjoy eating pizza!\n</pre> In\u00a0[52]: Copied! <pre>pets = [\"Dog\", \"Cat\", \"snake\", \"Turtle\"]\n\nprint(\"Type of pets:\")\n\nfor type in pets:\n\n    print(type)\n\nprint (\"\")\n\nprint(\"What would make a good pet:\")\n\nfor type in pets:\n\n    print(f\"A {type} would make a great pet.\")\n</pre> pets = [\"Dog\", \"Cat\", \"snake\", \"Turtle\"]  print(\"Type of pets:\")  for type in pets:      print(type)  print (\"\")  print(\"What would make a good pet:\")  for type in pets:      print(f\"A {type} would make a great pet.\") <pre>Type of pets:\nDog\nCat\nsnake\nTurtle\n\nWhat would make a good pet:\nA Dog would make a great pet.\nA Cat would make a great pet.\nA snake would make a great pet.\nA Turtle would make a great pet.\n</pre> <p>Add a line at the end of your program stating what these animals have in common. You could print a sentence such as Any of these animals would make a great pet!</p> In\u00a0[54]: Copied! <pre>print(\"All of these animals popular options types of pets\")\n</pre> print(\"All of these animals popular options types of pets\") <pre>All of these animals popular options types of pets\n</pre> In\u00a0[73]: Copied! <pre>numbers = list(range(1, 101))\n\n#print(numbers)\n\nprint(\"Minimum number:\", min(numbers))\n\nprint(\"Maximum number:\", max(numbers))\n\nprint(\"Sum of the numbers:\", sum(numbers))\n</pre> numbers = list(range(1, 101))  #print(numbers)  print(\"Minimum number:\", min(numbers))  print(\"Maximum number:\", max(numbers))  print(\"Sum of the numbers:\", sum(numbers))  <pre>Minimum number: 1\nMaximum number: 100\nSum of the numbers: 5050\n</pre> In\u00a0[68]: Copied! <pre>OddNumbers = list(range(1, 21, 2))\n\nOddNumbers\n</pre> OddNumbers = list(range(1, 21, 2))  OddNumbers Out[68]: <pre>[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</pre> In\u00a0[72]: Copied! <pre>multiples = [number for number in range(3, 31, 3)]\n\nprint(\"Here are the multiples of 3 up to 30:\")\n\nfor number in multiples:\n    \n    print(number)\n</pre> multiples = [number for number in range(3, 31, 3)]  print(\"Here are the multiples of 3 up to 30:\")  for number in multiples:          print(number) <pre>Here are the multiples of 3 up to 30:\n3\n6\n9\n12\n15\n18\n21\n24\n27\n30\n</pre> In\u00a0[99]: Copied! <pre>cubes = [number ** 3 for number in range(1, 11)]\n\nprint(cubes)\n</pre> cubes = [number ** 3 for number in range(1, 11)]  print(cubes) <pre>[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n</pre> In\u00a0[75]: Copied! <pre>vehicle = [\"Ninja 600\", \"3000GT\", \"Jeep Wrangler\", \"Tacoma\", \"LandCrusier\"]\n\nprint('The first three items in the list are:', (vehicle[:3]))\n</pre> vehicle = [\"Ninja 600\", \"3000GT\", \"Jeep Wrangler\", \"Tacoma\", \"LandCrusier\"]  print('The first three items in the list are:', (vehicle[:3])) <pre>The first three items in the list are: ['Ninja 600', '3000GT', 'Jeep Wrangler']\n</pre> <p>Print the message Three items from the middle of the list are:. Use a slice to print three items from the middle of the list.</p> In\u00a0[80]: Copied! <pre>MiddleThree = len(vehicle) // 2 - 1\n\nprint('The three items from the middle in the list are:', (vehicle[MiddleThree:MiddleThree + 3]))\n</pre> MiddleThree = len(vehicle) // 2 - 1  print('The three items from the middle in the list are:', (vehicle[MiddleThree:MiddleThree + 3]))  <pre>The three items from the middle in the list are: ['3000GT', 'Jeep Wrangler', 'Tacoma']\n</pre> <p>Print the message The last three items in the list are:. Use a slice to print the last three items in the list.</p> In\u00a0[81]: Copied! <pre>print('The last three items in the list are:', (vehicle[-3:]))\n</pre> print('The last three items in the list are:', (vehicle[-3:])) <pre>The last three items in the list are: ['Jeep Wrangler', 'Tacoma', 'LandCrusier']\n</pre> In\u00a0[82]: Copied! <pre>AvailableFoods = (\"Burger\", \"Salad\", \"Pasta\", \"Ribs\")\n\nprint(\"Foods available at this restaurant:\")\n\nfor option in AvailableFoods:\n\n    print(option)\n</pre> AvailableFoods = (\"Burger\", \"Salad\", \"Pasta\", \"Ribs\")  print(\"Foods available at this restaurant:\")  for option in AvailableFoods:      print(option) <pre>Foods available at this restaurant:\nBurger\nSalad\nPasta\nRibs\n</pre> <p>The restaurant changes its menu, replacing two of the items with different foods. Add a line that rewrites the tuple, and then use a for loop to print each of the items on the revised menu.</p> In\u00a0[84]: Copied! <pre>OriginalAvailableFoods = (\"Burger\", \"Salad\", \"Pasta\", \"Ribs\")\n\nprint(\"Original Menu:\")\nfor option in OriginalAvailableFoods:\n    print(option)\n\nNewAvailableFoods = (\"Soup\", \"Pizza\", \"Sandwich\", \"Sushi\")\n\nprint(\"\")\n\nprint(\"New Menu:\")\nfor option in NewAvailableFoods:\n    print(option)\n</pre> OriginalAvailableFoods = (\"Burger\", \"Salad\", \"Pasta\", \"Ribs\")  print(\"Original Menu:\") for option in OriginalAvailableFoods:     print(option)  NewAvailableFoods = (\"Soup\", \"Pizza\", \"Sandwich\", \"Sushi\")  print(\"\")  print(\"New Menu:\") for option in NewAvailableFoods:     print(option) <pre>Original Menu:\nBurger\nSalad\nPasta\nRibs\n\nNew Menu:\nSoup\nPizza\nSandwich\nSushi\n</pre> In\u00a0[86]: Copied! <pre>#Pass\nalien_color = \"green\"\n\nif alien_color == \"green\":\n    print(\"Congratulations! You just earned 5 points.\")\nelse:\n    print(\"You did not earn any points.\")\n\n#Fail\nalien_color = \"red\"\n\nif alien_color == \"green\":\n    print(\"Congratulations! You just earned 5 points.\")\nelse:\n    print(\"You did not earn any points.\")\n</pre> #Pass alien_color = \"green\"  if alien_color == \"green\":     print(\"Congratulations! You just earned 5 points.\") else:     print(\"You did not earn any points.\")  #Fail alien_color = \"red\"  if alien_color == \"green\":     print(\"Congratulations! You just earned 5 points.\") else:     print(\"You did not earn any points.\")  <pre>Congratulations! You just earned 5 points.\nYou did not earn any points.\n</pre> In\u00a0[87]: Copied! <pre>age = 22\n\nif age &lt; 2:\n\n    print(\"The person is a baby.\")\n\nelif age &lt; 4:\n\n    print(\"The person is a toddler.\")\n\nelif age &lt; 13:\n\n    print(\"The person is a kid.\")\n\nelif age &lt; 20:\n\n    print(\"The person is a teenager.\")\n\nelif age &lt; 65:\n\n    print(\"The person is an adult.\")\n\nelse:\n    \n    print(\"The person is a senior citizen.\")\n</pre> age = 22  if age &lt; 2:      print(\"The person is a baby.\")  elif age &lt; 4:      print(\"The person is a toddler.\")  elif age &lt; 13:      print(\"The person is a kid.\")  elif age &lt; 20:      print(\"The person is a teenager.\")  elif age &lt; 65:      print(\"The person is an adult.\")  else:          print(\"The person is a senior citizen.\")  <pre>The person is an adult.\n</pre> In\u00a0[88]: Copied! <pre>FavoriteFruits = [\"banana\", \"apple\", \"strawberry\"]\n\nif \"banana\" in FavoriteFruits:\n\n    print(\"You really like bananas.\")\n\nif \"apple\" in FavoriteFruits:\n\n    print(\"You really like apples.\")\n\nif \"orange\" in FavoriteFruits:\n\n    print(\"You really like oranges.\")\n\nif \"strawberry\" in FavoriteFruits:\n\n    print(\"You really like strawberries.\")\n\nif \"kiwi\" in FavoriteFruits:\n\n    print(\"You really like kiwis.\")\n</pre> FavoriteFruits = [\"banana\", \"apple\", \"strawberry\"]  if \"banana\" in FavoriteFruits:      print(\"You really like bananas.\")  if \"apple\" in FavoriteFruits:      print(\"You really like apples.\")  if \"orange\" in FavoriteFruits:      print(\"You really like oranges.\")  if \"strawberry\" in FavoriteFruits:      print(\"You really like strawberries.\")  if \"kiwi\" in FavoriteFruits:      print(\"You really like kiwis.\")  <pre>You really like bananas.\nYou really like apples.\nYou really like strawberries.\n</pre> In\u00a0[91]: Copied! <pre>UserNames = [\"Admin\", \"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]\n\nfor name in UserNames:\n\n    if name == \"Admin\":\n\n        print(\"Hello Admin, would you like to see a status report?\")\n\n    else:\n\n        print(f\"Hello {name}, thank you for logging in again.\")\n</pre> UserNames = [\"Admin\", \"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]  for name in UserNames:      if name == \"Admin\":          print(\"Hello Admin, would you like to see a status report?\")      else:          print(f\"Hello {name}, thank you for logging in again.\")  <pre>Hello Admin, would you like to see a status report?\nHello Ryan, thank you for logging in again.\nHello Jake, thank you for logging in again.\nHello Trevor, thank you for logging in again.\nHello Rylee, thank you for logging in again.\n</pre> In\u00a0[95]: Copied! <pre>current_users = [\"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]\n\n\nnew_users = [\"Jack\", \"Ryan\", \"Sarah\", \"Dylan\", \"Trevor\"]\n\ncurrent_users_lower = [user.lower for user in current_users]\n\nfor new_user in new_users:\n\n    if new_user.lower in current_users_lower:\n\n        print(f\"Sorry, the username '{new_user}' is not available. Please enter a new username.\")\n    \n    else:\n        \n        print(f\"The username '{new_user}' is available.\")\n</pre> current_users = [\"Ryan\", \"Jake\", \"Trevor\", \"Rylee\"]   new_users = [\"Jack\", \"Ryan\", \"Sarah\", \"Dylan\", \"Trevor\"]  current_users_lower = [user.lower for user in current_users]  for new_user in new_users:      if new_user.lower in current_users_lower:          print(f\"Sorry, the username '{new_user}' is not available. Please enter a new username.\")          else:                  print(f\"The username '{new_user}' is available.\")  <pre>The username 'Jack' is available.\nSorry, the username 'Ryan' is not available. Please enter a new username.\nThe username 'Sarah' is available.\nThe username 'Dylan' is available.\nSorry, the username 'Trevor' is not available. Please enter a new username.\n</pre> In\u00a0[\u00a0]: Copied! <pre>numbers = list(range(1,10))\n\nfor number in numbers:\n\n    if number == 1:\n\n        print(\"1st\")\n\n    elif number == 2:\n\n        print(\"2nd\")\n\n    elif number == 3:\n\n        print(\"3rd\")\n\n    else:\n        \n        print(f\"{number}th\")\n</pre> numbers = list(range(1,10))  for number in numbers:      if number == 1:          print(\"1st\")      elif number == 2:          print(\"2nd\")      elif number == 3:          print(\"3rd\")      else:                  print(f\"{number}th\")"},{"location":"labs/lab4/#lab-4","title":"Lab 4\u00b6","text":""},{"location":"labs/lab4/#submission-instructions","title":"Submission instructions\u00b6","text":"<ol> <li>Download the notebook from https://geohey.gishub.org/labs/lab4</li> <li>Complete the lab questions</li> <li>Restart Kernel and Run All Cells</li> <li>Upload the notebook to your GitHub repository</li> <li>Make sure the notebook has an <code>Open In Colab</code> badge. Click on the badge to make sure your notebook can be opened in Colab.</li> <li>Submit the link to the notebook on your GitHub repository to Canvas</li> </ol>"},{"location":"labs/lab4/#question-1","title":"Question 1\u00b6","text":"<p>Personal Message: Use a variable to represent a person\u2019s name, and print a message to that person. Your message should be simple, such as, \u201cHello Eric, would you like to learn some Python today?\u201d</p>"},{"location":"labs/lab4/#question-2","title":"Question 2\u00b6","text":"<p>Name Cases: Use a variable to represent a person\u2019s name, and then print that person\u2019s name in lowercase, uppercase, and title case.</p>"},{"location":"labs/lab4/#question-3","title":"Question 3\u00b6","text":"<p>Famous Quote: Find a quote from a famous person you admire. Print the quote and the name of its author. Your output should look something like the following, including the quotation marks:</p> <pre><code>Albert Einstein once said, \u201cA person who never made a mistake never tried anything new.\u201d\n</code></pre>"},{"location":"labs/lab4/#question-4","title":"Question 4\u00b6","text":"<p>Stripping Names: Use a variable to represent a person\u2019s name, and include some whitespace characters at the beginning and end of the name. Make sure you use each character combination, \"\\t\" and \"\\n\", at least once. Print the name once, so the whitespace around the name is displayed. Then print the name using each of the three stripping functions, lstrip(), rstrip(), and strip().</p>"},{"location":"labs/lab4/#question-5","title":"Question 5\u00b6","text":"<p>Names: Store the names of a few of your friends in a list called names. Print each person\u2019s name by accessing each element in the list, one at a time.</p>"},{"location":"labs/lab4/#question-6","title":"Question 6\u00b6","text":"<p>Your Own List: Think of your favorite mode of transportation, such as a motorcycle or a car, and make a list that stores several examples. Use your list to print a series of statements about these items, such as \u201cI would like to own a Honda motorcycle.\u201d</p>"},{"location":"labs/lab4/#question-7","title":"Question 7\u00b6","text":"<p>Pizzas: Think of at least three kinds of your favorite pizza. Store these pizza names in a list, and then use a for loop to print the name of each pizza.</p> <p>Modify your for loop to print a sentence using the name of the pizza instead of printing just the name of the pizza. For each pizza you should have one line of output containing a simple statement like I like pepperoni pizza.</p>"},{"location":"labs/lab4/#question-8","title":"Question 8\u00b6","text":"<p>Animals: Think of at least three different animals that have a common characteristic. Store the names of these animals in a list, and then use a for loop to print out the name of each animal.</p> <p>Modify your program to print a statement about each animal, such as A dog would make a great pet.</p>"},{"location":"labs/lab4/#question-9","title":"Question 9\u00b6","text":"<p>Summing a Hundred: Make a list of the numbers from one to one hundred, and then use <code>min()</code> and <code>max()</code> to make sure your list actually starts at one and ends at one hundred. Also, use the sum() function to see how quickly Python can add a hundred numbers.</p>"},{"location":"labs/lab4/#question-10","title":"Question 10\u00b6","text":"<p>Odd Numbers: Use the third argument of the <code>range()</code> function to make a list of the odd numbers from 1 to 20. Use a <code>for</code> loop to print each number.</p>"},{"location":"labs/lab4/#question-11","title":"Question 11\u00b6","text":"<p>Threes: Make a list of the multiples of 3 from 3 to 30. Use a <code>for</code> loop to print the numbers in your list.</p>"},{"location":"labs/lab4/#question-12","title":"Question 12\u00b6","text":"<p>Cube Comprehension: Use a list comprehension to generate a list of the first 10 cubes.</p>"},{"location":"labs/lab4/#question-13","title":"Question 13\u00b6","text":"<p>Slices: Using one of the programs you wrote in this lab, add several lines to the end of the program that do the following:</p> <p>Print the message The first three items in the list are:. Then use a slice to print the first three items from that program\u2019s list.</p>"},{"location":"labs/lab4/#question-14","title":"Question 14\u00b6","text":"<p>Buffet: A buffet-style restaurant offers only five basic foods. Think of five simple foods, and store them in a tuple.</p> <p>Use a for loop to print each food the restaurant offers.</p>"},{"location":"labs/lab4/#question-15","title":"Question 15\u00b6","text":"<p>Alien Colors: Imagine an alien was just shot down in a game. Create a variable called <code>alien_color</code> and assign it a value of <code>green, yellow,</code> or <code>red</code>.</p> <ul> <li>Write an if statement to test whether the alien\u2019s color is green. If it is, print a message that the player just earned 5 points.</li> <li>Write one version of this program that passes the if test and another that fails. (The version that fails will have no output.)</li> </ul>"},{"location":"labs/lab4/#question-16","title":"Question 16\u00b6","text":"<p>Stages of Life: Write an <code>if-elif-else</code> chain that determines a person\u2019s stage of life. Set a value for the variable <code>age</code>, and then:</p> <ul> <li>If the person is less than 2 years old, print a message that the person is a baby.</li> <li>If the person is at least 2 years old but less than 4, print a message that the person is a toddler.</li> <li>If the person is at least 4 years old but less than 13, print a message that the person is a kid.</li> <li>If the person is at least 13 years old but less than 20, print a message that the person is a teenager.</li> <li>If the person is at least 20 years old but less than 65, print a message that the person is an adult.</li> </ul>"},{"location":"labs/lab4/#question-17","title":"Question 17\u00b6","text":"<p>Favorite Fruit: Make a list of your favorite fruits, and then write a series of independent <code>if</code> statements that check for certain fruits in your list.</p> <ul> <li>Make a list of your three favorite fruits and call it favorite_fruits.</li> <li>Write five if statements. Each should check whether a certain kind of fruit is in your list. If the fruit is in your list, the if block should print a statement, such as You really like bananas!</li> </ul>"},{"location":"labs/lab4/#question-18","title":"Question 18\u00b6","text":"<p>Hello Admin: Make a list of five or more usernames, including the name <code>admin</code>. Imagine you are writing code that will print a greeting to each user after they log in to a website. Loop through the list, and print a greeting to each user:</p> <ul> <li>If the username is 'admin', print a special greeting, such as Hello admin, would you like to see a status report?</li> <li>Otherwise, print a generic greeting, such as Hello Jaden, thank you for logging in again.</li> </ul>"},{"location":"labs/lab4/#question-19","title":"Question 19\u00b6","text":"<p>Checking Usernames: Do the following to create a program that simulates how websites ensure that everyone has a unique username.</p> <ul> <li>Make a list of five or more usernames called <code>current_users</code>.</li> <li>Make another list of five usernames called <code>new_users</code>. Make sure one or two of the new usernames are also in the <code>current_users</code> list.</li> <li>Loop through the <code>new_users</code> list to see if each new username has already been used. If it has, print a message that the person will need to enter a new username. If a username has not been used, print a message saying that the username is available.</li> <li>Make sure your comparison is case insensitive. If 'John' has been used, 'JOHN' should not be accepted. (To do this, you\u2019ll need to make a copy of <code>current_users</code> containing the lowercase versions of all existing users.)</li> </ul>"},{"location":"labs/lab4/#question-20","title":"Question 20\u00b6","text":"<p>Ordinal Numbers: Ordinal numbers indicate their position in a list, such as 1st or 2nd. Most ordinal numbers end in th, except 1, 2, and 3.</p> <ul> <li>Store the numbers 1 through 9 in a list.</li> <li>Loop through the list.</li> <li>Use an <code>if-elif-else</code> chain inside the loop to print the proper ordinal ending for each number. Your output should read \"1st 2nd 3rd 4th 5th 6th 7th 8th 9th\", and each result should be on a separate line.</li> </ul>"},{"location":"labs/lab5/","title":"Lab5","text":"In\u00a0[4]: Copied! <pre># Create a dictionary to store information about a person\nperson_info = {\n    'first_name': 'Ryan',\n    'last_name': 'Willson',\n    'age': 30,\n    'city': 'Washington D.C.'\n}\n\n# Print each piece of information stored in the dictionary\nprint(\"First Name:\", person_info['first_name'])\nprint(\"Last Name:\", person_info['last_name'])\nprint(\"Age:\", person_info['age'])\nprint(\"City:\", person_info['city'])\n</pre> # Create a dictionary to store information about a person person_info = {     'first_name': 'Ryan',     'last_name': 'Willson',     'age': 30,     'city': 'Washington D.C.' }  # Print each piece of information stored in the dictionary print(\"First Name:\", person_info['first_name']) print(\"Last Name:\", person_info['last_name']) print(\"Age:\", person_info['age']) print(\"City:\", person_info['city'])  <pre>First Name: Ryan\nLast Name: Willson\nAge: 30\nCity: Washington D.C.\n</pre> In\u00a0[5]: Copied! <pre># Create a dictionary to store people's favorite numbers\nfavorite_numbers = {\n    'Ryan': 25,\n    'Jake': 42,\n    'Trevor': 7,\n    'Dylan': 8,\n    'Rylee': 16\n}\n\n# Print each person's name and their favorite number\nfor person, number in favorite_numbers.items():\n    print(f\"{person}'s favorite number is {number}.\")\n</pre> # Create a dictionary to store people's favorite numbers favorite_numbers = {     'Ryan': 25,     'Jake': 42,     'Trevor': 7,     'Dylan': 8,     'Rylee': 16 }  # Print each person's name and their favorite number for person, number in favorite_numbers.items():     print(f\"{person}'s favorite number is {number}.\")  <pre>Ryan's favorite number is 25.\nJake's favorite number is 42.\nTrevor's favorite number is 7.\nDylan's favorite number is 8.\nRylee's favorite number is 16.\n</pre> In\u00a0[9]: Copied! <pre># Create a glossary dictionary\nglossary = {\n    'list': 'A collection of items, ordered and changeable, used to store multiple values in a single variable.',\n    'definition': 'A statement or description that explains the meaning of a word or the purpose of a concept in programming.',\n    'function': 'A reusable block of code that performs a specific task.',\n    'variable': 'A named storage location in a program that can hold a value.',\n    'loop': 'A control flow statement that allows code to be repeatedly executed.',\n}\n\n# Print each word and its meaning neatly formatted\nfor word, meaning in glossary.items():\n    print(f\"{word}:\\n{meaning}\\n\")\n</pre> # Create a glossary dictionary glossary = {     'list': 'A collection of items, ordered and changeable, used to store multiple values in a single variable.',     'definition': 'A statement or description that explains the meaning of a word or the purpose of a concept in programming.',     'function': 'A reusable block of code that performs a specific task.',     'variable': 'A named storage location in a program that can hold a value.',     'loop': 'A control flow statement that allows code to be repeatedly executed.', }  # Print each word and its meaning neatly formatted for word, meaning in glossary.items():     print(f\"{word}:\\n{meaning}\\n\") <pre>list:\nA collection of items, ordered and changeable, used to store multiple values in a single variable.\n\ndefinition:\nA statement or description that explains the meaning of a word or the purpose of a concept in programming.\n\nfunction:\nA reusable block of code that performs a specific task.\n\nvariable:\nA named storage location in a program that can hold a value.\n\nloop:\nA control flow statement that allows code to be repeatedly executed.\n\n</pre> In\u00a0[10]: Copied! <pre>#Adding more python terms to the glossary\nglossary.update({\n    'dictionary': 'A collection of key-value pairs, allowing efficient data retrieval.',\n    'module': 'A file containing Python definitions and statements, intended for reuse.',\n    'exception': 'An event that occurs during the execution of a program and disrupts the normal flow.',\n    'syntax': 'A set of rules that dictate how programs in a specific language are constructed.',\n    'algorithm': 'A step-by-step procedure or formula for solving a problem or accomplishing a task.'\n})\n\n# Print each word and its meaning using a loop\nfor word, meaning in glossary.items():\n    print(f\"{word}:\\n{meaning}\\n\")\n</pre> #Adding more python terms to the glossary glossary.update({     'dictionary': 'A collection of key-value pairs, allowing efficient data retrieval.',     'module': 'A file containing Python definitions and statements, intended for reuse.',     'exception': 'An event that occurs during the execution of a program and disrupts the normal flow.',     'syntax': 'A set of rules that dictate how programs in a specific language are constructed.',     'algorithm': 'A step-by-step procedure or formula for solving a problem or accomplishing a task.' })  # Print each word and its meaning using a loop for word, meaning in glossary.items():     print(f\"{word}:\\n{meaning}\\n\") <pre>list:\nA collection of items, ordered and changeable, used to store multiple values in a single variable.\n\ndefinition:\nA statement or description that explains the meaning of a word or the purpose of a concept in programming.\n\nfunction:\nA reusable block of code that performs a specific task.\n\nvariable:\nA named storage location in a program that can hold a value.\n\nloop:\nA control flow statement that allows code to be repeatedly executed.\n\ndictionary:\nA collection of key-value pairs, allowing efficient data retrieval.\n\nmodule:\nA file containing Python definitions and statements, intended for reuse.\n\nexception:\nAn event that occurs during the execution of a program and disrupts the normal flow.\n\nsyntax:\nA set of rules that dictate how programs in a specific language are constructed.\n\nalgorithm:\nA step-by-step procedure or formula for solving a problem or accomplishing a task.\n\n</pre> In\u00a0[16]: Copied! <pre># Create a dictionary of major rivers and the countries they run through\nrivers = {\n    'Mississippi River': 'United States of America',\n    'Amazon': 'Brazil',\n    'Nile': 'Egypt'\n    \n    \n}\n\n# Use a loop to print a sentence about each river\nprint(\"River Information:\")\nfor river, country in rivers.items():\n    print(f\"The {river} is located in {country}.\")\n\n# Use a loop to print the names of each river\nprint(\"\\nNames of Rivers:\")\nfor river in rivers.keys():\n    print(river)\n\n# Use a loop to print the names of each country\nprint(\"\\nNames of Countries:\")\nfor country in rivers.values():\n    print(country)\n</pre> # Create a dictionary of major rivers and the countries they run through rivers = {     'Mississippi River': 'United States of America',     'Amazon': 'Brazil',     'Nile': 'Egypt'           }  # Use a loop to print a sentence about each river print(\"River Information:\") for river, country in rivers.items():     print(f\"The {river} is located in {country}.\")  # Use a loop to print the names of each river print(\"\\nNames of Rivers:\") for river in rivers.keys():     print(river)  # Use a loop to print the names of each country print(\"\\nNames of Countries:\") for country in rivers.values():     print(country)  <pre>River Information:\nThe Mississippi River is located in United States of America.\nThe Amazon is located in Brazil.\nThe Nile is located in Egypt.\n\nNames of Rivers:\nMississippi River\nAmazon\nNile\n\nNames of Countries:\nUnited States of America\nBrazil\nEgypt\n</pre> In\u00a0[47]: Copied! <pre># Create a dictionary of cities and their information\ncities = {\n    'New York': {\n        'country': 'United States',\n        'population': \"8.468 million\",\n        'fact': 'The Statue of Liberty is located in New York Harbor.'\n    },\n    'Tokyo': {\n        'country': 'Japan',\n        'population': \"13.96 million\",\n        'fact': 'Tokyo is the most populous metropolitan area in the world.'\n    },\n    'Paris': {\n        'country': 'France',\n        'population': \"2.161 million\",\n        'fact': 'Paris is known as the \"City of Light\" and is famous for its art and culture.'\n    }\n}\n\n# Print the name of each city and its information\nfor city, info in cities.items():\n    print(f\"\\nCity: {city}\")\n    print(f\"Country: {info['country']}\")\n    print(f\"Population: {info['population']}\")\n    print(f\"Fact: {info['fact']}\")\n</pre> # Create a dictionary of cities and their information cities = {     'New York': {         'country': 'United States',         'population': \"8.468 million\",         'fact': 'The Statue of Liberty is located in New York Harbor.'     },     'Tokyo': {         'country': 'Japan',         'population': \"13.96 million\",         'fact': 'Tokyo is the most populous metropolitan area in the world.'     },     'Paris': {         'country': 'France',         'population': \"2.161 million\",         'fact': 'Paris is known as the \"City of Light\" and is famous for its art and culture.'     } }  # Print the name of each city and its information for city, info in cities.items():     print(f\"\\nCity: {city}\")     print(f\"Country: {info['country']}\")     print(f\"Population: {info['population']}\")     print(f\"Fact: {info['fact']}\")  <pre>\nCity: New York\nCountry: United States\nPopulation: 8.468 million\nFact: The Statue of Liberty is located in New York Harbor.\n\nCity: Tokyo\nCountry: Japan\nPopulation: 13.96 million\nFact: Tokyo is the most populous metropolitan area in the world.\n\nCity: Paris\nCountry: France\nPopulation: 2.161 million\nFact: Paris is known as the \"City of Light\" and is famous for its art and culture.\n</pre> In\u00a0[18]: Copied! <pre># Ask the user what kind of rental car they would like\nrental_car = input(\"What kind of rental car would you like? \")\n\n# Print a message based on the user's choice\nprint(f\"Let me see if I can find you a {rental_car}.\")\n</pre> # Ask the user what kind of rental car they would like rental_car = input(\"What kind of rental car would you like? \")  # Print a message based on the user's choice print(f\"Let me see if I can find you a {rental_car}.\")  <pre>Let me see if I can find you a tacoma.\n</pre> In\u00a0[21]: Copied! <pre># Ask the user how many people are in their dinner group\nnum_people = int(input(\"How many people are in your dinner group? \"))\n\n# Check the number of people and provide a response\nif num_people &gt; 8:\n    print(\"I'm sorry, but you'll have to wait for a table.\")\nelse:\n    print(\"Your table is ready. Enjoy your meal!\")\n</pre> # Ask the user how many people are in their dinner group num_people = int(input(\"How many people are in your dinner group? \"))  # Check the number of people and provide a response if num_people &gt; 8:     print(\"I'm sorry, but you'll have to wait for a table.\") else:     print(\"Your table is ready. Enjoy your meal!\")  <pre>Your table is ready. Enjoy your meal!\n</pre> In\u00a0[22]: Copied! <pre># Ask the user for a number\nuser_number = int(input(\"Please enter a number: \"))\n\n# Check if the number is a multiple of 10\nif user_number % 10 == 0:\n    print(f\"{user_number} is a multiple of 10.\")\nelse:\n    print(f\"{user_number} is not a multiple of 10.\")\n</pre> # Ask the user for a number user_number = int(input(\"Please enter a number: \"))  # Check if the number is a multiple of 10 if user_number % 10 == 0:     print(f\"{user_number} is a multiple of 10.\") else:     print(f\"{user_number} is not a multiple of 10.\")  <pre>5 is not a multiple of 10.\n</pre> In\u00a0[31]: Copied! <pre># Initialize an empty list to store pizza toppings\npizza_toppings = []\n\n# Prompt the user to enter pizza toppings\nwhile True:\n    topping = input(\"Enter a pizza topping (type 'quit' to finish): \")\n\n    # Check if the user wants to quit\n    if topping.lower() == 'quit':\n        break\n\n    # Add the topping to the list and print a message\n    pizza_toppings.append(topping)\n    print(f\"Adding {topping} to your pizza.\")\n\n# Print the final list of pizza toppings\nprint(\"\\nYour pizza will have the following toppings:\")\nfor topping in pizza_toppings:\n    print(f\"- {topping}\")\n</pre> # Initialize an empty list to store pizza toppings pizza_toppings = []  # Prompt the user to enter pizza toppings while True:     topping = input(\"Enter a pizza topping (type 'quit' to finish): \")      # Check if the user wants to quit     if topping.lower() == 'quit':         break      # Add the topping to the list and print a message     pizza_toppings.append(topping)     print(f\"Adding {topping} to your pizza.\")  # Print the final list of pizza toppings print(\"\\nYour pizza will have the following toppings:\") for topping in pizza_toppings:     print(f\"- {topping}\")  <pre>Adding bacon to your pizza.\nAdding pepperoni to your pizza.\n\nYour pizza will have the following toppings:\n- bacon\n- pepperoni\n</pre> In\u00a0[40]: Copied! <pre># Define the display_message function\ndef message():\n    print(\"In this notebook, I am learning about Python functions and basic programming concepts.\")\n\n# Call the function to display the message\nmessage()\n</pre> # Define the display_message function def message():     print(\"In this notebook, I am learning about Python functions and basic programming concepts.\")  # Call the function to display the message message()  <pre>In this notebook, I am learning about Python functions and basic programming concepts.\n</pre> In\u00a0[41]: Copied! <pre># Define the favorite_book function\ndef favorite_book(title):\n    print(f\"One of my favorite books is {title}.\")\n\n# Call the function with a book title\nfavorite_book(\"Jurassic Park\")\n</pre> # Define the favorite_book function def favorite_book(title):     print(f\"One of my favorite books is {title}.\")  # Call the function with a book title favorite_book(\"Jurassic Park\")  <pre>One of my favorite books is Jurassic Park.\n</pre> In\u00a0[42]: Copied! <pre># Define the make_shirt function\ndef make_shirt(size, message):\n    print(f\"Creating a shirt of size {size} with the message: '{message}'.\")\n\n# Call the function once using positional arguments\nmake_shirt(\"Medium\", \"So Cool It Hurts\")\n\n# Call the function a second time using keyword arguments\nmake_shirt(size=\"Large\", message=\"Python Lover\")\n</pre> # Define the make_shirt function def make_shirt(size, message):     print(f\"Creating a shirt of size {size} with the message: '{message}'.\")  # Call the function once using positional arguments make_shirt(\"Medium\", \"So Cool It Hurts\")  # Call the function a second time using keyword arguments make_shirt(size=\"Large\", message=\"Python Lover\")  <pre>Creating a shirt of size Medium with the message: 'So Cool It Hurts'.\nCreating a shirt of size Large with the message: 'Python Lover'.\n</pre> In\u00a0[43]: Copied! <pre># Modified make_shirt function with default values\ndef make_shirt(size=\"Large\", message=\"I love Python\"):\n    print(f\"Creating a shirt of size {size} with the message: '{message}'.\")\n\n# Create a large shirt with the default message\nmake_shirt()\n\n# Create a medium shirt with the default message\nmake_shirt(size=\"Medium\")\n\n# Create a custom-sized shirt with a different message\nmake_shirt(size=\"Small\", message=\"Python is Fun!\")\n</pre> # Modified make_shirt function with default values def make_shirt(size=\"Large\", message=\"I love Python\"):     print(f\"Creating a shirt of size {size} with the message: '{message}'.\")  # Create a large shirt with the default message make_shirt()  # Create a medium shirt with the default message make_shirt(size=\"Medium\")  # Create a custom-sized shirt with a different message make_shirt(size=\"Small\", message=\"Python is Fun!\")  <pre>Creating a shirt of size Large with the message: 'I love Python'.\nCreating a shirt of size Medium with the message: 'I love Python'.\nCreating a shirt of size Small with the message: 'Python is Fun!'.\n</pre> In\u00a0[44]: Copied! <pre># Define the describe_city function with a default country\ndef describe_city(city, country=\"USA\"):\n    print(f\"{city} is in {country}.\")\n\n# Call the function for three different cities\ndescribe_city(\"New York\")\ndescribe_city(\"Washington D.C.\")\ndescribe_city(\"Tokyo\", \"Japan\")\n</pre> # Define the describe_city function with a default country def describe_city(city, country=\"USA\"):     print(f\"{city} is in {country}.\")  # Call the function for three different cities describe_city(\"New York\") describe_city(\"Washington D.C.\") describe_city(\"Tokyo\", \"Japan\")  <pre>New York is in USA.\nWashington D.C. is in USA.\nTokyo is in Japan.\n</pre> In\u00a0[49]: Copied! <pre>def city_country(city, country):\n    return f\"{city}, {country}\"\n\nprint(city_country(\"Tokyo\", \"Japan\"))\nprint(city_country(\"New York\", \"USA\"))\nprint(city_country(\"Paris\", \"France\"))\n</pre> def city_country(city, country):     return f\"{city}, {country}\"  print(city_country(\"Tokyo\", \"Japan\")) print(city_country(\"New York\", \"USA\")) print(city_country(\"Paris\", \"France\"))  <pre>Tokyo, Japan\nNew York, USA\nParis, France\n</pre> In\u00a0[50]: Copied! <pre># Define the make_album function\ndef make_album(artist, title, songs=None):\n    album = {'artist': artist, 'title': title}\n    if songs is not None:\n        album['songs'] = songs\n    return album\n\n# Make three dictionaries representing different albums\nalbum1 = make_album(\"Imagine Dragons\", \"Night Visions\", songs=13)\nalbum2 = make_album(\"The Beatles\", \"Abbey Road\", songs=17)\nalbum3 = make_album(\"Ed Sheeran\", \"\u00f7 (Divide)\", songs=16)\n\n# Print each return value to show the stored album information\nprint(album1)\nprint(album2)\nprint(album3)\n\nalbum4 = make_album(\"John Williams\", \"Jurassic Park\", songs=16)\nprint(album4)\n</pre> # Define the make_album function def make_album(artist, title, songs=None):     album = {'artist': artist, 'title': title}     if songs is not None:         album['songs'] = songs     return album  # Make three dictionaries representing different albums album1 = make_album(\"Imagine Dragons\", \"Night Visions\", songs=13) album2 = make_album(\"The Beatles\", \"Abbey Road\", songs=17) album3 = make_album(\"Ed Sheeran\", \"\u00f7 (Divide)\", songs=16)  # Print each return value to show the stored album information print(album1) print(album2) print(album3)  album4 = make_album(\"John Williams\", \"Jurassic Park\", songs=16) print(album4) <pre>{'artist': 'Imagine Dragons', 'title': 'Night Visions', 'songs': 13}\n{'artist': 'The Beatles', 'title': 'Abbey Road', 'songs': 17}\n{'artist': 'Ed Sheeran', 'title': '\u00f7 (Divide)', 'songs': 16}\n{'artist': 'John Williams', 'title': 'Jurassic Park', 'songs': 16}\n</pre> In\u00a0[60]: Copied! <pre># Define the make_album function\ndef make_album(artist, title, songs=None):\n    album = {'artist': artist, 'title': title}\n    if songs is not None:\n        album['songs'] = songs\n    return album\n\nalbums = [\n    (\"Imagine Dragons\", \"Night Visions\"),\n    (\"The Beatles\", \"Abbey Road\"),\n    (\"Ed Sheeran\", \"\u00f7 (Divide)\"),\n    (\"end\", \"end\") \n]\n\nfor artist, title in albums:\n    if artist.lower() == 'end' or title.lower() == 'end':\n        print(\"bye\")\n        break\n    else:\n        album = make_album(artist, title)\n        print(album)\n</pre> # Define the make_album function def make_album(artist, title, songs=None):     album = {'artist': artist, 'title': title}     if songs is not None:         album['songs'] = songs     return album  albums = [     (\"Imagine Dragons\", \"Night Visions\"),     (\"The Beatles\", \"Abbey Road\"),     (\"Ed Sheeran\", \"\u00f7 (Divide)\"),     (\"end\", \"end\")  ]  for artist, title in albums:     if artist.lower() == 'end' or title.lower() == 'end':         print(\"bye\")         break     else:         album = make_album(artist, title)         print(album)   <pre>{'artist': 'Imagine Dragons', 'title': 'Night Visions'}\n{'artist': 'The Beatles', 'title': 'Abbey Road'}\n{'artist': 'Ed Sheeran', 'title': '\u00f7 (Divide)'}\nbye\n</pre> In\u00a0[61]: Copied! <pre># Define the show_messages function\ndef show_messages(messages):\n    for message in messages:\n        print(message)\n\n# Create a list of short text messages\ntext_messages = [\n    \"Hello!\",\n    \"How are you?\",\n    \"Python is fun!\",\n    \"Keep coding!\",\n    \"Have a great day!\"\n]\n\n# Call the show_messages function with the list of messages\nshow_messages(text_messages)\n</pre> # Define the show_messages function def show_messages(messages):     for message in messages:         print(message)  # Create a list of short text messages text_messages = [     \"Hello!\",     \"How are you?\",     \"Python is fun!\",     \"Keep coding!\",     \"Have a great day!\" ]  # Call the show_messages function with the list of messages show_messages(text_messages)  <pre>Hello!\nHow are you?\nPython is fun!\nKeep coding!\nHave a great day!\n</pre> In\u00a0[73]: Copied! <pre># Define the send_messages function\ndef send_messages(messages, sent_messages):\n    while messages:\n        current_message = messages.pop()\n        print(f\"Sending message: {current_message}\")\n        sent_messages.append(current_message)\n    return sent_messages\n\n# Create a list of short text messages\ntext_messages = [\n    \"Hello!\",\n    \"How are you?\",\n    \"Python is fun!\",\n    \"Keep coding!\",\n    \"Have a great day!\"\n]\n\n# Create an empty list to store sent messages\nsent_messages = []\n\n# Call the send_messages function with the list of messages\nsend_messages(text_messages, sent_messages)\n\n# Print both lists to verify messages were moved correctly\nprint(\"\\nOriginal messages:\")\nprint(text_messages)\n\nprint(\"\\nSent messages:\")\nprint(sent_messages)\n</pre> # Define the send_messages function def send_messages(messages, sent_messages):     while messages:         current_message = messages.pop()         print(f\"Sending message: {current_message}\")         sent_messages.append(current_message)     return sent_messages  # Create a list of short text messages text_messages = [     \"Hello!\",     \"How are you?\",     \"Python is fun!\",     \"Keep coding!\",     \"Have a great day!\" ]  # Create an empty list to store sent messages sent_messages = []  # Call the send_messages function with the list of messages send_messages(text_messages, sent_messages)  # Print both lists to verify messages were moved correctly print(\"\\nOriginal messages:\") print(text_messages)  print(\"\\nSent messages:\") print(sent_messages)  <pre>Sending message: Have a great day!\nSending message: Keep coding!\nSending message: Python is fun!\nSending message: How are you?\nSending message: Hello!\n\nOriginal messages:\n[]\n\nSent messages:\n['Have a great day!', 'Keep coding!', 'Python is fun!', 'How are you?', 'Hello!']\n</pre> In\u00a0[78]: Copied! <pre>filename = 'learning_python.txt'\n\n# Read the entire file and print its contents\nwith open(filename) as text_file:\n    contents = text_file.read()\nprint(\"Read entire file:\")\nprint(contents)\n\n# Loop over the file object and print each line\nprint(\"\\nLooping over the file object:\")\nwith open(filename) as text_file:\n    for line in text_file:\n        print(line.rstrip())\n\n# Store lines in a list and print outside the with block\nprint(\"\\nLines stored in a list and printed outside the with block:\")\nwith open(filename) as text_file:\n    lines = text_file.readlines()\n\n# Strip to remove extra newline characters\nfor line in lines:\n    print(line.rstrip())\n</pre> filename = 'learning_python.txt'  # Read the entire file and print its contents with open(filename) as text_file:     contents = text_file.read() print(\"Read entire file:\") print(contents)  # Loop over the file object and print each line print(\"\\nLooping over the file object:\") with open(filename) as text_file:     for line in text_file:         print(line.rstrip())  # Store lines in a list and print outside the with block print(\"\\nLines stored in a list and printed outside the with block:\") with open(filename) as text_file:     lines = text_file.readlines()  # Strip to remove extra newline characters for line in lines:     print(line.rstrip())  <pre>Read entire file:\nIn Python you can define functions to encapsulate reusable code.\nIn Python you can use dictionaries to store key-value pairs.\nIn Python you can work with files using the built-in file handling capabilities.\n\n\nLooping over the file object:\nIn Python you can define functions to encapsulate reusable code.\nIn Python you can use dictionaries to store key-value pairs.\nIn Python you can work with files using the built-in file handling capabilities.\n\nLines stored in a list and printed outside the with block:\nIn Python you can define functions to encapsulate reusable code.\nIn Python you can use dictionaries to store key-value pairs.\nIn Python you can work with files using the built-in file handling capabilities.\n</pre> In\u00a0[79]: Copied! <pre>filename = 'learning_python.txt'\n\nwith open(filename) as text_file:\n    file = text_file.readlines()\n\nfor line in file:\n    modified_line = line.replace('Python', 'C')\n    print(modified_line.rstrip())\n</pre> filename = 'learning_python.txt'  with open(filename) as text_file:     file = text_file.readlines()  for line in file:     modified_line = line.replace('Python', 'C')     print(modified_line.rstrip())  <pre>In C you can define functions to encapsulate reusable code.\nIn C you can use dictionaries to store key-value pairs.\nIn C you can work with files using the built-in file handling capabilities.\n</pre> In\u00a0[80]: Copied! <pre># Prompt the user for their name\nuser_name = input(\"Please enter your name: \")\n\n# Write the user's name to guest.txt\nwith open('guest.txt', 'w') as file:\n    file.write(user_name)\n\nprint(f\"Thank you, {user_name}! Your name has been written to guest.txt.\")\n</pre> # Prompt the user for their name user_name = input(\"Please enter your name: \")  # Write the user's name to guest.txt with open('guest.txt', 'w') as file:     file.write(user_name)  print(f\"Thank you, {user_name}! Your name has been written to guest.txt.\")  <pre>Thank you, Brycen Harris! Your name has been written to guest.txt.\n</pre> In\u00a0[81]: Copied! <pre># Open guest_book.txt in append mode to record visits\nwith open('guest_book.txt', 'a') as guest_book:\n    while True:\n        # Prompt the user for their name\n        user_name = input(\"Please enter your name (type 'quit' to exit): \")\n\n        # Check if the user wants to quit\n        if user_name.lower() == 'quit':\n            break\n\n        # Print a greeting to the screen\n        print(f\"Welcome, {user_name}!\")\n\n        # Write the user's visit to guest_book.txt\n        guest_book.write(f\"{user_name}\\n\")\n\nprint(\"Thanks for visiting! Check guest_book.txt for recorded visits.\")\n</pre> # Open guest_book.txt in append mode to record visits with open('guest_book.txt', 'a') as guest_book:     while True:         # Prompt the user for their name         user_name = input(\"Please enter your name (type 'quit' to exit): \")          # Check if the user wants to quit         if user_name.lower() == 'quit':             break          # Print a greeting to the screen         print(f\"Welcome, {user_name}!\")          # Write the user's visit to guest_book.txt         guest_book.write(f\"{user_name}\\n\")  print(\"Thanks for visiting! Check guest_book.txt for recorded visits.\")  <pre>Welcome, Brycen Harris!\nWelcome, Ryan Willson!\nThanks for visiting! Check guest_book.txt for recorded visits.\n</pre> In\u00a0[82]: Copied! <pre># Open poll_responses.txt in append mode to store responses\nwith open('poll_responses.txt', 'a') as poll_responses:\n    print(\"Welcome to the Programming Poll! Type 'quit' to exit.\")\n\n    while True:\n        # Prompt the user for their reason for liking programming\n        reason = input(\"Why do you like programming? \")\n\n        # Check if the user wants to quit\n        if reason.lower() == 'quit':\n            break\n\n        # Write the user's reason to poll_responses.txt\n        poll_responses.write(f\"{reason}\\n\")\n\nprint(\"Thank you for participating! Responses have been recorded in poll_responses.txt.\")\n</pre> # Open poll_responses.txt in append mode to store responses with open('poll_responses.txt', 'a') as poll_responses:     print(\"Welcome to the Programming Poll! Type 'quit' to exit.\")      while True:         # Prompt the user for their reason for liking programming         reason = input(\"Why do you like programming? \")          # Check if the user wants to quit         if reason.lower() == 'quit':             break          # Write the user's reason to poll_responses.txt         poll_responses.write(f\"{reason}\\n\")  print(\"Thank you for participating! Responses have been recorded in poll_responses.txt.\")  <pre>Welcome to the Programming Poll! Type 'quit' to exit.\nThank you for participating! Responses have been recorded in poll_responses.txt.\n</pre> In\u00a0[84]: Copied! <pre>while True:\n    try:\n        # Prompt the user for two numbers\n        num1 = input(\"Enter the first number: \")\n        num2 = input(\"Enter the second number: \")\n\n        # Convert input to integers and add them together\n        result = int(num1) + int(num2)\n\n        # Print the result\n        print(f\"The sum of {num1} and {num2} is: {result}\")\n\n        # Break out of the loop after successful input\n        break\n\n    except ValueError:\n        # Handle ValueError if input is not a number\n        print(\"Invalid input. Please enter valid numbers.\")\n</pre> while True:     try:         # Prompt the user for two numbers         num1 = input(\"Enter the first number: \")         num2 = input(\"Enter the second number: \")          # Convert input to integers and add them together         result = int(num1) + int(num2)          # Print the result         print(f\"The sum of {num1} and {num2} is: {result}\")          # Break out of the loop after successful input         break      except ValueError:         # Handle ValueError if input is not a number         print(\"Invalid input. Please enter valid numbers.\")  <pre>Invalid input. Please enter valid numbers.\nThe sum of 6 and 8 is: 14\n</pre> In\u00a0[85]: Copied! <pre>while True:\n    try:\n        # Prompt the user for two numbers\n        num1 = input(\"Enter the first number (or 'quit' to exit): \")\n\n        # Check if the user wants to quit\n        if num1.lower() == 'quit':\n            break\n\n        num2 = input(\"Enter the second number: \")\n\n        # Convert input to integers and add them together\n        result = int(num1) + int(num2)\n\n        # Print the result\n        print(f\"The sum of {num1} and {num2} is: {result}\")\n\n    except ValueError:\n        # Handle ValueError if input is not a number\n        print(\"Invalid input. Please enter valid numbers.\")\n</pre> while True:     try:         # Prompt the user for two numbers         num1 = input(\"Enter the first number (or 'quit' to exit): \")          # Check if the user wants to quit         if num1.lower() == 'quit':             break          num2 = input(\"Enter the second number: \")          # Convert input to integers and add them together         result = int(num1) + int(num2)          # Print the result         print(f\"The sum of {num1} and {num2} is: {result}\")      except ValueError:         # Handle ValueError if input is not a number         print(\"Invalid input. Please enter valid numbers.\")  <pre>The sum of 6 and 8 is: 14\nThe sum of 5 and 4 is: 9\nThe sum of 10 and 15 is: 25\n</pre> In\u00a0[88]: Copied! <pre>filenames = ['dogs.txt', 'cats.txt']\n\nfor filename in filenames:\n    try:\n        with open(filename) as text_file:\n            print(f\"Contents of {filename}:\")\n            contents = text_file.read()\n            print(contents)\n            print()\n    except FileNotFoundError:\n        print(f\"Sorry, the file '{filename}' does not exist or cannot be found.\")\n</pre> filenames = ['dogs.txt', 'cats.txt']  for filename in filenames:     try:         with open(filename) as text_file:             print(f\"Contents of {filename}:\")             contents = text_file.read()             print(contents)             print()     except FileNotFoundError:         print(f\"Sorry, the file '{filename}' does not exist or cannot be found.\")  <pre>Contents of dogs.txt:\nGrace\nJunior\nMitsy\n\nContents of cats.txt:\nLuna\nMilo\nOliver\n\n</pre> In\u00a0[89]: Copied! <pre>filenames = ['dogs.txt', 'cats.txt']\n\nfor filename in filenames:\n    try:\n        with open(filename) as text_file:\n            print(f\"Contents of {filename}:\")\n            contents = text_file.read()\n            print(contents)\n            print()\n    except FileNotFoundError:\n        pass\n</pre> filenames = ['dogs.txt', 'cats.txt']  for filename in filenames:     try:         with open(filename) as text_file:             print(f\"Contents of {filename}:\")             contents = text_file.read()             print(contents)             print()     except FileNotFoundError:         pass  <pre>Contents of dogs.txt:\nGrace\nJunior\nMitsy\n\nContents of cats.txt:\nLuna\nMilo\nOliver\n\n</pre> In\u00a0[\u00a0]: Copied! <pre>line = \"Row, row, row your boat\"\nline.count(\"row\")\n</pre> line = \"Row, row, row your boat\" line.count(\"row\") In\u00a0[\u00a0]: Copied! <pre>line.lower().count(\"row\")\n</pre> line.lower().count(\"row\") <p>Notice that converting the string to lowercase using lower() catches all appearances of the word you\u2019re looking for, regardless of how it\u2019s formatted.</p> <p>Write a program that reads the files you found at Project Gutenberg and determines how many times the word <code>the</code> appears in each text. This will be an approximation because it will also count words such as <code>then</code> and <code>there</code>. Try counting <code>the</code>, with a space in the string, and see how much lower your count is.</p> In\u00a0[101]: Copied! <pre>def count_the(file_name, target_word):\n    try:\n        with open(file_name, 'r', encoding='utf-8') as file:\n            content = file.read()\n            # Count occurrences with a space\n            with_space = content.lower().count(target_word.lower())\n            \n            # Count occurrences without a space\n            no_space = content.lower().count(target_word.lower() + \" \")\n\n            print(f\"The word '{target_word}' with space show up {with_space} times in the text file.\")\n            print(f\"The word '{target_word}' without a space shows up {no_space} times in the text file.\")\n\n    except FileNotFoundError:\n        print(f\"Sorry, the file '{filename}' does not exist or cannot be found.\")\n\n# Example usage for the gutenberg_file.txt\ncount_the(\"gutenberg_file.txt\", \"the\")\n</pre> def count_the(file_name, target_word):     try:         with open(file_name, 'r', encoding='utf-8') as file:             content = file.read()             # Count occurrences with a space             with_space = content.lower().count(target_word.lower())                          # Count occurrences without a space             no_space = content.lower().count(target_word.lower() + \" \")              print(f\"The word '{target_word}' with space show up {with_space} times in the text file.\")             print(f\"The word '{target_word}' without a space shows up {no_space} times in the text file.\")      except FileNotFoundError:         print(f\"Sorry, the file '{filename}' does not exist or cannot be found.\")  # Example usage for the gutenberg_file.txt count_the(\"gutenberg_file.txt\", \"the\") <pre>The word 'the' with space show up 3151 times in the text file.\nThe word 'the' without a space shows up 2215 times in the text file.\n</pre>"},{"location":"labs/lab5/#lab-5","title":"Lab 5\u00b6","text":""},{"location":"labs/lab5/#submission-instructions","title":"Submission instructions\u00b6","text":"<ol> <li>Download the notebook from https://geohey.gishub.org/labs/lab5</li> <li>Complete the lab questions</li> <li>Restart Kernel and Run All Cells</li> <li>Upload the notebook to your GitHub repository</li> <li>Make sure the notebook has an <code>Open In Colab</code> badge. Click on the badge to make sure your notebook can be opened in Colab.</li> <li>Submit the link to the notebook on your GitHub repository to Canvas</li> </ol>"},{"location":"labs/lab5/#question-1","title":"Question 1\u00b6","text":"<p>Person: Use a dictionary to store information about a person you know. Store their first name, last name, age, and the city in which they live. You should have keys such as first_name, last_name, age, and city. Print each piece of information stored in your dictionary.</p>"},{"location":"labs/lab5/#question-2","title":"Question 2\u00b6","text":"<p>Favorite Numbers: Use a dictionary to store people\u2019s favorite numbers. Think of five names, and use them as keys in your dictionary. Think of a favorite number for each person, and store each as a value in your dictionary. Print each person\u2019s name and their favorite number. For even more fun, poll a few friends and get some actual data for your program.</p>"},{"location":"labs/lab5/#question-3","title":"Question 3\u00b6","text":"<p>Glossary: A Python dictionary can be used to model an actual dictionary. However, to avoid confusion, let\u2019s call it a glossary.</p> <ul> <li>Think of five programming words you\u2019ve learned about in the previous chapters. Use these words as the keys in your glossary, and store their meanings as values.</li> <li>Print each word and its meaning as neatly formatted output. You might print the word followed by a colon and then its meaning, or print the word on one line and then print its meaning indented on a second line. Use the newline character (\\n) to insert a blank line between each word-meaning pair in your output.</li> </ul>"},{"location":"labs/lab5/#question-4","title":"Question 4\u00b6","text":"<p>Glossary 2: Now that you know how to loop through a dictionary, clean up the code from Question 3 by replacing your series of print() calls with a loop that runs through the dictionary\u2019s keys and values. When you\u2019re sure that your loop works, add five more Python terms to your glossary. When you run your program again, these new words and meanings should automatically be included in the output.</p>"},{"location":"labs/lab5/#question-5","title":"Question 5\u00b6","text":"<p>Rivers: Make a dictionary containing three major rivers and the country each river runs through. One key-value pair might be 'nile': 'egypt'.</p> <ul> <li>Use a loop to print a sentence about each river, such as The Nile runs through Egypt.</li> <li>Use a loop to print the name of each river included in the dictionary.</li> <li>Use a loop to print the name of each country included in the dictionary.</li> </ul>"},{"location":"labs/lab5/#question-6","title":"Question 6\u00b6","text":"<p>Cities: Make a dictionary called <code>cities</code>. Use the names of three cities as keys in your dictionary. Create a dictionary of information about each city and include the country that the city is in, its approximate population, and one fact about that city. The keys for each city\u2019s dictionary should be something like <code>country</code>, <code>population</code>, and <code>fact</code>. Print the name of each city and all of the information you have stored about it.</p>"},{"location":"labs/lab5/#question-7","title":"Question 7\u00b6","text":"<p>Rental Car: Write a program that asks the user what kind of rental car they would like. Print a message about that car, such as \u201cLet me see if I can find you a Subaru.\u201d</p>"},{"location":"labs/lab5/#question-8","title":"Question 8\u00b6","text":"<p>Restaurant Seating: Write a program that asks the user how many people are in their dinner group. If the answer is more than eight, print a message saying they\u2019ll have to wait for a table. Otherwise, report that their table is ready.</p>"},{"location":"labs/lab5/#question-9","title":"Question 9\u00b6","text":"<p>Multiples of Ten: Ask the user for a number, and then report whether the number is a multiple of 10 or not.</p>"},{"location":"labs/lab5/#question-10","title":"Question 10\u00b6","text":"<p>Pizza Toppings: Write a loop that prompts the user to enter a series of pizza toppings until they enter a 'quit' value. As they enter each topping, print a message saying you\u2019ll add that topping to their pizza.</p>"},{"location":"labs/lab5/#question-11","title":"Question 11\u00b6","text":"<p>Message: Write a function called <code>display_message()</code> that prints one sentence telling everyone what you are learning about in this chapter. Call the function, and make sure the message displays correctly.</p>"},{"location":"labs/lab5/#question-12","title":"Question 12\u00b6","text":"<p>Favorite Book: Write a function called <code>favorite_book()</code> that accepts one parameter, title. The function should print a message, such as <code>One of my favorite books is Alice in Wonderland</code>. Call the function, making sure to include a book title as an argument in the function call.</p>"},{"location":"labs/lab5/#question-13","title":"Question 13\u00b6","text":"<p>T-Shirt: Write a function called <code>make_shirt()</code> that accepts a size and the text of a message that should be printed on the shirt. The function should print a sentence summarizing the size of the shirt and the message printed on it.</p> <p>Call the function once using positional arguments to make a shirt. Call the function a second time using keyword arguments.</p>"},{"location":"labs/lab5/#question-14","title":"Question 14\u00b6","text":"<p>Large Shirts: Modify the <code>make_shirt()</code> function so that shirts are large by default with a message that reads I love Python. Make a large shirt and a medium shirt with the default message, and a shirt of any size with a different message.</p>"},{"location":"labs/lab5/#question-15","title":"Question 15\u00b6","text":"<p>Cities: Write a function called <code>describe_city()</code> that accepts the name of a city and its country. The function should print a simple sentence, such as <code>Reykjavik is in Iceland</code>. Give the parameter for the country a default value. Call your function for three different cities, at least one of which is not in the default country.</p>"},{"location":"labs/lab5/#question-16","title":"Question 16\u00b6","text":"<p>City Names: Write a function called <code>city_country()</code> that takes in the name of a city and its country. The function should return a string formatted like this:</p> <pre>Santiago, Chile\n</pre> <p>Call your function with at least three city-country pairs, and print the values that are returned.</p>"},{"location":"labs/lab5/#question-17","title":"Question 17\u00b6","text":"<p>Album: Write a function called <code>make_album()</code> that builds a dictionary describing a music album. The function should take in an artist name and an album title, and it should return a dictionary containing these two pieces of information. Use the function to make three dictionaries representing different albums. Print each return value to show that the dictionaries are storing the album information correctly.</p> <p>Use None to add an optional parameter to make_album() that allows you to store the number of songs on an album. If the calling line includes a value for the number of songs, add that value to the album\u2019s dictionary. Make at least one new function call that includes the number of songs on an album.</p>"},{"location":"labs/lab5/#question-18","title":"Question 18\u00b6","text":"<p>User Albums: Start with your program from Question 17. Write a <code>while</code> loop that allows users to enter an album\u2019s artist and title. Once you have that information, call <code>make_album()</code> with the user\u2019s input and print the dictionary that\u2019s created. Be sure to include a quit value in the <code>while</code> loop.</p>"},{"location":"labs/lab5/#question-19","title":"Question 19\u00b6","text":"<p>Messages: Make a list containing a series of short text messages. Pass the list to a function called <code>show_messages()</code>, which prints each text message.</p>"},{"location":"labs/lab5/#question-20","title":"Question 20\u00b6","text":"<p>Sending Messages: Start with a copy of your program from Question 19. Write a function called <code>send_messages()</code> that prints each text message and moves each message to a new list called <code>sent_messages</code> as it\u2019s printed. After calling the function, print both of your lists to make sure the messages were moved correctly.</p>"},{"location":"labs/lab5/#question-21","title":"Question 21\u00b6","text":"<p>Learning Python: Open a blank file in your text editor and write a few lines summarizing what you\u2019ve learned about Python so far. Start each line with the phrase In Python you can. . .. Save the file as learning_python.txt in the same directory as your exercises from this chapter. Write a program that reads the file and prints what you wrote three times. Print the contents once by reading in the entire file, once by looping over the file object, and once by storing the lines in a list and then working with them outside the with block.</p>"},{"location":"labs/lab5/#question-22","title":"Question 22\u00b6","text":"<p>Learning C: You can use the replace() method to replace any word in a string with a different word. Here\u2019s a quick example showing how to replace 'dog' with 'cat' in a sentence:</p> <pre>message = \"I really like dogs.\"\nmessage.replace('dog', 'cat')\n'I really like cats.'\n</pre> <p>Read in each line from the file you just created, learning_python.txt, and replace the word Python with the name of another language, such as C. Print each modified line to the screen.</p>"},{"location":"labs/lab5/#question-23","title":"Question 23\u00b6","text":"<p>Guest: Write a program that prompts the user for their name. When they respond, write their name to a file called guest.txt.</p>"},{"location":"labs/lab5/#question-24","title":"Question 24\u00b6","text":"<p>Guest Book: Write a while loop that prompts users for their name. When they enter their name, print a greeting to the screen and add a line recording their visit in a file called guest_book.txt. Make sure each entry appears on a new line in the file.</p>"},{"location":"labs/lab5/#question-25","title":"Question 25\u00b6","text":"<p>Programming Poll: Write a while loop that asks people why they like programming. Each time someone enters a reason, add their reason to a file that stores all the responses.</p>"},{"location":"labs/lab5/#question-26","title":"Question 26\u00b6","text":"<p>Addition: One common problem when prompting for numerical input occurs when people provide text instead of numbers. When you try to convert the input to an int, you\u2019ll get a ValueError. Write a program that prompts for two numbers. Add them together and print the result. Catch the ValueError if either input value is not a number, and print a friendly error message. Test your program by entering two numbers and then by entering some text instead of a number.</p>"},{"location":"labs/lab5/#question-27","title":"Question 27\u00b6","text":"<p>Addition Calculator: Wrap your code from Question 26 in a while loop so the user can continue entering numbers even if they make a mistake and enter text instead of a number.</p>"},{"location":"labs/lab5/#question-28","title":"Question 28\u00b6","text":"<p>Cats and Dogs: Make two files, cats.txt and dogs.txt. Store at least three names of cats in the first file and three names of dogs in the second file. Write a program that tries to read these files and print the contents of the file to the screen. Wrap your code in a <code>try-except</code> block to catch the <code>FileNotFound</code> error, and print a friendly message if a file is missing. Move one of the files to a different location on your system, and make sure the code in the <code>except</code> block executes properly.</p>"},{"location":"labs/lab5/#question-29","title":"Question 29\u00b6","text":"<p>Silent Cats and Dogs: Modify your except block in Question 28 to fail silently if either file is missing.</p>"},{"location":"labs/lab5/#question-30","title":"Question 30\u00b6","text":"<p>Common Words: Visit Project Gutenberg (https://gutenberg.org/) and find a few texts you\u2019d like to analyze. Download the text files for these works, or copy the raw text from your browser into a text file on your computer. You can use the <code>count()</code> method to find out how many times a word or phrase appears in a string. For example, the following code counts the number of times 'row' appears in a string:</p>"}]}